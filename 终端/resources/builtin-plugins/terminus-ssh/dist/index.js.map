{"version":3,"sources":["webpack-terminus-ssh:///webpack/universalModuleDefinition","webpack-terminus-ssh:///webpack/bootstrap","webpack-terminus-ssh:///external \"util\"","webpack-terminus-ssh:///external \"@angular/core\"","webpack-terminus-ssh:///external \"terminus-core\"","webpack-terminus-ssh:///external \"stream\"","webpack-terminus-ssh:///external \"@ng-bootstrap/ng-bootstrap\"","webpack-terminus-ssh:///external \"fs\"","webpack-terminus-ssh:///external \"events\"","webpack-terminus-ssh:///./node_modules/ssh2-streams/lib/utils.js","webpack-terminus-ssh:///../node_modules/webpack/buildin/module.js","webpack-terminus-ssh:///../node_modules/pug-runtime/index.js","webpack-terminus-ssh:///./node_modules/ssh2-streams/index.js","webpack-terminus-ssh:///external \"assert\"","webpack-terminus-ssh:///external \"ngx-toastr\"","webpack-terminus-ssh:///external \"terminus-settings\"","webpack-terminus-ssh:///./src/services/passwordStorage.service.ts","webpack-terminus-ssh:///external \"crypto\"","webpack-terminus-ssh:///external \"net\"","webpack-terminus-ssh:///./node_modules/asn1/lib/ber/errors.js","webpack-terminus-ssh:///./node_modules/asn1/lib/ber/types.js","webpack-terminus-ssh:///./node_modules/ssh2-streams/lib/constants.js","webpack-terminus-ssh:///./src/components/promptModal.component.ts","webpack-terminus-ssh:///./src/components/editConnectionModal.component.ts","webpack-terminus-ssh:///./src/components/sshModal.component.ts","webpack-terminus-ssh:///./src/services/ssh.service.ts","webpack-terminus-ssh:///./node_modules/asn1/lib/index.js","webpack-terminus-ssh:///./node_modules/semver/semver.js","webpack-terminus-ssh:///./node_modules/ssh2/lib/Channel.js","webpack-terminus-ssh:///external \"path\"","webpack-terminus-ssh:///../app/node_modules/any-promise/index.js","webpack-terminus-ssh:///./node_modules/graceful-fs/fs.js","webpack-terminus-ssh:///external \"terminus-terminal\"","webpack-terminus-ssh:///./src/components/sshSettingsTab.component.ts","webpack-terminus-ssh:///./src/index.ts","webpack-terminus-ssh:///external \"@angular/common\"","webpack-terminus-ssh:///external \"@angular/forms\"","webpack-terminus-ssh:///external \"xkeychain\"","webpack-terminus-ssh:///external \"wincredmgr\"","webpack-terminus-ssh:///./src/components/editConnectionModal.component.pug","webpack-terminus-ssh:///./node_modules/ssh2/lib/client.js","webpack-terminus-ssh:///external \"dns\"","webpack-terminus-ssh:///./node_modules/ssh2-streams/lib/sftp.js","webpack-terminus-ssh:///./node_modules/asn1/lib/ber/index.js","webpack-terminus-ssh:///./node_modules/asn1/lib/ber/reader.js","webpack-terminus-ssh:///./node_modules/asn1/lib/ber/writer.js","webpack-terminus-ssh:///./node_modules/ssh2-streams/lib/jsbn.js","webpack-terminus-ssh:///./node_modules/ssh2-streams/lib/keyParser.js","webpack-terminus-ssh:///./node_modules/ssh2-streams/lib/ssh.js","webpack-terminus-ssh:///external \"zlib\"","webpack-terminus-ssh:///external \"buffer\"","webpack-terminus-ssh:///./node_modules/streamsearch/lib/sbmh.js","webpack-terminus-ssh:///./node_modules/ssh2/lib/agent.js","webpack-terminus-ssh:///external \"child_process\"","webpack-terminus-ssh:///./node_modules/ssh2/lib/SFTPWrapper.js","webpack-terminus-ssh:///./node_modules/ssh2/lib/server.js","webpack-terminus-ssh:///./node_modules/ssh2/lib/keepalivemgr.js","webpack-terminus-ssh:///./node_modules/ssh2/lib/utils.js","webpack-terminus-ssh:///../app/node_modules/mz/fs.js","webpack-terminus-ssh:///../app/node_modules/any-promise/register.js","webpack-terminus-ssh:///../app/node_modules/any-promise/loader.js","webpack-terminus-ssh:///../app/node_modules/any-promise sync","webpack-terminus-ssh:///./node_modules/graceful-fs/graceful-fs.js","webpack-terminus-ssh:///./node_modules/graceful-fs/polyfills.js","webpack-terminus-ssh:///external \"constants\"","webpack-terminus-ssh:///./node_modules/graceful-fs/legacy-streams.js","webpack-terminus-ssh:///../app/node_modules/thenify-all/index.js","webpack-terminus-ssh:///../app/node_modules/thenify/index.js","webpack-terminus-ssh:///./src/api.ts","webpack-terminus-ssh:///./src/components/promptModal.component.pug","webpack-terminus-ssh:///./src/components/sshModal.component.pug","webpack:///./src/components/sshModal.component.scss?5ffd","webpack-terminus-ssh:///./src/components/sshModal.component.scss","webpack-terminus-ssh:///../node_modules/css-loader/lib/css-base.js","webpack-terminus-ssh:///./src/components/sshSettingsTab.component.pug","webpack-terminus-ssh:///./src/buttonProvider.ts","webpack-terminus-ssh:///external \"@angular/platform-browser\"","webpack-terminus-ssh:///./src/icons/globe.svg","webpack-terminus-ssh:///./src/config.ts","webpack-terminus-ssh:///./src/settings.ts"],"names":[],"mappings":"AAAA;AACA;AACA,+UAA+U,MAAM,6BAA6B,EAAE,YAAY,EAAE,oDAAoD,MAAM,8BAA8B,EAAE,YAAY,EAAE;AAC1e;AACA;AACA;AACA,oWAAoW,MAAM,6BAA6B,EAAE,YAAY,EAAE,oDAAoD,MAAM,8BAA8B,EAAE,YAAY,EAAE;AAC/f;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA,iC;;;;;;;;;;;;ACAA,gD;;;;;;;;;;;;ACAA,gD;;;;;;;;;;;;ACAA,mC;;;;;;;;;;;;ACAA,gD;;;;;;;;;;;;ACAA,gD;;;;;;;;;;;;ACAA,mC;;;;;;;;;;;;ACAA,aAAa,mBAAO,CAAC,gBAAQ;;AAE7B,UAAU,mBAAO,CAAC,cAAM;AACxB,iBAAiB,mBAAO,CAAC,gBAAQ,EAAE;;AAEnC,qBAAqB,mBAAO,CAAC,qBAAa;;AAE1C;AACA,qBAAqB,GAAG;AACxB;AACA;AACA,8BAA8B,OAAO;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAO,CAAC,qBAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,KAAK;AACpC;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK,mCAAmC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK,OAAO;AACZ;AACA;AACA;AACA,2BAA2B;AAC3B,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG,OAAO;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;;;;;;;;;;;;;;AC/yBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;;;ACrBa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iDAAiD,aAAa;AAC9D;AACA,iDAAiD,aAAa;AAC9D;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iDAAiD;AAC5D,WAAW,gBAAgB;AAC3B,YAAY;AACZ;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,iCAAiC;AAC5C,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,iBAAiB;AAC7D;AACA,+BAA+B,EAAE;AACjC,8BAA8B,EAAE;AAChC,6BAA6B,EAAE;AAC/B,6BAA6B,EAAE;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAO,CAAC,WAAI;AAC7B,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5PA;AACA,cAAc,mBAAO,CAAC,oBAAY;AAClC,cAAc,mBAAO,CAAC,mBAAW;AACjC,SAAS,mBAAO,CAAC,oBAAa;AAC9B,aAAa,mBAAO,CAAC,yBAAiB;AACtC,E;;;;;;;;;;;;ACLA,mC;;;;;;;;;;;;ACAA,iD;;;;;;;;;;;;ACAA,iD;;;;;;;;;;;;;;;;;;;;;;;;ACAA,2DAAkD;AAGlD,IAAI,SAAS;AACb,IAAI,UAAU;AACd,IAAI;IACA,SAAS,GAAG,mBAAO,CAAC,mBAAW,CAAC;CACnC;AAAC,OAAO,KAAK,EAAE;IACZ,IAAI;QACA,UAAU,GAAG,mBAAO,CAAC,oBAAY,CAAC;KACrC;IAAC,OAAO,MAAM,EAAE;QACb,OAAO,CAAC,IAAI,CAAC,+BAA+B,CAAC;KAChD;CACJ;AAGD,IAAa,sBAAsB,GAAnC,MAAa,sBAAsB;IAC/B,YACY,IAAY;QAAZ,SAAI,GAAJ,IAAI,CAAQ;IACpB,CAAC;IAEL,YAAY,CAAE,UAAyB,EAAE,QAAgB;QACrD,IAAI,SAAS,EAAE;YACX,SAAS,CAAC,WAAW,CAAC;gBAClB,OAAO,EAAE,UAAU,CAAC,IAAI;gBACxB,OAAO,EAAE,OAAO,UAAU,CAAC,IAAI,EAAE;gBACjC,QAAQ;aACX,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC;SACjB;aAAM;YACH,UAAU,CAAC,gBAAgB,CACvB,MAAM,EACN,QAAQ,EACR,OAAO,UAAU,CAAC,IAAI,IAAI,UAAU,CAAC,IAAI,EAAE,CAC9C;SACJ;IACL,CAAC;IAED,cAAc,CAAE,UAAyB;QACrC,IAAI,SAAS,EAAE;YACX,SAAS,CAAC,cAAc,CAAC;gBACrB,OAAO,EAAE,UAAU,CAAC,IAAI;gBACxB,OAAO,EAAE,OAAO,UAAU,CAAC,IAAI,EAAE;aACpC,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC;SACjB;aAAM;YACH,UAAU,CAAC,iBAAiB,CACxB,OAAO,UAAU,CAAC,IAAI,IAAI,UAAU,CAAC,IAAI,EAAE,CAC9C;SACJ;IACL,CAAC;IAED,YAAY,CAAE,UAAyB;QACnC,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE;YACzB,IAAI,CAAC,UAAU,IAAI,CAAC,SAAS,CAAC,WAAW,EAAE,EAAE;gBACzC,OAAO,OAAO,CAAC,IAAI,CAAC;aACvB;YACD,IAAI,SAAS,EAAE;gBACX,SAAS,CAAC,WAAW,CACjB;oBACI,OAAO,EAAE,UAAU,CAAC,IAAI;oBACxB,OAAO,EAAE,OAAO,UAAU,CAAC,IAAI,EAAE;iBACpC,EACD,CAAC,CAAC,EAAE,MAAM,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CACtD;aACJ;iBAAM;gBACH,IAAI;oBACA,OAAO,CAAC,UAAU,CAAC,eAAe,CAAC,OAAO,UAAU,CAAC,IAAI,IAAI,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC,QAAQ,CAAC;iBAC5F;gBAAC,OAAO,KAAK,EAAE;oBACZ,OAAO,CAAC,IAAI,CAAC;iBAChB;aACJ;QACL,CAAC,CAAC;IACN,CAAC;CACJ;AAxDY,sBAAsB;IADlC,iBAAU,EAAE;qCAGS,aAAM;GAFf,sBAAsB,CAwDlC;AAxDY,wDAAsB;;;;;;;;;;;;;AChBnC,mC;;;;;;;;;;;;ACAA,gC;;;;;;;;;;;;ACAA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACZA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnCA,aAAa,mBAAO,CAAC,gBAAQ;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,SAAS;AAC1E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACjYA,2DAAuE;AACvE,gFAA2D;AAK3D,IAAa,oBAAoB,GAAjC,MAAa,oBAAoB;IAK7B,YACY,aAA6B;QAA7B,kBAAa,GAAb,aAAa,CAAgB;IACrC,CAAC;IAEL,QAAQ;QACJ,UAAU,CAAC,GAAG,EAAE;YACZ,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,KAAK,EAAE;QACpC,CAAC,CAAC;IACN,CAAC;IAED,EAAE;QACE,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC;IACxC,CAAC;IAED,MAAM;QACF,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,EAAE,CAAC;IAChC,CAAC;CACJ;AArBY;IAAR,YAAK,EAAE;;mDAAc;AACb;IAAR,YAAK,EAAE;;sDAAkB;AACN;IAAnB,gBAAS,CAAC,OAAO,CAAC;8BAAQ,iBAAU;mDAAA;AAH5B,oBAAoB;IAHhC,gBAAS,CAAC;QACP,QAAQ,EAAE,mBAAO,CAAC,qCAA6B,CAAC;KACnD,CAAC;qCAO6B,6BAAc;GANhC,oBAAoB,CAsBhC;AAtBY,oDAAoB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNjC,2DAAyC;AACzC,gFAA2D;AAC3D,oEAA+D;AAC/D,qGAA4E;AAM5E,IAAa,4BAA4B,GAAzC,MAAa,4BAA4B;IAKrC,YACY,aAA6B,EAC7B,QAAyB,EACzB,OAAuB,EACvB,eAAuC;QAHvC,kBAAa,GAAb,aAAa,CAAgB;QAC7B,aAAQ,GAAR,QAAQ,CAAiB;QACzB,YAAO,GAAP,OAAO,CAAgB;QACvB,oBAAe,GAAf,eAAe,CAAwB;QAE/C,IAAI,CAAC,SAAS,GAAG,EAAE,MAAM,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE;IAC7C,CAAC;IAEK,QAAQ;;YACV,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QACxF,CAAC;KAAA;IAED,kBAAkB;QACd,IAAI,CAAC,gBAAgB,GAAG,KAAK;QAC7B,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC,IAAI,CAAC,UAAU,CAAC;IACxD,CAAC;IAED,gBAAgB;QACZ,IAAI,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,cAAc,CAC1C,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,EACxB;YACI,KAAK,EAAE,oBAAoB;SAC9B,CACJ;QACD,IAAI,IAAI,EAAE;YACN,IAAI,CAAC,UAAU,CAAC,UAAU,GAAG,IAAI,CAAC,CAAC,CAAC;SACvC;IACL,CAAC;IAED,IAAI;QACA,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC;IAC7C,CAAC;IAED,MAAM;QACF,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE;IAChC,CAAC;IAED,YAAY,CAAE,MAAmB;QAC7B,IAAI,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC;QACnD,IAAI,KAAK,GAAG,CAAC,EAAE;YACX,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC;YACxC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC;SACvD;IACL,CAAC;IAED,cAAc,CAAE,MAAmB;QAC/B,IAAI,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC;QACnD,IAAI,KAAK,IAAI,CAAC,IAAI,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;YAC1D,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC;YACxC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC;SACvD;IACL,CAAC;IAED,YAAY,CAAE,MAAmB;QAC7B,IAAI,OAAO,CAAC,SAAS,CAAC,EAAE;YACpB,IAAI,CAAC,UAAU,CAAC,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,MAAM,CAAC;SAC9E;IACL,CAAC;IAED,SAAS;QACL,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE;YAC1B,IAAI,CAAC,UAAU,CAAC,OAAO,GAAG,EAAE;SAC/B;QACD,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,mBAAK,IAAI,CAAC,SAAS,EAAE;QACjD,IAAI,CAAC,WAAW,EAAE;IACtB,CAAC;IAED,WAAW;QACP,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,EAAE;QAC1B,IAAI,CAAC,SAAS,CAAC,IAAI,GAAG,EAAE;QACxB,IAAI,CAAC,SAAS,CAAC,OAAO,GAAG,KAAK;QAC9B,IAAI,CAAC,SAAS,CAAC,QAAQ,GAAG,KAAK;IACnC,CAAC;CACJ;AA/EY,4BAA4B;IAHxC,gBAAS,CAAC;QACP,QAAQ,EAAE,mBAAO,CAAC,6CAAqC,CAAC;KAC3D,CAAC;qCAO6B,6BAAc;QACnB,+BAAe;QAChB,8BAAc;QACN,gDAAsB;GAT1C,4BAA4B,CA+ExC;AA/EY,oEAA4B;;;;;;;;;;;;;;;;;;;;;;;;;ACTzC,2DAAyC;AACzC,gFAA2D;AAC3D,+DAA0C;AAC1C,oEAAyD;AACzD,6EAAwD;AACxD,6EAAoD;AAOpD,IAAa,iBAAiB,GAA9B,MAAa,iBAAiB;IAQ1B,YACW,aAA6B,EAC5B,MAAqB,EACrB,GAAe,EACf,GAAe,EACf,MAAqB;QAJtB,kBAAa,GAAb,aAAa,CAAgB;QAC5B,WAAM,GAAN,MAAM,CAAe;QACrB,QAAG,GAAH,GAAG,CAAY;QACf,QAAG,GAAH,GAAG,CAAY;QACf,WAAM,GAAN,MAAM,CAAe;QAPjC,mBAAc,GAA4B,EAAE;IAQxC,CAAC;IAEL,QAAQ;QACJ,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,WAAW;QACpD,IAAI,MAAM,CAAC,YAAY,CAAC,cAAc,EAAE;YACpC,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,cAAc,CAAC;SACvE;QACD,IAAI,CAAC,OAAO,EAAE;IAClB,CAAC;IAED,YAAY;QACR,IAAI,IAAI,GAAG,MAAM;QACjB,IAAI,IAAI,GAAG,IAAI,CAAC,WAAW;QAC3B,IAAI,IAAI,GAAG,EAAE;QACb,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;YACpB,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;SACjC;QACD,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;YACpB,IAAI,GAAG,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YACnC,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;SAC5B;QAED,IAAI,UAAU,GAAkB;YAC5B,IAAI,EAAE,IAAI,CAAC,WAAW;YACtB,IAAI,EAAE,IAAI,EAAE,IAAI;SACnB;QACD,MAAM,CAAC,YAAY,CAAC,cAAc,GAAG,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC;QAC/D,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC;IAC5B,CAAC;IAED,mBAAmB;QACf,MAAM,CAAC,YAAY,CAAC,cAAc,GAAG,IAAI;QACzC,IAAI,CAAC,cAAc,GAAG,IAAI;IAC9B,CAAC;IAED,OAAO,CAAE,UAAyB;QAC9B,IAAI,CAAC,KAAK,EAAE;QACZ,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;YACvC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,sBAAsB,KAAK,EAAE,CAAC;QACpD,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE;YACT,UAAU,CAAC,GAAG,EAAE;gBACZ,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,WAAW,EAAE;YACpC,CAAC,CAAC;QACN,CAAC,CAAC;IACN,CAAC;IAED,iBAAiB;QACb,IAAI,CAAC,KAAK,EAAE;QACZ,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,wCAAoB,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC;IACnE,CAAC;IAED,KAAK;QACD,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE;IAC9B,CAAC;IAED,OAAO;QACH,IAAI,CAAC,WAAW,GAAG,EAAE;QAErB,IAAI,WAAW,GAAG,IAAI,CAAC,WAAW;QAClC,IAAI,IAAI,CAAC,WAAW,EAAE;YAClB,WAAW,GAAG,WAAW,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,UAAU,CAAC,IAAI,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;SAChI;QAED,KAAK,IAAI,UAAU,IAAI,WAAW,EAAE;YAChC,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,IAAI,IAAI;YAC3C,IAAI,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,UAAU,CAAC,KAAK,CAAC;YACnE,IAAI,CAAC,KAAK,EAAE;gBACR,KAAK,GAAG;oBACJ,IAAI,EAAE,UAAU,CAAC,KAAK;oBACtB,WAAW,EAAE,EAAE;iBAClB;gBACD,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC;aAC/B;YACD,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC;SACrC;IACL,CAAC;CACJ;AA1FY,iBAAiB;IAJ7B,gBAAS,CAAC;QACP,QAAQ,EAAE,mBAAO,CAAC,kCAA0B,CAAC;QAC7C,MAAM,EAAE,CAAC,mBAAO,CAAC,mCAA2B,CAAC,CAAC;KACjD,CAAC;qCAU4B,6BAAc;QACpB,6BAAa;QAChB,wBAAU;QACV,0BAAU;QACP,0BAAa;GAbxB,iBAAiB,CA0F7B;AA1FY,8CAAiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZ9B,2DAAkD;AAClD,gFAAqD;AACrD,mDAA6B;AAC7B,8DAA2B;AAC3B,+DAA4B;AAC5B,+DAA0C;AAC1C,oEAAwF;AACxF,6EAAwD;AACxD,oDAAkD;AAClD,mGAA0E;AAC1E,2FAAkE;AAClE,MAAM,EAAE,UAAU,EAAE,GAAG,mBAAO,CAAC,sBAAc,CAAC;AAG9C,IAAa,UAAU,GAAvB,MAAa,UAAU;IAGnB,YACI,GAAe,EACP,GAAe,EACf,IAAY,EACZ,QAAkB,EAClB,OAAuB,EACvB,eAAuC,EACvC,MAAqB;QALrB,QAAG,GAAH,GAAG,CAAY;QACf,SAAI,GAAJ,IAAI,CAAQ;QACZ,aAAQ,GAAR,QAAQ,CAAU;QAClB,YAAO,GAAP,OAAO,CAAgB;QACvB,oBAAe,GAAf,eAAe,CAAwB;QACvC,WAAM,GAAN,MAAM,CAAe;QAE7B,IAAI,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC;IACnC,CAAC;IAEK,OAAO,CAAE,UAAyB;;YACpC,IAAI,UAAU,GAAW,IAAI;YAC7B,IAAI,oBAAoB,GAAW,IAAI;YACvC,IAAI,cAAc,GAAG,UAAU,CAAC,UAAU;YAC1C,IAAI,CAAC,cAAc,EAAE;gBACjB,IAAI,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,MAAM,EAAE,QAAQ,CAAC;gBAC/D,IAAI,MAAM,EAAE,CAAC,MAAM,CAAC,WAAW,CAAC,EAAE;oBAC9B,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,oCAAoC,EAAE,WAAW,CAAC;oBACnE,cAAc,GAAG,WAAW;iBAC/B;aACJ;YAED,IAAI,cAAc,EAAE;gBAChB,IAAI;oBACA,UAAU,GAAG,CAAC,MAAM,EAAE,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC,CAAC,QAAQ,EAAE;iBAC9D;gBAAC,OAAO,KAAK,EAAE;oBACZ,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,qCAAqC,CAAC;iBAC7D;gBAED,IAAI,UAAU,EAAE;oBACZ,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,yBAAyB,EAAE,cAAc,CAAC;oBAE3D,IAAI,SAAS,GAAG,UAAU,CAAC,QAAQ,CAAC,WAAW,CAAC;oBAChD,IAAI,cAAc,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;wBAC/C,SAAS,GAAG,SAAS,IAAI,UAAU,CAAC,QAAQ,CAAC,aAAa,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,kBAAkB,CAAC;qBAC1G;oBACD,IAAI,SAAS,EAAE;wBACX,IAAI,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,4CAAoB,CAAC;wBACpD,KAAK,CAAC,iBAAiB,CAAC,MAAM,GAAG,wBAAwB;wBACzD,KAAK,CAAC,iBAAiB,CAAC,QAAQ,GAAG,IAAI;wBACvC,IAAI;4BACA,oBAAoB,GAAG,MAAM,KAAK,CAAC,MAAM;yBAC5C;wBAAC,OAAO,IAAI,EAAE,GAAG,CAAC,sBAAsB;qBAC5C;iBACJ;aACJ;YAED,IAAI,GAAG,GAAG,IAAI,aAAM,EAAE;YACtB,IAAI,SAAS,GAAG,KAAK;YACrB,IAAI,aAAa,GAAW,IAAI;YAChC,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBAClC,GAAG,CAAC,EAAE,CAAC,OAAO,EAAE,GAAG,EAAE;oBACjB,SAAS,GAAG,IAAI;oBAChB,IAAI,aAAa,EAAE;wBACf,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,UAAU,EAAE,aAAa,CAAC;qBAC/D;oBACD,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC;gBAC1B,CAAC,CAAC;gBACF,GAAG,CAAC,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,EAAE;oBACpB,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC,UAAU,CAAC;oBAC/C,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE;wBACf,IAAI,SAAS,EAAE;4BACX,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC;yBACtC;6BAAM;4BACH,MAAM,CAAC,KAAK,CAAC;yBAChB;oBACL,CAAC,CAAC;gBACN,CAAC,CAAC;gBACF,GAAG,CAAC,EAAE,CAAC,sBAAsB,EAAE,CAAC,IAAI,EAAE,YAAY,EAAE,gBAAgB,EAAE,OAAO,EAAE,MAAM,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAS,EAAE;oBAC/G,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,YAAY,EAAE,gBAAgB,CAAC;oBACjD,IAAI,OAAO,GAAG,EAAE;oBAChB,KAAK,IAAI,MAAM,IAAI,OAAO,EAAE;wBACxB,IAAI,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,4CAAoB,CAAC;wBACpD,KAAK,CAAC,iBAAiB,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM;wBAC9C,KAAK,CAAC,iBAAiB,CAAC,QAAQ,GAAG,CAAC,MAAM,CAAC,IAAI;wBAC/C,OAAO,CAAC,IAAI,CAAC,MAAM,KAAK,CAAC,MAAM,CAAC;qBACnC;oBACD,MAAM,CAAC,OAAO,CAAC;gBACnB,CAAC,EAAC,CAAC;gBAEH,IAAI,KAAK,GAAW,IAAI;gBACxB,IAAI,IAAI,CAAC,OAAO,CAAC,QAAQ,KAAK,wBAAQ,CAAC,OAAO,EAAE;oBAC5C,KAAK,GAAG,SAAS;iBACpB;qBAAM;oBACH,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,aAAa;iBACpC;gBAED,GAAG,CAAC,OAAO,CAAC;oBACR,IAAI,EAAE,UAAU,CAAC,IAAI;oBACrB,IAAI,EAAE,UAAU,CAAC,IAAI,IAAI,EAAE;oBAC3B,QAAQ,EAAE,UAAU,CAAC,IAAI;oBACzB,QAAQ,EAAE,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE;oBAChD,UAAU;oBACV,UAAU,EAAE,oBAAoB;oBAChC,WAAW,EAAE,IAAI;oBACjB,KAAK;oBACL,YAAY,EAAE,CAAC,CAAC,KAAK;oBACrB,iBAAiB,EAAE,UAAU,CAAC,iBAAiB;oBAC/C,iBAAiB,EAAE,UAAU,CAAC,iBAAiB;oBAC/C,YAAY,EAAE,UAAU,CAAC,YAAY;iBACxC,CAAC;gBAEF,IAAI,oBAAoB,GAAG,KAAK,CAE/B;gBAAC,GAAW,CAAC,MAAM,CAAC,QAAQ,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAS,EAAE;oBAC3D,IAAI,UAAU,CAAC,QAAQ,EAAE;wBACrB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,uBAAuB,CAAC;wBACzC,OAAO,UAAU,CAAC,QAAQ;qBAC7B;oBAED,IAAI,CAAC,oBAAoB,EAAE;wBACvB,IAAI,QAAQ,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,UAAU,CAAC;wBAClE,IAAI,QAAQ,EAAE;4BACV,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,sBAAsB,CAAC;4BACxC,oBAAoB,GAAG,IAAI;4BAC3B,OAAO,QAAQ;yBAClB;qBACJ;oBAED,IAAI,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,4CAAoB,CAAC;oBACpD,KAAK,CAAC,iBAAiB,CAAC,MAAM,GAAG,gBAAgB,UAAU,CAAC,IAAI,IAAI,UAAU,CAAC,IAAI,EAAE;oBACrF,KAAK,CAAC,iBAAiB,CAAC,QAAQ,GAAG,IAAI;oBACvC,aAAa,GAAG,MAAM,KAAK,CAAC,MAAM;oBAClC,OAAO,aAAa;gBACxB,CAAC,EAAC;YACN,CAAC,CAAC;YAEF,IAAI;gBACA,IAAI,KAAK,GAAG,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;oBAC9C,GAAG,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,gBAAgB,EAAE,EAAE,CAAC,GAAG,EAAE,KAAK,EAAE,EAAE;wBACjD,IAAI,GAAG,EAAE;4BACL,MAAM,CAAC,GAAG,CAAC;yBACd;6BAAM;4BACH,OAAO,CAAC,KAAK,CAAC;yBACjB;oBACL,CAAC,CAAC;gBACN,CAAC,CAAC;gBAEF,IAAI,OAAO,GAAG,IAAI,gBAAU,CAAC,KAAK,EAAE,UAAU,CAAC;gBAE/C,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,CAC1C,wCAAoB,EACpB,EAAE,OAAO,EAAE,cAAc,EAAE,EAAE,EAAE,CACV,CAAC;aAC7B;YAAC,OAAO,KAAK,EAAE;gBACZ,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC;gBAClB,MAAM,KAAK;aACd;QACL,CAAC;KAAA;CACJ;AA1JY,UAAU;IADtB,iBAAU,EAAE;qCAKA,0BAAU;QACF,0BAAU;QACT,aAAM;QACF,uBAAQ;QACT,8BAAc;QACN,gDAAsB;QAC/B,0BAAa;GAVxB,UAAU,CA0JtB;AA1JY,gCAAU;AA4JvB,MAAM,aAAa,GAAG,UAAU,CAAC,SAAS,CAAC,YAAY;AACvD,UAAU,CAAC,SAAS,CAAC,YAAY,GAAG,UAAgB,QAAQ,EAAE,UAAU;;QACpE,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,QAAQ,EAAE,MAAM,UAAU,EAAE,CAAC;IAC1D,CAAC;CAAA;;;;;;;;;;;;;AC7KD;;AAEA;AACA;;AAEA,UAAU,mBAAO,CAAC,qBAAa;;;;AAI/B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;;;;;;;;;;;ACnBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,oCAAoC;AACxD,0BAA0B,oCAAoC;AAC9D,0BAA0B,oCAAoC;AAC9D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,sCAAsC;AACtC,oCAAoC;AACpC,sCAAsC;AACtC,oCAAoC;AACpC,sCAAsC;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,2BAA2B;AAC3B,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,2BAA2B;AAC3B,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,sF;AACA;;;;;;;;;;;;;AC3yCA,eAAe,mBAAO,CAAC,aAAM;AAC7B,mBAAmB,mBAAO,CAAC,eAAQ;AACnC,qBAAqB,mBAAO,CAAC,eAAQ;AACrC,qBAAqB,mBAAO,CAAC,eAAQ;;AAErC,aAAa,mBAAO,CAAC,sBAAc;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC,2BAA2B;;AAE3B;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,4BAA4B;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACzfA,iD;;;;;;;;;;;;ACAA,iBAAiB,mBAAO,CAAC,oBAAY;;;;;;;;;;;;;;ACAzB;;AAEZ,SAAS,mBAAO,CAAC,WAAI;;AAErB;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;;ACpBA,iD;;;;;;;;;;;;;;;;;;;;;;;;ACAA,2DAAyC;AACzC,gFAAqD;AACrD,oEAA6C;AAE7C,uGAA8E;AAC9E,uFAA8D;AAK9D,IAAa,uBAAuB,GAApC,MAAa,uBAAuB;IAKhC,YACW,MAAqB,EACpB,QAAkB;QADnB,WAAM,GAAN,MAAM,CAAe;QACpB,aAAQ,GAAR,QAAQ,CAAU;QAJ9B,mBAAc,GAA4B,EAAE;QAMxC,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,WAAW;QACpD,IAAI,CAAC,OAAO,EAAE;IAClB,CAAC;IAED,gBAAgB;QACZ,IAAI,UAAU,GAAkB;YAC5B,IAAI,EAAE,EAAE;YACR,IAAI,EAAE,EAAE;YACR,IAAI,EAAE,EAAE;YACR,IAAI,EAAE,MAAM;SACf;QAED,IAAI,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,4DAA4B,CAAC;QAC5D,KAAK,CAAC,iBAAiB,CAAC,UAAU,GAAG,UAAU;QAC/C,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;YACvB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC;YAC7B,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW;YACpD,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE;YAClB,IAAI,CAAC,OAAO,EAAE;QAClB,CAAC,CAAC;IACN,CAAC;IAED,cAAc,CAAE,UAAyB;QACrC,IAAI,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,4DAA4B,CAAC;QAC5D,KAAK,CAAC,iBAAiB,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,UAAU,CAAC;QAClE,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;YACvB,MAAM,CAAC,MAAM,CAAC,UAAU,EAAE,MAAM,CAAC;YACjC,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE;YAClB,IAAI,CAAC,OAAO,EAAE;QAClB,CAAC,CAAC;IACN,CAAC;IAED,gBAAgB,CAAE,UAAyB;QACvC,IAAI,OAAO,CAAC,WAAW,UAAU,CAAC,IAAI,IAAI,CAAC,EAAE;YACzC,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,UAAU,CAAC;YACjE,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW;YACpD,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE;YAClB,IAAI,CAAC,OAAO,EAAE;SACjB;IACL,CAAC;IAED,SAAS,CAAE,KAA0B;QACjC,IAAI,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,4CAAoB,CAAC;QACpD,KAAK,CAAC,iBAAiB,CAAC,MAAM,GAAG,gBAAgB;QACjD,KAAK,CAAC,iBAAiB,CAAC,KAAK,GAAG,KAAK,CAAC,IAAI;QAC1C,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;YACvB,IAAI,MAAM,EAAE;gBACR,KAAK,IAAI,UAAU,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,KAAK,KAAK,CAAC,IAAI,CAAC,EAAE;oBACzE,UAAU,CAAC,KAAK,GAAG,MAAM;iBAC5B;gBACD,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE;gBAClB,IAAI,CAAC,OAAO,EAAE;aACjB;QACL,CAAC,CAAC;IACN,CAAC;IAED,WAAW,CAAE,KAA0B;QACnC,IAAI,OAAO,CAAC,WAAW,KAAK,IAAI,CAAC,EAAE;YAC/B,KAAK,IAAI,UAAU,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,KAAK,KAAK,CAAC,IAAI,CAAC,EAAE;gBACzE,UAAU,CAAC,KAAK,GAAG,IAAI;aAC1B;YACD,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE;YAClB,IAAI,CAAC,OAAO,EAAE;SACjB;IACL,CAAC;IAED,OAAO;QACH,IAAI,CAAC,WAAW,GAAG,EAAE;QAErB,KAAK,IAAI,UAAU,IAAI,IAAI,CAAC,WAAW,EAAE;YACrC,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,IAAI,IAAI;YAC3C,IAAI,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,UAAU,CAAC,KAAK,CAAC;YACnE,IAAI,CAAC,KAAK,EAAE;gBACR,KAAK,GAAG;oBACJ,IAAI,EAAE,UAAU,CAAC,KAAK;oBACtB,WAAW,EAAE,EAAE;iBAClB;gBACD,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC;aAC/B;YACD,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC;SACrC;IACL,CAAC;CACJ;AA3FY,uBAAuB;IAHnC,gBAAS,CAAC;QACP,QAAQ,EAAE,mBAAO,CAAC,wCAAgC,CAAC;KACtD,CAAC;qCAOqB,6BAAa;QACV,uBAAQ;GAPrB,uBAAuB,CA2FnC;AA3FY,0DAAuB;;;;;;;;;;;;;;;;;;;;;;;;;ACVpC,2DAAwC;AACxC,gEAA8C;AAC9C,8DAA4C;AAC5C,gFAAsD;AACtD,+DAAyC;AACzC,oEAAqE;AACrE,qFAA8C;AAC9C,6EAAuD;AAEvD,kHAAyF;AACzF,4FAAmE;AACnE,kGAAyE;AACzE,wGAA+E;AAC/E,4EAAmD;AACnD,oGAA2E;AAE3E,yEAAiD;AACjD,yDAA4C;AAC5C,6DAAmD;AA8BnD,IAAqB,SAAS,GAA9B,MAAqB,SAAS;CAAI;AAAb,SAAS;IA5B7B,eAAQ,CAAC;QACN,OAAO,EAAE;YACL,wBAAS;YACT,qBAAY;YACZ,mBAAW;YACX,yBAAY;YACZ,uBAAkB;SACrB;QACD,SAAS,EAAE;YACP,gDAAsB;YACtB,wBAAU;YACV,EAAE,OAAO,EAAE,qCAAqB,EAAE,QAAQ,EAAE,+BAAc,EAAE,KAAK,EAAE,IAAI,EAAE;YACzE,EAAE,OAAO,EAAE,8BAAc,EAAE,QAAQ,EAAE,0BAAiB,EAAE,KAAK,EAAE,IAAI,EAAE;YACrE,EAAE,OAAO,EAAE,uCAAmB,EAAE,QAAQ,EAAE,iCAAsB,EAAE,KAAK,EAAE,IAAI,EAAE;SAClF;QACD,eAAe,EAAE;YACb,4DAA4B;YAC5B,4CAAoB;YACpB,sCAAiB;YACjB,kDAAuB;SAC1B;QACD,YAAY,EAAE;YACV,4DAA4B;YAC5B,4CAAoB;YACpB,sCAAiB;YACjB,kDAAuB;SAC1B;KACJ,CAAC;GACmB,SAAS,CAAI;kBAAb,SAAS;;;;;;;;;;;;;AChD9B,iD;;;;;;;;;;;;ACAA,iD;;;;;;;;;;;;ACAA,4DAA4D,oDAAoD,6BAA6B;AAC7I,iD;;;;;;;;;;;;ACDA,4DAA4D,qDAAqD,6BAA6B;AAC9I,iD;;;;;;;;;;;;ACDA,wDAAU,mBAAO,CAAC,mDAA6C;;AAE/D,2BAA2B,kCAAkC,aAAa,i7LAAi7L;AAC3/L;;AAEA,iD;;;;;;;;;;;;;ACLA,aAAa,mBAAO,CAAC,gBAAQ;AAC7B,aAAa,mBAAO,CAAC,aAAK;AAC1B,gBAAgB,mBAAO,CAAC,aAAK;AAC7B,mBAAmB,mBAAO,CAAC,eAAQ;AACnC,eAAe,mBAAO,CAAC,aAAM;AAC7B;;AAEA,mBAAmB,mBAAO,CAAC,sBAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,mBAAO,CAAC,mBAAW;AACjC,iBAAiB,mBAAO,CAAC,iBAAS;AAClC,kBAAkB,mBAAO,CAAC,uBAAe;;AAEzC;AACA,iDAAiD,GAAG;AACpD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;;AAEnB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,8BAA8B,+BAA+B,EAAE;AAC/D;AACA;AACA;AACA,8BAA8B,+BAA+B,EAAE;AAC/D;;AAEA,0BAA0B,8BAA8B,EAAE;AAC1D;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,4BAA4B,8BAA8B,EAAE;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+BAA+B,EAAE;AAC/D;;AAEA,0BAA0B,oBAAoB,EAAE;AAChD;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C,iBAAiB;AAC7D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;;AAEA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,gBAAgB,mBAAO,CAAC,kBAAU;AAClC;AACA;AACA;AACA;AACA;;AAEA,wBAAwB;;;;;;;;;;;;;ACngDxB,gC;;;;;;;;;;;;ACAA;;AAEA,sBAAsB,mBAAO,CAAC,eAAQ;AACtC,qBAAqB,mBAAO,CAAC,eAAQ;AACrC,qBAAqB,mBAAO,CAAC,eAAQ;AACrC,gBAAgB,mBAAO,CAAC,WAAI;AAC5B,WAAW,mBAAO,CAAC,aAAM;AACzB;AACA;AACA,oBAAoB,mBAAO,CAAC,eAAQ;AACpC,SAAS,mBAAO,CAAC,WAAI;;AAErB,iBAAiB,mBAAO,CAAC,gBAAS;AAClC,cAAc,mBAAO,CAAC,gBAAS;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA,mDAAmD;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD,6CAA6C,UAAU;AACvD;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC,kBAAkB,EAAE;AAC3D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA;;AAEA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD,6CAA6C,UAAU;AACvD;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA,0CAA0C,SAAS;AACnD;;AAEA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD,6CAA6C,UAAU;AACvD;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD,6CAA6C,UAAU;AACvD;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,WAAW;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD,6CAA6C,UAAU;AACvD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,uCAAuC,SAAS;AAChD,6CAA6C,UAAU;AACvD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,SAAS;AAChC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,8BAA8B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;;;;;;;;;;;;;;ACr5FA;;AAEA,aAAa,mBAAO,CAAC,kBAAU;AAC/B,YAAY,mBAAO,CAAC,iBAAS;;AAE7B,aAAa,mBAAO,CAAC,kBAAU;AAC/B,aAAa,mBAAO,CAAC,kBAAU;;;AAG/B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1BA;;AAEA,aAAa,mBAAO,CAAC,gBAAQ;;AAE7B,WAAW,mBAAO,CAAC,iBAAS;AAC5B,aAAa,mBAAO,CAAC,kBAAU;;;AAG/B;;AAEA;;;;AAIA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,oBAAoB;AACxC,CAAC;;AAED;AACA;AACA,oBAAoB,uBAAuB;AAC3C,CAAC;;AAED;AACA,oBAAoB,oCAAoC;AACxD,CAAC;;AAED;AACA,oBAAoB,wCAAwC;AAC5D,CAAC;;;AAGD;AACA,2CAA2C;AAC3C;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,UAAU;AAC7B;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C;AAC5C;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4CAA4C;;AAE5C;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,cAAc;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,4CAA4C;AAC5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;AAIA;;AAEA;;;;;;;;;;;;;ACpQA;;AAEA,aAAa,mBAAO,CAAC,gBAAQ;AAC7B,WAAW,mBAAO,CAAC,iBAAS;AAC5B,aAAa,mBAAO,CAAC,kBAAU;;;AAG/B;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;;;AAIA;;AAEA;AACA,6CAA6C;;AAE7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,GAAG;AACvB;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;;AAEA;;;;;;;;;;;;;AC3TA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,6BAA6B;;AAE7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,YAAY,SAAS;AACrB;AACA,YAAY,SAAS;;AAErB,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,eAAe,cAAc,UAAU;;AAExD;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,QAAQ,qBAAqB,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,UAAU,iBAAiB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc,KAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,eAAe,+BAA+B,UAAU;;AAE7E;AACA,kBAAkB,sCAAsC;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,OAAO,SAAS;AACvC,qBAAqB,OAAO,QAAQ;AACpC,qBAAqB,OAAO,QAAQ;AACpC,qBAAqB,OAAO,QAAQ;AACpC,qBAAqB,OAAO,QAAQ;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,cAAc,QAAQ;AACtB;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,SAAS,QAAQ;AACrC;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,eAAe,oBAAoB,oBAAoB;AACvD,QAAQ,cAAc,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B,qBAAqB,2BAA2B;AAChD,wBAAwB,mBAAmB,gBAAgB;AAC3D,sBAAsB,eAAe,gBAAgB;;AAErD;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,4BAA4B;AAC5B,8BAA8B;AAC9B,6CAA6C;AAC7C;AACA;AACA,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,cAAc,UAAU;AACjD;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB,yBAAyB,eAAe,gBAAgB;;AAExD,oBAAoB;AACpB,2BAA2B,mBAAmB,gBAAgB;;AAE9D;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,6CAA6C;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,WAAW,QAAQ,QAAQ;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,oBAAoB,eAAe,gBAAgB,UAAU;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,6CAA6C;;AAErE;AACA,yBAAyB,6CAA6C;;AAEtE;AACA,0BAA0B,iDAAiD;;AAE3E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc,KAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,8BAA8B;AACpD,mBAAmB,oCAAoC;AACvD,mBAAmB,oCAAoC;;AAEvD;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,YAAY;AAClC,mBAAmB,eAAe,4BAA4B,UAAU;;AAExE;AACA,qBAAqB,YAAY;AACjC,kBAAkB,eAAe,2BAA2B,UAAU;;AAEtE;AACA,sBAAsB,YAAY;AAClC,mBAAmB,eAAe,4BAA4B,UAAU;;AAExE;AACA,yBAAyB,aAAa;AACtC,sBAAsB,eAAe,+BAA+B,UAAU;;AAE9E;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;;AAEA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,UAAU,SAAS;AAC1C,qBAAqB,SAAS,QAAQ;AACtC,oBAAoB,SAAS,QAAQ;AACrC,kBAAkB,SAAS,QAAQ;AACnC;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,UAAU,KAAK;AAChC;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,gCAAgC;;AAEtD;AACA,wBAAwB,oCAAoC;;AAE5D;AACA,uBAAuB,iCAAiC;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe,iBAAiB,UAAU;;AAE7D;AACA,wBAAwB,eAAe,iBAAiB,UAAU;;AAElE;AACA,wBAAwB,eAAe,sBAAsB,UAAU;;AAEvE;AACA,qBAAqB,eAAe,kBAAkB,UAAU;;AAEhE;AACA,sBAAsB,eAAe,yBAAyB,UAAU;;AAExE;AACA,yBAAyB,eAAe,yBAAyB,UAAU;;AAE3E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,UAAU;AAC5B,wBAAwB,mBAAmB;AAC3C,sBAAsB,eAAe;;AAErC;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,kCAAkC;;AAErD;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B,0BAA0B,OAAO;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,eAAe,aAAa,gBAAgB,UAAU;AAC9D;;AAEA,2BAA2B,UAAU;;AAErC;AACA;AACA;AACA,wBAAwB,kBAAkB,WAAW;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB,4BAA4B,eAAe,gBAAgB;;AAE3D,iBAAiB;AACjB,8BAA8B,mBAAmB,gBAAgB;;AAEjE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,SAAS,KAAK;AACrC,sBAAsB,cAAc,KAAK;AACzC,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,eAAe,eAAe,QAAQ;AAC1D,8BAA8B,OAAO,OAAO,QAAQ,QAAQ;AAC5D;AACA;;AAEA;AACA,oBAAoB,OAAO,QAAQ;AACnC,mBAAmB,eAAe,KAAK;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,WAAW,OAAO,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB,cAAc;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB,cAAc;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,qCAAqC;AACrC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;AChqCA;AACA;AACA;;AAEA;AACA,UAAU,mBAAO,CAAC,cAAM;AACxB,aAAa,mBAAO,CAAC,gBAAQ;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA,kBAAkB;AAClB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,mBAAO,CAAC,gBAAS;;AAE/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;;;;;;;;;;;;AC9OA;AACA;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,gBAAQ;AAC7B,WAAW,mBAAO,CAAC,cAAM;AACzB,sBAAsB,mBAAO,CAAC,eAAQ;AACtC,eAAe,mBAAO,CAAC,aAAM;AAC7B,cAAc,mBAAO,CAAC,aAAM;AAC5B,qBAAqB,mBAAO,CAAC,gBAAQ;;AAErC,mBAAmB,mBAAO,CAAC,sBAAc;;AAEzC,aAAa,mBAAO,CAAC,qBAAa;AAClC,YAAY,mBAAO,CAAC,gBAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAO,CAAC,yBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,iCAAiC,iBAAiB,EAAE;;AAEpD;AACA;AACA,uCAAuC,uBAAuB,EAAE;AAChE,GAAG;AACH;AACA,2CAA2C,2BAA2B,EAAE;AACxE;AACA,kCAAkC,qCAAqC,EAAE;AACzE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,SAAS;AAC5C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC;AAChC;AACA;;AAEA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,mDAAmD;AACnD;;AAEA;AACA;AACA,kDAAkD;AAClD;;AAEA;AACA;AACA,yCAAyC;AACzC;AACA;;AAEA;AACA;AACA,wCAAwC;AACxC;AACA;;AAEA;AACA;AACA,qCAAqC;AACrC;;AAEA;AACA,wDAAwD;AACxD,kBAAkB;;AAElB;AACA;AACA;AACA;AACA,mDAAmD;AACnD;;AAEA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;;AAEA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;;AAEA;AACA;AACA;AACA;AACA,gDAAgD;;AAEhD,4DAA4D;;AAE5D,yDAAyD;AACzD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,yDAAyD,GAAG;AAC5D;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,sBAAsB;AACtB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,UAAU,UAAU;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,UAAU,UAAU;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,+BAA+B;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,sCAAsC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,kCAAkC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,wCAAwC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,kCAAkC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,8BAA8B;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,gCAAgC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,+BAA+B;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,oCAAoC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,iCAAiC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,mCAAmC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,qDAAqD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kDAAkD;AAClD;;AAEA;AACA;AACA,mDAAmD;AACnD;;AAEA;AACA;AACA,wCAAwC;AACxC;AACA;;AAEA;AACA;AACA,yCAAyC;AACzC;AACA;;AAEA;AACA;AACA,gCAAgC;AAChC;;AAEA;AACA,wDAAwD;AACxD,kBAAkB;;AAElB;AACA;AACA;AACA;AACA,mDAAmD;AACnD;;AAEA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;;AAEA;AACA;AACA;AACA;AACA,2CAA2C;;AAE3C,4DAA4D;;AAE5D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8BAA8B;AAC9B;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC1xKA,iC;;;;;;;;;;;;ACAA,mC;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,eAAQ;AACnC,eAAe,mBAAO,CAAC,aAAM;;AAE7B;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,aAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;ACpNA,8DAAa,mBAAO,CAAC,aAAK;AAC1B,mBAAmB,mBAAO,CAAC,eAAQ;AACnC,eAAe,mBAAO,CAAC,aAAM;AAC7B,WAAW,mBAAO,CAAC,cAAM;AACzB,SAAS,mBAAO,CAAC,WAAI;AACrB,SAAS,mBAAO,CAAC,uBAAe;;AAEhC;AACA;AACA;AACA;AACA;;AAEA,oDAAoD,EAAE,WAAW,EAAE,WAAW,EAAE,WAAW,EAAE;;AAE7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;;AAEA;AACA,qBAAqB,QAAQ;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3ZA,0C;;;;;;;;;;;;ACAA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,aAAM;AAC7B,mBAAmB,mBAAO,CAAC,eAAQ;;AAEnC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AChJA,UAAU,mBAAO,CAAC,aAAK;AACvB,mBAAmB,mBAAO,CAAC,eAAQ;AACnC;AACA,eAAe,mBAAO,CAAC,aAAM;;AAE7B,mBAAmB,mBAAO,CAAC,sBAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,mBAAO,CAAC,mBAAW;AACjC,uBAAuB,mBAAO,CAAC,wBAAgB;;AAE/C;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB,2CAA2C;AAC5D,KAAK;AACL,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,qDAAqD,eAAe;;AAEpE;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,qDAAqD,eAAe;;AAEpE;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,mDAAmD,eAAe;;AAElE;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,eAAe;AAC9D,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C,iBAAiB;AAC7D;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACpoCA,gBAAgB,mBAAO,CAAC,iBAAS;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC3EA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;;;;;;;;;;;;;;ACHA,cAAc,mBAAO,CAAC,qBAAa;AACnC;AACA;AACA,OAAO,mBAAO,CAAC,qBAAa;AAC5B,CAAC;AACD,OAAO,mBAAO,CAAC,WAAI;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAO,CAAC,qBAAa;;AAErB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;;;;;;;;;;;;;AC5DY;AACZ,iBAAiB,mBAAO,CAAC,kBAAU;;AAEnC;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,cAAc,wBAAQ,cAAc,CAAC;AACrC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS;AAChB;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;AC7FY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,4B;;;;;;;;;;;;ACRA,SAAS,mBAAO,CAAC,WAAI;AACrB,gBAAgB,mBAAO,CAAC,wBAAgB;AACxC,aAAa,mBAAO,CAAC,6BAAqB;AAC1C;;AAEA,WAAW,mBAAO,CAAC,aAAM;;AAEzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,mBAAO,CAAC,gBAAQ;AACpB,GAAG;AACH;;AAEA,uBAAuB,mBAAO,CAAC,iBAAS;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,iCAAiC;AACjC,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrQA,SAAS,mBAAO,CAAC,iBAAS;AAC1B,gBAAgB,mBAAO,CAAC,mBAAW;;AAEnC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,yCAAyC;AACzC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH,4CAA4C;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACzUA,sC;;;;;;;;;;;;ACAA,aAAa,mBAAO,CAAC,eAAQ;;AAE7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;;AAEA;;AAEA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;;AAEA;;AAEA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpHA,cAAc,mBAAO,CAAC,iBAAS;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvEA,cAAc,mBAAO,CAAC,qBAAa;AACnC,aAAa,mBAAO,CAAC,gBAAQ;;AAE7B;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;;AAEA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA,sDAAsD;AACtD;AACA;AACA,QAAQ;AACR,MAAM;AACN;;;;;;;;;;;;;;;;;;;;;;;;AC/EA,6EAA+C;AAuB/C,MAAa,UAAW,SAAQ,+BAAW;IAGvC,YAAqB,KAAU,EAAE,IAAmB;QAChD,KAAK,EAAE;QADU,UAAK,GAAL,KAAK,CAAK;QAE3B,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,IAAI,EAAE;IACrC,CAAC;IAED,KAAK;QACD,IAAI,CAAC,IAAI,GAAG,IAAI;QAEhB,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE;YACzB,IAAI,UAAU,GAAG,IAAI,CAAC,QAAQ,EAAE;YAChC,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC;YAE3B,IAAI,IAAI,CAAC,OAAO,EAAE;gBACd,IAAI,KAAK,GAAG,KAAK;gBACjB,KAAK,IAAI,MAAM,IAAI,IAAI,CAAC,OAAO,EAAE;oBAC7B,IAAI,KAAK,GAAG,KAAK;oBACjB,IAAI,GAAG,GAAG,EAAE;oBACZ,IAAI,MAAM,CAAC,OAAO,EAAE;wBAChB,IAAI,EAAE,GAAG,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC;wBACvC,IAAI,UAAU,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;4BACtB,GAAG,GAAG,UAAU,CAAC,OAAO,CAAC,EAAE,EAAE,MAAM,CAAC,IAAI,CAAC;4BACzC,KAAK,GAAG,IAAI;4BACZ,KAAK,GAAG,IAAI;yBACf;qBACJ;yBAAM;wBACH,IAAI,UAAU,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE;4BACpC,GAAG,GAAG,MAAM,CAAC,IAAI;4BACjB,KAAK,GAAG,IAAI;4BACZ,KAAK,GAAG,IAAI;yBACf;qBACJ;oBAED,IAAI,KAAK,EAAE;wBACP,OAAO,CAAC,GAAG,CAAC,qBAAqB,GAAG,GAAG,GAAG,GAAG,CAAC;wBAC9C,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC;wBAC5B,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,MAAM,CAAC;qBACxD;yBAAM;wBACH,IAAI,MAAM,CAAC,QAAQ,EAAE;4BACjB,OAAO,CAAC,GAAG,CAAC,wBAAwB,GAAG,MAAM,CAAC,MAAM,CAAC;4BACrD,KAAK,GAAG,IAAI;4BACZ,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,MAAM,CAAC;yBACxD;6BAAM;4BACH,MAAK;yBACR;qBACJ;iBACJ;gBAED,IAAI,KAAK,EAAE;oBACP,IAAI,CAAC,2BAA2B,EAAE;iBACrC;aACJ;QACL,CAAC,CAAC;QAEF,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE;YACtB,IAAI,IAAI,CAAC,IAAI,EAAE;gBACX,IAAI,CAAC,OAAO,EAAE;aACjB;QACL,CAAC,CAAC;QAEF,IAAI,CAAC,2BAA2B,EAAE;IACtC,CAAC;IAED,MAAM,CAAE,OAAO,EAAE,IAAI;QACjB,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,EAAE,OAAO,CAAC;IACvC,CAAC;IAED,KAAK,CAAE,IAAI;QACP,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC;IAC1B,CAAC;IAED,IAAI,CAAE,MAAe;QACjB,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,IAAI,MAAM,CAAC;IACvC,CAAC;IAEK,iBAAiB;;YACnB,OAAO,EAAE;QACb,CAAC;KAAA;IAEK,qBAAqB;;YACvB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;QACrB,CAAC;KAAA;IAEK,mBAAmB;;YACrB,OAAO,IAAI;QACf,CAAC;KAAA;IAEO,2BAA2B;QAC/B,IAAI,IAAI,CAAC,OAAO,EAAE;YACd,KAAK,IAAI,MAAM,IAAI,IAAI,CAAC,OAAO,EAAE;gBAC7B,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;oBAChB,OAAO,CAAC,GAAG,CAAC,mBAAmB,EAAE,MAAM,CAAC,IAAI,CAAC;oBAC7C,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;oBACpC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,MAAM,CAAC;iBACxD;qBAAM;oBACH,MAAK;iBACR;aACJ;SACJ;IACL,CAAC;CACJ;AAtGD,gCAsGC;;;;;;;;;;;;;AC7HD,wDAAU,mBAAO,CAAC,mDAA6C;;AAE/D,2BAA2B,kCAAkC,aAAa,wHAAwH,cAAc,SAAS,UAAU,gJAAgJ;AACnX;;AAEA,iD;;;;;;;;;;;;;ACLA,wDAAU,mBAAO,CAAC,mDAA6C;;AAE/D,2BAA2B,kCAAkC,aAAa,wiBAAwiB,qBAAqB,0GAA0G,ssBAAssB,6BAA6B,wRAAwR,iBAAiB,8HAA8H;AAC33D;;AAEA,iD;;;;;;;;;;;;;;ACJA,qBAAqB,mBAAO,CAAC,qHAAuH;;AAEpJ;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,0DAAkD;AACrF;;;AAGA;AACA,cAAc,QAAS,iCAAiC,mBAAmB,qBAAqB,qBAAqB,EAAE;;AAEvH;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD,IAAI;AACJ;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qDAAqD,cAAc;;AAEnE;AACA;;;;;;;;;;;;;AC1EA,wDAAU,mBAAO,CAAC,mDAA6C;;AAE/D,2BAA2B,kCAAkC,aAAa,ilBAAilB,6BAA6B,4lBAA4lB,iBAAiB,2DAA2D,iBAAiB,8tBAA8tB;AAC/kE;;AAEA,iD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLA,2DAA0C;AAC1C,oFAAwD;AACxD,gFAAqD;AACrD,oEAAqF;AACrF,4FAAmE;AAGnE,IAAa,cAAc,GAA3B,MAAa,cAAe,SAAQ,qCAAqB;IACrD,YACY,QAAkB,EAClB,YAA0B,EAClC,OAAuB;QAEvB,KAAK,EAAE;QAJC,aAAQ,GAAR,QAAQ,CAAU;QAClB,iBAAY,GAAZ,YAAY,CAAc;QAIlC,OAAO,CAAC,aAAa,CAAC,SAAS,CAAC,CAAO,MAAM,EAAE,EAAE;YAC7C,IAAI,MAAM,KAAK,KAAK,EAAE;gBAClB,IAAI,CAAC,QAAQ,EAAE;aAClB;QACL,CAAC,EAAC;IACN,CAAC;IAED,QAAQ;QACJ,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,sCAAiB,CAAC;IACzC,CAAC;IAED,OAAO;QACH,OAAO,CAAC;gBACJ,IAAI,EAAE,IAAI,CAAC,YAAY,CAAC,uBAAuB,CAAC,mBAAO,CAAC,2BAAmB,CAAC,CAAC;gBAC7E,MAAM,EAAE,CAAC;gBACT,KAAK,EAAE,iBAAiB;gBACxB,eAAe,EAAE,iCAAiC;gBAClD,KAAK,EAAE,GAAS,EAAE;oBACd,IAAI,CAAC,QAAQ,EAAE;gBACnB,CAAC;aACJ,CAAC;IACN,CAAC;CACJ;AA7BY,cAAc;IAD1B,iBAAU,EAAE;qCAGa,uBAAQ;QACJ,+BAAY;QACzB,8BAAc;GAJlB,cAAc,CA6B1B;AA7BY,wCAAc;;;;;;;;;;;;;ACP3B,iD;;;;;;;;;;;;ACAA,y4B;;;;;;;;;;;;;;;ACAA,oEAA8C;AAE9C,MAAa,iBAAkB,SAAQ,8BAAc;IAArD;;QACI,aAAQ,GAAG;YACP,GAAG,EAAE;gBACD,WAAW,EAAE,EAAE;gBACf,OAAO,EAAE,EACR;aACJ;YACD,OAAO,EAAE;gBACL,KAAK,EAAE;oBACH,OAAO;iBACV;aACJ;SACJ;QAED,qBAAgB,GAAG,EAAG;IAC1B,CAAC;CAAA;AAfD,8CAeC;;;;;;;;;;;;;;;;;;;;;;ACjBD,2DAA0C;AAC1C,6EAAuD;AAEvD,wGAA+E;AAG/E,IAAa,sBAAsB,GAAnC,MAAa,sBAAuB,SAAQ,uCAAmB;IAD/D;;QAEI,OAAE,GAAG,KAAK;QACV,UAAK,GAAG,KAAK;IAKjB,CAAC;IAHG,gBAAgB;QACZ,OAAO,kDAAuB;IAClC,CAAC;CACJ;AAPY,sBAAsB;IADlC,iBAAU,EAAE;GACA,sBAAsB,CAOlC;AAPY,wDAAsB","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@angular/core\"), require(\"terminus-core\"), require(\"@ng-bootstrap/ng-bootstrap\"), require(\"fs\"), require(\"ngx-toastr\"), require(\"terminus-settings\"), require(\"path\"), require(\"terminus-terminal\"), require(\"@angular/common\"), require(\"@angular/forms\"), (function webpackLoadOptionalExternalModule() { try { return require(\"xkeychain\"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require(\"wincredmgr\"); } catch(e) {} }()), require(\"@angular/platform-browser\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@angular/core\", \"terminus-core\", \"@ng-bootstrap/ng-bootstrap\", \"fs\", \"ngx-toastr\", \"terminus-settings\", \"path\", \"terminus-terminal\", \"@angular/common\", \"@angular/forms\", \"xkeychain\", \"wincredmgr\", \"@angular/platform-browser\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"@angular/core\"), require(\"terminus-core\"), require(\"@ng-bootstrap/ng-bootstrap\"), require(\"fs\"), require(\"ngx-toastr\"), require(\"terminus-settings\"), require(\"path\"), require(\"terminus-terminal\"), require(\"@angular/common\"), require(\"@angular/forms\"), (function webpackLoadOptionalExternalModule() { try { return require(\"xkeychain\"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require(\"wincredmgr\"); } catch(e) {} }()), require(\"@angular/platform-browser\")) : factory(root[\"@angular/core\"], root[\"terminus-core\"], root[\"@ng-bootstrap/ng-bootstrap\"], root[\"fs\"], root[\"ngx-toastr\"], root[\"terminus-settings\"], root[\"path\"], root[\"terminus-terminal\"], root[\"@angular/common\"], root[\"@angular/forms\"], root[\"xkeychain\"], root[\"wincredmgr\"], root[\"@angular/platform-browser\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(global, function(__WEBPACK_EXTERNAL_MODULE__1__, __WEBPACK_EXTERNAL_MODULE__2__, __WEBPACK_EXTERNAL_MODULE__4__, __WEBPACK_EXTERNAL_MODULE__5__, __WEBPACK_EXTERNAL_MODULE__12__, __WEBPACK_EXTERNAL_MODULE__13__, __WEBPACK_EXTERNAL_MODULE__27__, __WEBPACK_EXTERNAL_MODULE__30__, __WEBPACK_EXTERNAL_MODULE__33__, __WEBPACK_EXTERNAL_MODULE__34__, __WEBPACK_EXTERNAL_MODULE__35__, __WEBPACK_EXTERNAL_MODULE__36__, __WEBPACK_EXTERNAL_MODULE__75__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 32);\n","module.exports = require(\"util\");","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","module.exports = __WEBPACK_EXTERNAL_MODULE__2__;","module.exports = require(\"stream\");","module.exports = __WEBPACK_EXTERNAL_MODULE__4__;","module.exports = __WEBPACK_EXTERNAL_MODULE__5__;","module.exports = require(\"events\");","var crypto = require('crypto');\n\nvar Ber = require('asn1').Ber;\nvar BigInteger = require('./jsbn'); // only for converting PPK -> OpenSSL format\n\nvar SSH_TO_OPENSSL = require('./constants').SSH_TO_OPENSSL;\n\nvar RE_STREAM = /^arcfour/i;\nvar RE_KEY_LEN = /(.{64})/g;\n// XXX the value of 2400 from dropbear is only for certain strings, not all\n// strings. for example the list strings used during handshakes\nvar MAX_STRING_LEN = Infinity;//2400; // taken from dropbear\nvar PPK_IV = new Buffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n\nmodule.exports = {\n  iv_inc: iv_inc,\n  isStreamCipher: isStreamCipher,\n  readInt: readInt,\n  readString: readString,\n  parseKey: require('./keyParser'),\n  genPublicKey: genPublicKey,\n  convertPPKPrivate: convertPPKPrivate,\n  verifyPPKMAC: verifyPPKMAC,\n  decryptKey: decryptKey,\n  DSASigBERToBare: DSASigBERToBare,\n  DSASigBareToBER: DSASigBareToBER,\n  ECDSASigASN1ToSSH: ECDSASigASN1ToSSH,\n  ECDSASigSSHToASN1: ECDSASigSSHToASN1,\n  RSAKeySSHToASN1: RSAKeySSHToASN1,\n  DSAKeySSHToASN1: DSAKeySSHToASN1,\n  ECDSAKeySSHToASN1: ECDSAKeySSHToASN1\n};\n\nfunction iv_inc(iv) {\n  var n = 12;\n  var c = 0;\n  do {\n    --n;\n    c = iv[n];\n    if (c === 255)\n      iv[n] = 0;\n    else {\n      iv[n] = ++c;\n      return;\n    }\n  } while (n > 4);\n}\n\nfunction isStreamCipher(name) {\n  return RE_STREAM.test(name);\n}\n\nfunction readInt(buffer, start, stream, cb) {\n  var bufferLen = buffer.length;\n  if (start < 0 || start >= bufferLen || (bufferLen - start) < 4) {\n    stream && stream._cleanup(cb);\n    return false;\n  }\n\n  return buffer.readUInt32BE(start, true);\n}\n\nfunction DSASigBERToBare(signature) {\n  if (signature.length <= 40)\n    return signature;\n  // This is a quick and dirty way to get from BER encoded r and s that\n  // OpenSSL gives us, to just the bare values back to back (40 bytes\n  // total) like OpenSSH (and possibly others) are expecting\n  var asnReader = new Ber.Reader(signature);\n  asnReader.readSequence();\n  var r = asnReader.readString(Ber.Integer, true);\n  var s = asnReader.readString(Ber.Integer, true);\n  var rOffset = 0;\n  var sOffset = 0;\n  if (r.length < 20) {\n    var rNew = new Buffer(20);\n    r.copy(rNew, 1);\n    r = rNew;\n    r[0] = 0;\n  }\n  if (s.length < 20) {\n    var sNew = new Buffer(20);\n    s.copy(sNew, 1);\n    s = sNew;\n    s[0] = 0;\n  }\n  if (r.length > 20 && r[0] === 0x00)\n    rOffset = 1;\n  if (s.length > 20 && s[0] === 0x00)\n    sOffset = 1;\n  var newSig = new Buffer((r.length - rOffset) + (s.length - sOffset));\n  r.copy(newSig, 0, rOffset);\n  s.copy(newSig, r.length - rOffset, sOffset);\n  return newSig;\n}\n\nfunction DSASigBareToBER(signature) {\n  if (signature.length > 40)\n    return signature;\n  // Change bare signature r and s values to ASN.1 BER values for OpenSSL\n  var asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n  var r = signature.slice(0, 20);\n  var s = signature.slice(20);\n  if (r[0] & 0x80) {\n    var rNew = new Buffer(21);\n    rNew[0] = 0x00;\n    r.copy(rNew, 1);\n    r = rNew;\n  } else if (r[0] === 0x00 && !(r[1] & 0x80)) {\n    r = r.slice(1);\n  }\n  if (s[0] & 0x80) {\n    var sNew = new Buffer(21);\n    sNew[0] = 0x00;\n    s.copy(sNew, 1);\n    s = sNew;\n  } else if (s[0] === 0x00 && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  asnWriter.writeBuffer(r, Ber.Integer);\n  asnWriter.writeBuffer(s, Ber.Integer);\n  asnWriter.endSequence();\n  return asnWriter.buffer;\n}\n\nfunction ECDSASigASN1ToSSH(signature) {\n  if (signature[0] === 0x00)\n    return signature;\n  // Convert SSH signature parameters to ASN.1 BER values for OpenSSL\n  var asnReader = new Ber.Reader(signature);\n  asnReader.readSequence();\n  var r = asnReader.readString(Ber.Integer, true);\n  var s = asnReader.readString(Ber.Integer, true);\n  if (r === null || s === null)\n    throw new Error('Invalid signature');\n  var newSig = new Buffer(4 + r.length + 4 + s.length);\n  newSig.writeUInt32BE(r.length, 0, true);\n  r.copy(newSig, 4);\n  newSig.writeUInt32BE(s.length, 4 + r.length, true);\n  s.copy(newSig, 4 + 4 + r.length);\n  return newSig;\n}\n\nfunction ECDSASigSSHToASN1(signature, self, callback) {\n  // Convert SSH signature parameters to ASN.1 BER values for OpenSSL\n  var r = readString(signature, 0, self, callback);\n  if (r === false)\n    return false;\n  var s = readString(signature, signature._pos, self, callback);\n  if (s === false)\n    return false;\n\n  var asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n  asnWriter.writeBuffer(r, Ber.Integer);\n  asnWriter.writeBuffer(s, Ber.Integer);\n  asnWriter.endSequence();\n  return asnWriter.buffer;\n}\n\nfunction RSAKeySSHToASN1(key, self, callback) {\n  // Convert SSH key parameters to ASN.1 BER values for OpenSSL\n  var e = readString(key, key._pos, self, callback);\n  if (e === false)\n    return false;\n  var n = readString(key, key._pos, self, callback);\n  if (n === false)\n    return false;\n\n  var asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.2.840.113549.1.1.1'); // rsaEncryption\n      // algorithm parameters (RSA has none)\n      asnWriter.writeNull();\n    asnWriter.endSequence();\n\n    // subjectPublicKey\n    asnWriter.startSequence(Ber.BitString);\n      asnWriter.writeByte(0x00);\n      asnWriter.startSequence();\n        asnWriter.writeBuffer(n, Ber.Integer);\n        asnWriter.writeBuffer(e, Ber.Integer);\n      asnWriter.endSequence();\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return asnWriter.buffer;\n}\n\nfunction DSAKeySSHToASN1(key, self, callback) {\n  // Convert SSH key parameters to ASN.1 BER values for OpenSSL\n  var p = readString(key, key._pos, self, callback);\n  if (p === false)\n    return false;\n  var q = readString(key, key._pos, self, callback);\n  if (q === false)\n    return false;\n  var g = readString(key, key._pos, self, callback);\n  if (g === false)\n    return false;\n  var y = readString(key, key._pos, self, callback);\n  if (y === false)\n    return false;\n\n  var asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.2.840.10040.4.1'); // id-dsa\n      // algorithm parameters\n      asnWriter.startSequence();\n        asnWriter.writeBuffer(p, Ber.Integer);\n        asnWriter.writeBuffer(q, Ber.Integer);\n        asnWriter.writeBuffer(g, Ber.Integer);\n      asnWriter.endSequence();\n    asnWriter.endSequence();\n\n    // subjectPublicKey\n    asnWriter.startSequence(Ber.BitString);\n      asnWriter.writeByte(0x00);\n      asnWriter.writeBuffer(y, Ber.Integer);\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return asnWriter.buffer;\n}\n\nfunction ECDSAKeySSHToASN1(key, self, callback) {\n  // Convert SSH key parameters to ASN.1 BER values for OpenSSL\n  var curve = readString(key, key._pos, self, callback);\n  if (curve === false)\n    return false;\n  var Q = readString(key, key._pos, self, callback);\n  if (Q === false)\n    return false;\n\n  var ecCurveOID;\n  switch (curve.toString('ascii')) {\n    case 'nistp256':\n      // prime256v1/secp256r1\n      ecCurveOID = '1.2.840.10045.3.1.7';\n      break;\n    case 'nistp384':\n      // secp384r1\n      ecCurveOID = '1.3.132.0.34';\n      break;\n    case 'nistp521':\n      // secp521r1\n      ecCurveOID = '1.3.132.0.35';\n      break;\n    default:\n      return false;\n  }\n  var asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.2.840.10045.2.1'); // id-ecPublicKey\n      // algorithm parameters (namedCurve)\n      asnWriter.writeOID(ecCurveOID);\n    asnWriter.endSequence();\n\n    // subjectPublicKey\n    asnWriter.startSequence(Ber.BitString);\n      asnWriter.writeByte(0x00);\n      // XXX: hack to write a raw buffer without a tag -- yuck\n      asnWriter._ensure(Q.length);\n      Q.copy(asnWriter._buf, asnWriter._offset, 0, Q.length);\n      asnWriter._offset += Q.length;\n      // end hack\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return asnWriter.buffer;\n}\n\nfunction decryptKey(keyInfo, passphrase) {\n  if (keyInfo._decrypted || !keyInfo.encryption)\n    return;\n\n  var keylen = 0;\n  var key;\n  var iv;\n  var dc;\n\n  keyInfo.encryption = (SSH_TO_OPENSSL[keyInfo.encryption]\n                        || keyInfo.encryption);\n  switch (keyInfo.encryption) {\n    case 'aes-256-cbc':\n    case 'aes-256-ctr':\n      keylen = 32;\n      break;\n    case 'des-ede3-cbc':\n    case 'des-ede3':\n    case 'aes-192-cbc':\n    case 'aes-192-ctr':\n      keylen = 24;\n      break;\n    case 'aes-128-cbc':\n    case 'aes-128-ctr':\n    case 'cast-cbc':\n    case 'bf-cbc':\n      keylen = 16;\n      break;\n    default:\n      throw new Error('Unsupported cipher for encrypted key: '\n                      + keyInfo.encryption);\n  }\n\n  if (keyInfo.ppk) {\n    iv = PPK_IV;\n\n    key = Buffer.concat([\n      crypto.createHash('sha1')\n            .update('\\x00\\x00\\x00\\x00' + passphrase, 'utf8')\n            .digest(),\n      crypto.createHash('sha1')\n            .update('\\x00\\x00\\x00\\x01' + passphrase, 'utf8')\n            .digest()\n    ]);\n    key = key.slice(0, keylen);\n  } else {\n    iv = new Buffer(keyInfo.extra[0], 'hex');\n\n    key = crypto.createHash('md5')\n                .update(passphrase, 'utf8')\n                .update(iv.slice(0, 8))\n                .digest();\n\n    while (keylen > key.length) {\n      key = Buffer.concat([\n        key,\n        (crypto.createHash('md5')\n               .update(key)\n               .update(passphrase, 'utf8')\n               .update(iv)\n               .digest()).slice(0, 8)\n      ]);\n    }\n    if (key.length > keylen)\n      key = key.slice(0, keylen);\n  }\n\n  dc = crypto.createDecipheriv(keyInfo.encryption, key, iv);\n  dc.setAutoPadding(false);\n  keyInfo.private = Buffer.concat([ dc.update(keyInfo.private), dc.final() ]);\n\n  keyInfo._decrypted = true;\n\n  if (keyInfo.privateOrig) {\n    // Update our original base64-encoded version of the private key\n    var orig = keyInfo.privateOrig.toString('utf8');\n    var newOrig = /^(.+(?:\\r\\n|\\n))/.exec(orig)[1];\n    var b64key = keyInfo.private.toString('base64');\n\n    newOrig += b64key.match(/.{1,70}/g).join('\\n');\n    newOrig += /((?:\\r\\n|\\n).+)$/.exec(orig)[1];\n\n    keyInfo.privateOrig = newOrig;\n  } else if (keyInfo.ppk) {\n    var valid = verifyPPKMAC(keyInfo, passphrase, keyInfo.private);\n    if (!valid)\n      throw new Error('PPK MAC mismatch');\n    // Automatically convert private key data to OpenSSL format\n    // (including PEM)\n    convertPPKPrivate(keyInfo);\n  }\n\n  // Fill in full key type\n  // TODO: make DRY, we do this also in keyParser\n  if (keyInfo.type !== 'ec') {\n    keyInfo.fulltype = 'ssh-' + keyInfo.type;\n  } else {\n    // ECDSA\n    var asnReader = new Ber.Reader(keyInfo.private);\n    asnReader.readSequence();\n    asnReader.readInt();\n    asnReader.readString(Ber.OctetString, true);\n    asnReader.readByte(); // Skip \"complex\" context type byte\n    var offset = asnReader.readLength(); // Skip context length\n    if (offset !== null) {\n      asnReader._offset = offset;\n      switch (asnReader.readOID()) {\n        case '1.2.840.10045.3.1.7':\n          // prime256v1/secp256r1\n          keyInfo.fulltype = 'ecdsa-sha2-nistp256';\n          break;\n        case '1.3.132.0.34':\n          // secp384r1\n          keyInfo.fulltype = 'ecdsa-sha2-nistp384';\n          break;\n        case '1.3.132.0.35':\n          // secp521r1\n          keyInfo.fulltype = 'ecdsa-sha2-nistp521';\n          break;\n      }\n    }\n    if (keyInfo.fulltype === undefined)\n      return new Error('Unsupported EC private key type');\n  }\n}\n\nfunction genPublicKey(keyInfo) {\n  var publicKey;\n  var i;\n\n  // RSA\n  var n;\n  var e;\n\n  // DSA\n  var p;\n  var q;\n  var g;\n  var y;\n\n  // ECDSA\n  var d;\n  var Q;\n  var ecCurveOID;\n  var ecCurveName;\n\n  if (keyInfo.private) {\n    // parsing private key in ASN.1 format in order to generate a public key\n    var privKey = keyInfo.private;\n    var asnReader = new Ber.Reader(privKey);\n    var errMsg;\n\n    if (asnReader.readSequence() === null) {\n      errMsg = 'Malformed private key (expected sequence)';\n      if (keyInfo._decrypted)\n        errMsg += '. Bad passphrase?';\n      throw new Error(errMsg);\n    }\n\n    // version (ignored)\n    if (asnReader.readInt() === null) {\n      errMsg = 'Malformed private key (expected version)';\n      if (keyInfo._decrypted)\n        errMsg += '. Bad passphrase?';\n      throw new Error(errMsg);\n    }\n\n    if (keyInfo.type === 'rsa') {\n      // modulus (n) -- integer\n      n = asnReader.readString(Ber.Integer, true);\n      if (n === null) {\n        errMsg = 'Malformed private key (expected RSA n value)';\n        if (keyInfo._decrypted)\n          errMsg += '. Bad passphrase?';\n        throw new Error(errMsg);\n      }\n\n      // public exponent (e) -- integer\n      e = asnReader.readString(Ber.Integer, true);\n      if (e === null) {\n        errMsg = 'Malformed private key (expected RSA e value)';\n        if (keyInfo._decrypted)\n          errMsg += '. Bad passphrase?';\n        throw new Error(errMsg);\n      }\n\n      publicKey = new Buffer(4 + 7 // ssh-rsa\n                             + 4 + n.length\n                             + 4 + e.length);\n\n      publicKey.writeUInt32BE(7, 0, true);\n      publicKey.write('ssh-rsa', 4, 7, 'ascii');\n\n      i = 4 + 7;\n      publicKey.writeUInt32BE(e.length, i, true);\n      e.copy(publicKey, i += 4);\n\n      publicKey.writeUInt32BE(n.length, i += e.length, true);\n      n.copy(publicKey, i += 4);\n    } else if (keyInfo.type === 'dss') { // DSA\n      // prime (p) -- integer\n      p = asnReader.readString(Ber.Integer, true);\n      if (p === null) {\n        errMsg = 'Malformed private key (expected DSA p value)';\n        if (keyInfo._decrypted)\n          errMsg += '. Bad passphrase?';\n        throw new Error(errMsg);\n      }\n\n      // group order (q) -- integer\n      q = asnReader.readString(Ber.Integer, true);\n      if (q === null) {\n        errMsg = 'Malformed private key (expected DSA q value)';\n        if (keyInfo._decrypted)\n          errMsg += '. Bad passphrase?';\n        throw new Error(errMsg);\n      }\n\n      // group generator (g) -- integer\n      g = asnReader.readString(Ber.Integer, true);\n      if (g === null) {\n        errMsg = 'Malformed private key (expected DSA g value)';\n        if (keyInfo._decrypted)\n          errMsg += '. Bad passphrase?';\n        throw new Error(errMsg);\n      }\n\n      // public key value (y) -- integer\n      y = asnReader.readString(Ber.Integer, true);\n      if (y === null) {\n        errMsg = 'Malformed private key (expected DSA y value)';\n        if (keyInfo._decrypted)\n          errMsg += '. Bad passphrase?';\n        throw new Error(errMsg);\n      }\n\n      publicKey = new Buffer(4 + 7 // ssh-dss\n                             + 4 + p.length\n                             + 4 + q.length\n                             + 4 + g.length\n                             + 4 + y.length);\n\n      publicKey.writeUInt32BE(7, 0, true);\n      publicKey.write('ssh-dss', 4, 7, 'ascii');\n\n      i = 4 + 7;\n      publicKey.writeUInt32BE(p.length, i, true);\n      p.copy(publicKey, i += 4);\n\n      publicKey.writeUInt32BE(q.length, i += p.length, true);\n      q.copy(publicKey, i += 4);\n\n      publicKey.writeUInt32BE(g.length, i += q.length, true);\n      g.copy(publicKey, i += 4);\n\n      publicKey.writeUInt32BE(y.length, i += g.length, true);\n      y.copy(publicKey, i += 4);\n    } else { // ECDSA\n      d = asnReader.readString(Ber.OctetString, true);\n      if (d === null)\n        throw new Error('Malformed private key (expected ECDSA private key)');\n      asnReader.readByte(); // Skip \"complex\" context type byte\n      var offset = asnReader.readLength(); // Skip context length\n      if (offset === null)\n        throw new Error('Malformed private key (expected ECDSA context value)');\n      asnReader._offset = offset;\n      ecCurveOID = asnReader.readOID();\n      if (ecCurveOID === null)\n        throw new Error('Malformed private key (expected ECDSA curve)');\n      var tempECDH;\n      switch (ecCurveOID) {\n        case '1.2.840.10045.3.1.7':\n          // prime256v1/secp256r1\n          keyInfo.curve = ecCurveName = 'nistp256';\n          tempECDH = crypto.createECDH('prime256v1');\n          break;\n        case '1.3.132.0.34':\n          // secp384r1\n          keyInfo.curve = ecCurveName = 'nistp384';\n          tempECDH = crypto.createECDH('secp384r1');\n          break;\n        case '1.3.132.0.35':\n          // secp521r1\n          keyInfo.curve = ecCurveName = 'nistp521';\n          tempECDH = crypto.createECDH('secp521r1');\n          break;\n        default:\n          throw new Error('Malformed private key (unsupported EC curve)');\n      }\n      tempECDH.setPrivateKey(d);\n      Q = tempECDH.getPublicKey();\n\n      publicKey = new Buffer(4 + 19 // ecdsa-sha2-<curve name>\n                             + 4 + 8 // <curve name>\n                             + 4 + Q.length);\n\n      publicKey.writeUInt32BE(19, 0, true);\n      publicKey.write('ecdsa-sha2-' + ecCurveName, 4, 19, 'ascii');\n\n      publicKey.writeUInt32BE(8, 23, true);\n      publicKey.write(ecCurveName, 27, 8, 'ascii');\n\n      publicKey.writeUInt32BE(Q.length, 35, true);\n      Q.copy(publicKey, 39);\n    }\n  } else if (keyInfo.public) {\n    publicKey = keyInfo.public;\n    if (keyInfo.type === 'ec') {\n      // TODO: support adding ecdsa-* prefix\n      ecCurveName = keyInfo.curve;\n    } else if (publicKey[0] !== 0\n      // check for missing ssh-{dsa,rsa} prefix\n               || publicKey[1] !== 0\n               || publicKey[2] !== 0\n               || publicKey[3] !== 7\n               || publicKey[4] !== 115\n               || publicKey[5] !== 115\n               || publicKey[6] !== 104\n               || publicKey[7] !== 45\n               || ((publicKey[8] !== 114\n                    || publicKey[9] !== 115\n                    || publicKey[10] !== 97)\n                   &&\n                   ((publicKey[8] !== 100\n                     || publicKey[9] !== 115\n                     || publicKey[10] !== 115)))) {\n      var newPK = new Buffer(4 + 7 + publicKey.length);\n      publicKey.copy(newPK, 11);\n      newPK.writeUInt32BE(7, 0, true);\n      if (keyInfo.type === 'rsa')\n        newPK.write('ssh-rsa', 4, 7, 'ascii');\n      else\n        newPK.write('ssh-dss', 4, 7, 'ascii');\n      publicKey = newPK;\n    }\n  } else\n    throw new Error('Missing data generated by parseKey()');\n\n  // generate a public key format for use with OpenSSL\n\n  i = 4 + 7;\n\n  var fulltype;\n  var asn1KeyBuf;\n  if (keyInfo.type === 'rsa') {\n    fulltype = 'ssh-rsa';\n    asn1KeyBuf = RSAKeySSHToASN1(publicKey.slice(4 + 7));\n  } else if (keyInfo.type === 'dss') {\n    fulltype = 'ssh-dss';\n    asn1KeyBuf = DSAKeySSHToASN1(publicKey.slice(4 + 7));\n  } else { // ECDSA\n    fulltype = 'ecdsa-sha2-' + ecCurveName;\n    asn1KeyBuf = ECDSAKeySSHToASN1(publicKey.slice(4 + 19));\n  }\n\n  if (!asn1KeyBuf)\n    throw new Error('Invalid SSH-formatted public key');\n\n  var b64key = asn1KeyBuf.toString('base64').replace(RE_KEY_LEN, '$1\\n');\n  var fullkey = '-----BEGIN PUBLIC KEY-----\\n'\n                + b64key\n                + (b64key[b64key.length - 1] === '\\n' ? '' : '\\n')\n                + '-----END PUBLIC KEY-----';\n\n  return {\n    type: keyInfo.type,\n    fulltype: fulltype,\n    curve: ecCurveName,\n    public: publicKey,\n    publicOrig: new Buffer(fullkey)\n  };\n}\n\nfunction verifyPPKMAC(keyInfo, passphrase, privateKey) {\n  if (keyInfo._macresult !== undefined)\n    return keyInfo._macresult;\n  else if (!keyInfo.ppk)\n    throw new Error(\"Key isn't a PPK\");\n  else if (!keyInfo.privateMAC)\n    throw new Error('Missing MAC');\n  else if (!privateKey)\n    throw new Error('Missing raw private key data');\n  else if (keyInfo.encryption && typeof passphrase !== 'string')\n    throw new Error('Missing passphrase for encrypted PPK');\n  else if (keyInfo.encryption && !keyInfo._decrypted)\n    throw new Error('PPK must be decrypted before verifying MAC');\n\n  var mac = keyInfo.privateMAC;\n  var typelen = keyInfo.fulltype.length;\n  // encryption algorithm is converted at this point for use with OpenSSL,\n  // so we need to use the original value so that the MAC is calculated\n  // correctly\n  var enc = (keyInfo.encryption ? 'aes256-cbc' : 'none');\n  var enclen = enc.length;\n  var commlen = Buffer.byteLength(keyInfo.comment);\n  var pub = keyInfo.public;\n  var publen = pub.length;\n  var privlen = privateKey.length;\n  var macdata = new Buffer(4 + typelen\n                           + 4 + enclen\n                           + 4 + commlen\n                           + 4 + publen\n                           + 4 + privlen);\n  var p = 0;\n\n  macdata.writeUInt32BE(typelen, p, true);\n  macdata.write(keyInfo.fulltype, p += 4, typelen, 'ascii');\n  macdata.writeUInt32BE(enclen, p += typelen, true);\n  macdata.write(enc, p += 4, enclen, 'ascii');\n  macdata.writeUInt32BE(commlen, p += enclen, true);\n  macdata.write(keyInfo.comment, p += 4, commlen, 'utf8');\n  macdata.writeUInt32BE(publen, p += commlen, true);\n  pub.copy(macdata, p += 4);\n  macdata.writeUInt32BE(privlen, p += publen, true);\n  privateKey.copy(macdata, p += 4);\n\n  if (typeof passphrase !== 'string')\n    passphrase = '';\n\n  var mackey = crypto.createHash('sha1')\n                     .update('putty-private-key-file-mac-key', 'ascii')\n                     .update(passphrase, 'utf8')\n                     .digest();\n\n  var calcMAC = crypto.createHmac('sha1', mackey)\n                      .update(macdata)\n                      .digest('hex');\n\n  return (keyInfo._macresult = (calcMAC === mac));\n}\n\nfunction convertPPKPrivate(keyInfo) {\n  if (!keyInfo.ppk || !keyInfo.public || !keyInfo.private)\n    throw new Error(\"Key isn't a PPK\");\n  else if (keyInfo._converted)\n    return false;\n\n  var pub = keyInfo.public;\n  var priv = keyInfo.private;\n  var asnWriter = new Ber.Writer();\n  var p;\n  var q;\n\n  if (keyInfo.type === 'rsa') {\n    var e = readString(pub, 4 + 7);\n    var n = readString(pub, pub._pos);\n    var d = readString(priv, 0);\n    p = readString(priv, priv._pos);\n    q = readString(priv, priv._pos);\n    var iqmp = readString(priv, priv._pos);\n    var p1 = new BigInteger(p, 256);\n    var q1 = new BigInteger(q, 256);\n    var dmp1 = new BigInteger(d, 256);\n    var dmq1 = new BigInteger(d, 256);\n\n    dmp1 = new Buffer(dmp1.mod(p1.subtract(BigInteger.ONE)).toByteArray());\n    dmq1 = new Buffer(dmq1.mod(q1.subtract(BigInteger.ONE)).toByteArray());\n\n    asnWriter.startSequence();\n      asnWriter.writeInt(0x00, Ber.Integer);\n      asnWriter.writeBuffer(n, Ber.Integer);\n      asnWriter.writeBuffer(e, Ber.Integer);\n      asnWriter.writeBuffer(d, Ber.Integer);\n      asnWriter.writeBuffer(p, Ber.Integer);\n      asnWriter.writeBuffer(q, Ber.Integer);\n      asnWriter.writeBuffer(dmp1, Ber.Integer);\n      asnWriter.writeBuffer(dmq1, Ber.Integer);\n      asnWriter.writeBuffer(iqmp, Ber.Integer);\n    asnWriter.endSequence();\n  } else {\n    p = readString(pub, 4 + 7);\n    q = readString(pub, pub._pos);\n    var g = readString(pub, pub._pos);\n    var y = readString(pub, pub._pos);\n    var x = readString(priv, 0);\n\n    asnWriter.startSequence();\n      asnWriter.writeInt(0x00, Ber.Integer);\n      asnWriter.writeBuffer(p, Ber.Integer);\n      asnWriter.writeBuffer(q, Ber.Integer);\n      asnWriter.writeBuffer(g, Ber.Integer);\n      asnWriter.writeBuffer(y, Ber.Integer);\n      asnWriter.writeBuffer(x, Ber.Integer);\n    asnWriter.endSequence();\n  }\n\n  var b64key = asnWriter.buffer.toString('base64').replace(RE_KEY_LEN, '$1\\n');\n  var fullkey = '-----BEGIN '\n                + (keyInfo.type === 'rsa' ? 'RSA' : 'DSA')\n                + ' PRIVATE KEY-----\\n'\n                + b64key\n                + (b64key[b64key.length - 1] === '\\n' ? '' : '\\n')\n                + '-----END '\n                + (keyInfo.type === 'rsa' ? 'RSA' : 'DSA')\n                + ' PRIVATE KEY-----';\n\n  keyInfo.private = asnWriter.buffer;\n  keyInfo.privateOrig = new Buffer(fullkey);\n  keyInfo._converted = true;\n  return true;\n}\n\nfunction readString(buffer, start, encoding, stream, cb, maxLen) {\n  if (encoding && !Buffer.isBuffer(encoding) && typeof encoding !== 'string') {\n    if (typeof cb === 'number')\n      maxLen = cb;\n    cb = stream;\n    stream = encoding;\n    encoding = undefined;\n  }\n\n  start || (start = 0);\n  var bufferLen = buffer.length;\n  var left = (bufferLen - start);\n  var len;\n  var end;\n  if (start < 0 || start >= bufferLen || left < 4) {\n    stream && stream._cleanup(cb);\n    return false;\n  }\n\n  len = buffer.readUInt32BE(start, true);\n  if (len > (maxLen || MAX_STRING_LEN) || left < (4 + len)) {\n    stream && stream._cleanup(cb);\n    return false;\n  }\n\n  start += 4;\n  end = start + len;\n  buffer._pos = end;\n\n  if (encoding) {\n    if (Buffer.isBuffer(encoding)) {\n      buffer.copy(encoding, 0, start, end);\n      return encoding;\n    } else\n      return buffer.toString(encoding, start, end);\n  } else\n    return buffer.slice(start, end);\n}\n\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","'use strict';\n\nvar pug_has_own_property = Object.prototype.hasOwnProperty;\n\n/**\n * Merge two attribute objects giving precedence\n * to values in object `b`. Classes are special-cased\n * allowing for arrays and merging/joining appropriately\n * resulting in a string.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n * @api private\n */\n\nexports.merge = pug_merge;\nfunction pug_merge(a, b) {\n  if (arguments.length === 1) {\n    var attrs = a[0];\n    for (var i = 1; i < a.length; i++) {\n      attrs = pug_merge(attrs, a[i]);\n    }\n    return attrs;\n  }\n\n  for (var key in b) {\n    if (key === 'class') {\n      var valA = a[key] || [];\n      a[key] = (Array.isArray(valA) ? valA : [valA]).concat(b[key] || []);\n    } else if (key === 'style') {\n      var valA = pug_style(a[key]);\n      valA = valA && valA[valA.length - 1] !== ';' ? valA + ';' : valA;\n      var valB = pug_style(b[key]);\n      valB = valB && valB[valB.length - 1] !== ';' ? valB + ';' : valB;\n      a[key] = valA + valB;\n    } else {\n      a[key] = b[key];\n    }\n  }\n\n  return a;\n};\n\n/**\n * Process array, object, or string as a string of classes delimited by a space.\n *\n * If `val` is an array, all members of it and its subarrays are counted as\n * classes. If `escaping` is an array, then whether or not the item in `val` is\n * escaped depends on the corresponding item in `escaping`. If `escaping` is\n * not an array, no escaping is done.\n *\n * If `val` is an object, all the keys whose value is truthy are counted as\n * classes. No escaping is done.\n *\n * If `val` is a string, it is counted as a class. No escaping is done.\n *\n * @param {(Array.<string>|Object.<string, boolean>|string)} val\n * @param {?Array.<string>} escaping\n * @return {String}\n */\nexports.classes = pug_classes;\nfunction pug_classes_array(val, escaping) {\n  var classString = '', className, padding = '', escapeEnabled = Array.isArray(escaping);\n  for (var i = 0; i < val.length; i++) {\n    className = pug_classes(val[i]);\n    if (!className) continue;\n    escapeEnabled && escaping[i] && (className = pug_escape(className));\n    classString = classString + padding + className;\n    padding = ' ';\n  }\n  return classString;\n}\nfunction pug_classes_object(val) {\n  var classString = '', padding = '';\n  for (var key in val) {\n    if (key && val[key] && pug_has_own_property.call(val, key)) {\n      classString = classString + padding + key;\n      padding = ' ';\n    }\n  }\n  return classString;\n}\nfunction pug_classes(val, escaping) {\n  if (Array.isArray(val)) {\n    return pug_classes_array(val, escaping);\n  } else if (val && typeof val === 'object') {\n    return pug_classes_object(val);\n  } else {\n    return val || '';\n  }\n}\n\n/**\n * Convert object or string to a string of CSS styles delimited by a semicolon.\n *\n * @param {(Object.<string, string>|string)} val\n * @return {String}\n */\n\nexports.style = pug_style;\nfunction pug_style(val) {\n  if (!val) return '';\n  if (typeof val === 'object') {\n    var out = '';\n    for (var style in val) {\n      /* istanbul ignore else */\n      if (pug_has_own_property.call(val, style)) {\n        out = out + style + ':' + val[style] + ';';\n      }\n    }\n    return out;\n  } else {\n    return val + '';\n  }\n};\n\n/**\n * Render the given attribute.\n *\n * @param {String} key\n * @param {String} val\n * @param {Boolean} escaped\n * @param {Boolean} terse\n * @return {String}\n */\nexports.attr = pug_attr;\nfunction pug_attr(key, val, escaped, terse) {\n  if (val === false || val == null || !val && (key === 'class' || key === 'style')) {\n    return '';\n  }\n  if (val === true) {\n    return ' ' + (terse ? key : key + '=\"' + key + '\"');\n  }\n  if (typeof val.toJSON === 'function') {\n    val = val.toJSON();\n  }\n  if (typeof val !== 'string') {\n    val = JSON.stringify(val);\n    if (!escaped && val.indexOf('\"') !== -1) {\n      return ' ' + key + '=\\'' + val.replace(/'/g, '&#39;') + '\\'';\n    }\n  }\n  if (escaped) val = pug_escape(val);\n  return ' ' + key + '=\"' + val + '\"';\n};\n\n/**\n * Render the given attributes object.\n *\n * @param {Object} obj\n * @param {Object} terse whether to use HTML5 terse boolean attributes\n * @return {String}\n */\nexports.attrs = pug_attrs;\nfunction pug_attrs(obj, terse){\n  var attrs = '';\n\n  for (var key in obj) {\n    if (pug_has_own_property.call(obj, key)) {\n      var val = obj[key];\n\n      if ('class' === key) {\n        val = pug_classes(val);\n        attrs = pug_attr(key, val, false, terse) + attrs;\n        continue;\n      }\n      if ('style' === key) {\n        val = pug_style(val);\n      }\n      attrs += pug_attr(key, val, false, terse);\n    }\n  }\n\n  return attrs;\n};\n\n/**\n * Escape the given string of `html`.\n *\n * @param {String} html\n * @return {String}\n * @api private\n */\n\nvar pug_match_html = /[\"&<>]/;\nexports.escape = pug_escape;\nfunction pug_escape(_html){\n  var html = '' + _html;\n  var regexResult = pug_match_html.exec(html);\n  if (!regexResult) return _html;\n\n  var result = '';\n  var i, lastIndex, escape;\n  for (i = regexResult.index, lastIndex = 0; i < html.length; i++) {\n    switch (html.charCodeAt(i)) {\n      case 34: escape = '&quot;'; break;\n      case 38: escape = '&amp;'; break;\n      case 60: escape = '&lt;'; break;\n      case 62: escape = '&gt;'; break;\n      default: continue;\n    }\n    if (lastIndex !== i) result += html.substring(lastIndex, i);\n    lastIndex = i + 1;\n    result += escape;\n  }\n  if (lastIndex !== i) return result + html.substring(lastIndex, i);\n  else return result;\n};\n\n/**\n * Re-throw the given `err` in context to the\n * the pug in `filename` at the given `lineno`.\n *\n * @param {Error} err\n * @param {String} filename\n * @param {String} lineno\n * @param {String} str original source\n * @api private\n */\n\nexports.rethrow = pug_rethrow;\nfunction pug_rethrow(err, filename, lineno, str){\n  if (!(err instanceof Error)) throw err;\n  if ((typeof window != 'undefined' || !filename) && !str) {\n    err.message += ' on line ' + lineno;\n    throw err;\n  }\n  try {\n    str = str || require('fs').readFileSync(filename, 'utf8')\n  } catch (ex) {\n    pug_rethrow(err, null, lineno)\n  }\n  var context = 3\n    , lines = str.split('\\n')\n    , start = Math.max(lineno - context, 0)\n    , end = Math.min(lines.length, lineno + context);\n\n  // Error context\n  var context = lines.slice(start, end).map(function(line, i){\n    var curr = i + start + 1;\n    return (curr == lineno ? '  > ' : '    ')\n      + curr\n      + '| '\n      + line;\n  }).join('\\n');\n\n  // Alter exception message\n  err.path = filename;\n  err.message = (filename || 'Pug') + ':' + lineno\n    + '\\n' + context + '\\n\\n' + err.message;\n  throw err;\n};\n","module.exports = {\n  SFTPStream: require('./lib/sftp'),\n  SSH2Stream: require('./lib/ssh'),\n  utils: require('./lib/utils'),\n  constants: require('./lib/constants')\n};","module.exports = require(\"assert\");","module.exports = __WEBPACK_EXTERNAL_MODULE__12__;","module.exports = __WEBPACK_EXTERNAL_MODULE__13__;","import { Injectable, NgZone } from '@angular/core'\nimport { SSHConnection } from '../api'\n\nlet xkeychain\nlet wincredmgr\ntry {\n    xkeychain = require('xkeychain')\n} catch (error) {\n    try {\n        wincredmgr = require('wincredmgr')\n    } catch (error2) {\n        console.warn('No keychain manager available')\n    }\n}\n\n@Injectable()\nexport class PasswordStorageService {\n    constructor (\n        private zone: NgZone,\n    ) { }\n\n    savePassword (connection: SSHConnection, password: string) {\n        if (xkeychain) {\n            xkeychain.setPassword({\n                account: connection.user,\n                service: `ssh@${connection.host}`,\n                password\n            }, () => null)\n        } else {\n            wincredmgr.WriteCredentials(\n                'user',\n                password,\n                `ssh:${connection.user}@${connection.host}`,\n            )\n        }\n    }\n\n    deletePassword (connection: SSHConnection) {\n        if (xkeychain) {\n            xkeychain.deletePassword({\n                account: connection.user,\n                service: `ssh@${connection.host}`,\n            }, () => null)\n        } else {\n            wincredmgr.DeleteCredentials(\n                `ssh:${connection.user}@${connection.host}`,\n            )\n        }\n    }\n\n    loadPassword (connection: SSHConnection): Promise<string> {\n        return new Promise(resolve => {\n            if (!wincredmgr && !xkeychain.isSupported()) {\n                return resolve(null)\n            }\n            if (xkeychain) {\n                xkeychain.getPassword(\n                    {\n                        account: connection.user,\n                        service: `ssh@${connection.host}`,\n                    },\n                    (_, result) => this.zone.run(() => resolve(result))\n                )\n            } else {\n                try {\n                    resolve(wincredmgr.ReadCredentials(`ssh:${connection.user}@${connection.host}`).password)\n                } catch (error) {\n                    resolve(null)\n                }\n            }\n        })\n    }\n}\n","module.exports = require(\"crypto\");","module.exports = require(\"net\");","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\n\nmodule.exports = {\n\n  newInvalidAsn1Error: function(msg) {\n    var e = new Error();\n    e.name = 'InvalidAsn1Error';\n    e.message = msg || '';\n    return e;\n  }\n\n};\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\n\nmodule.exports = {\n  EOC: 0,\n  Boolean: 1,\n  Integer: 2,\n  BitString: 3,\n  OctetString: 4,\n  Null: 5,\n  OID: 6,\n  ObjectDescriptor: 7,\n  External: 8,\n  Real: 9, // float\n  Enumeration: 10,\n  PDV: 11,\n  Utf8String: 12,\n  RelativeOID: 13,\n  Sequence: 16,\n  Set: 17,\n  NumericString: 18,\n  PrintableString: 19,\n  T61String: 20,\n  VideotexString: 21,\n  IA5String: 22,\n  UTCTime: 23,\n  GeneralizedTime: 24,\n  GraphicString: 25,\n  VisibleString: 26,\n  GeneralString: 28,\n  UniversalString: 29,\n  CharacterString: 30,\n  BMPString: 31,\n  Constructor: 32,\n  Context: 128\n};\n","var semver = require('semver');\n\nvar i;\nvar keys;\nvar len;\n\nvar MESSAGE = exports.MESSAGE = {\n  // Transport layer protocol -- generic (1-19)\n  DISCONNECT: 1,\n  IGNORE: 2,\n  UNIMPLEMENTED: 3,\n  DEBUG: 4,\n  SERVICE_REQUEST: 5,\n  SERVICE_ACCEPT: 6,\n\n  // Transport layer protocol -- algorithm negotiation (20-29)\n  KEXINIT: 20,\n  NEWKEYS: 21,\n\n  // Transport layer protocol -- key exchange method-specific (30-49)\n\n  // User auth protocol -- generic (50-59)\n  USERAUTH_REQUEST: 50,\n  USERAUTH_FAILURE: 51,\n  USERAUTH_SUCCESS: 52,\n  USERAUTH_BANNER: 53,\n\n  // User auth protocol -- user auth method-specific (60-79)\n\n  // Connection protocol -- generic (80-89)\n  GLOBAL_REQUEST: 80,\n  REQUEST_SUCCESS: 81,\n  REQUEST_FAILURE: 82,\n\n  // Connection protocol -- channel-related (90-127)\n  CHANNEL_OPEN: 90,\n  CHANNEL_OPEN_CONFIRMATION: 91,\n  CHANNEL_OPEN_FAILURE: 92,\n  CHANNEL_WINDOW_ADJUST: 93,\n  CHANNEL_DATA: 94,\n  CHANNEL_EXTENDED_DATA: 95,\n  CHANNEL_EOF: 96,\n  CHANNEL_CLOSE: 97,\n  CHANNEL_REQUEST: 98,\n  CHANNEL_SUCCESS: 99,\n  CHANNEL_FAILURE: 100\n\n  // Reserved for client protocols (128-191)\n\n  // Local extensions (192-155)\n};\nfor (i = 0, keys = Object.keys(MESSAGE), len = keys.length; i < len; ++i)\n  MESSAGE[MESSAGE[keys[i]]] = keys[i];\n// context-specific message codes:\nMESSAGE.KEXDH_INIT = 30;\nMESSAGE.KEXDH_REPLY = 31;\nMESSAGE.KEXDH_GEX_REQUEST = 34;\nMESSAGE.KEXDH_GEX_GROUP = 31;\nMESSAGE.KEXDH_GEX_INIT = 32;\nMESSAGE.KEXDH_GEX_REPLY = 33;\nMESSAGE.KEXECDH_INIT = 30; // included here for completeness\nMESSAGE.KEXECDH_REPLY = 31; // included here for completeness\nMESSAGE.USERAUTH_PASSWD_CHANGEREQ = 60;\nMESSAGE.USERAUTH_PK_OK = 60;\nMESSAGE.USERAUTH_INFO_REQUEST = 60;\nMESSAGE.USERAUTH_INFO_RESPONSE = 61;\n\nvar DYNAMIC_KEXDH_MESSAGE = exports.DYNAMIC_KEXDH_MESSAGE = {};\nDYNAMIC_KEXDH_MESSAGE[MESSAGE.KEXDH_GEX_GROUP] = 'KEXDH_GEX_GROUP';\nDYNAMIC_KEXDH_MESSAGE[MESSAGE.KEXDH_GEX_REPLY] = 'KEXDH_GEX_REPLY';\n\nvar KEXDH_MESSAGE = exports.KEXDH_MESSAGE = {};\nKEXDH_MESSAGE[MESSAGE.KEXDH_INIT] = 'KEXDH_INIT';\nKEXDH_MESSAGE[MESSAGE.KEXDH_REPLY] = 'KEXDH_REPLY';\n\nvar DISCONNECT_REASON = exports.DISCONNECT_REASON = {\n  HOST_NOT_ALLOWED_TO_CONNECT: 1,\n  PROTOCOL_ERROR: 2,\n  KEY_EXCHANGE_FAILED: 3,\n  RESERVED: 4,\n  MAC_ERROR: 5,\n  COMPRESSION_ERROR: 6,\n  SERVICE_NOT_AVAILABLE: 7,\n  PROTOCOL_VERSION_NOT_SUPPORTED: 8,\n  HOST_KEY_NOT_VERIFIABLE: 9,\n  CONNECTION_LOST: 10,\n  BY_APPLICATION: 11,\n  TOO_MANY_CONNECTIONS: 12,\n  AUTH_CANCELED_BY_USER: 13,\n  NO_MORE_AUTH_METHODS_AVAILABLE: 14,\n  ILLEGAL_USER_NAME: 15\n};\nfor (i = 0, keys = Object.keys(DISCONNECT_REASON), len = keys.length;\n     i < len;\n     ++i) {\n  DISCONNECT_REASON[DISCONNECT_REASON[keys[i]]] = keys[i];\n}\n\nvar CHANNEL_OPEN_FAILURE = exports.CHANNEL_OPEN_FAILURE = {\n  ADMINISTRATIVELY_PROHIBITED: 1,\n  CONNECT_FAILED: 2,\n  UNKNOWN_CHANNEL_TYPE: 3,\n  RESOURCE_SHORTAGE: 4\n};\nfor (i = 0, keys = Object.keys(CHANNEL_OPEN_FAILURE), len = keys.length;\n     i < len;\n     ++i) {\n  CHANNEL_OPEN_FAILURE[CHANNEL_OPEN_FAILURE[keys[i]]] = keys[i];\n}\n\nvar TERMINAL_MODE = exports.TERMINAL_MODE = {\n  TTY_OP_END: 0,        // Indicates end of options.\n  VINTR: 1,             // Interrupt character; 255 if none. Similarly for the\n                        //  other characters.  Not all of these characters are\n                        //  supported on all systems.\n  VQUIT: 2,             // The quit character (sends SIGQUIT signal on POSIX\n                        //  systems).\n  VERASE: 3,            // Erase the character to left of the cursor.\n  VKILL: 4,             // Kill the current input line.\n  VEOF: 5,              // End-of-file character (sends EOF from the terminal).\n  VEOL: 6,              // End-of-line character in addition to carriage return\n                        //  and/or linefeed.\n  VEOL2: 7,             // Additional end-of-line character.\n  VSTART: 8,            // Continues paused output (normally control-Q).\n  VSTOP: 9,             // Pauses output (normally control-S).\n  VSUSP: 10,            // Suspends the current program.\n  VDSUSP: 11,           // Another suspend character.\n  VREPRINT: 12,         // Reprints the current input line.\n  VWERASE: 13,          // Erases a word left of cursor.\n  VLNEXT: 14,           // Enter the next character typed literally, even if it\n                        //  is a special character\n  VFLUSH: 15,           // Character to flush output.\n  VSWTCH: 16,           // Switch to a different shell layer.\n  VSTATUS: 17,          // Prints system status line (load, command, pid, etc).\n  VDISCARD: 18,         // Toggles the flushing of terminal output.\n  IGNPAR: 30,           // The ignore parity flag.  The parameter SHOULD be 0\n                        //  if this flag is FALSE, and 1 if it is TRUE.\n  PARMRK: 31,           // Mark parity and framing errors.\n  INPCK: 32,            // Enable checking of parity errors.\n  ISTRIP: 33,           // Strip 8th bit off characters.\n  INLCR: 34,            // Map NL into CR on input.\n  IGNCR: 35,            // Ignore CR on input.\n  ICRNL: 36,            // Map CR to NL on input.\n  IUCLC: 37,            // Translate uppercase characters to lowercase.\n  IXON: 38,             // Enable output flow control.\n  IXANY: 39,            // Any char will restart after stop.\n  IXOFF: 40,            // Enable input flow control.\n  IMAXBEL: 41,          // Ring bell on input queue full.\n  ISIG: 50,             // Enable signals INTR, QUIT, [D]SUSP.\n  ICANON: 51,           // Canonicalize input lines.\n  XCASE: 52,            // Enable input and output of uppercase characters by\n                        //  preceding their lowercase equivalents with \"\\\".\n  ECHO: 53,             // Enable echoing.\n  ECHOE: 54,            // Visually erase chars.\n  ECHOK: 55,            // Kill character discards current line.\n  ECHONL: 56,           // Echo NL even if ECHO is off.\n  NOFLSH: 57,           // Don't flush after interrupt.\n  TOSTOP: 58,           // Stop background jobs from output.\n  IEXTEN: 59,           // Enable extensions.\n  ECHOCTL: 60,          // Echo control characters as ^(Char).\n  ECHOKE: 61,           // Visual erase for line kill.\n  PENDIN: 62,           // Retype pending input.\n  OPOST: 70,            // Enable output processing.\n  OLCUC: 71,            // Convert lowercase to uppercase.\n  ONLCR: 72,            // Map NL to CR-NL.\n  OCRNL: 73,            // Translate carriage return to newline (output).\n  ONOCR: 74,            // Translate newline to carriage return-newline\n                        // (output).\n  ONLRET: 75,           // Newline performs a carriage return (output).\n  CS7: 90,              // 7 bit mode.\n  CS8: 91,              // 8 bit mode.\n  PARENB: 92,           // Parity enable.\n  PARODD: 93,           // Odd parity, else even.\n  TTY_OP_ISPEED: 128,   // Specifies the input baud rate in bits per second.\n  TTY_OP_OSPEED: 129    // Specifies the output baud rate in bits per second.\n};\nfor (i = 0, keys = Object.keys(TERMINAL_MODE), len = keys.length; i < len; ++i)\n  TERMINAL_MODE[TERMINAL_MODE[keys[i]]] = keys[i];\n\nvar CHANNEL_EXTENDED_DATATYPE = exports.CHANNEL_EXTENDED_DATATYPE = {\n  STDERR: 1\n};\nfor (i = 0, keys = Object.keys(CHANNEL_EXTENDED_DATATYPE), len = keys.length;\n     i < len;\n     ++i) {\n  CHANNEL_EXTENDED_DATATYPE[CHANNEL_EXTENDED_DATATYPE[keys[i]]] = keys[i];\n}\n\nexports.SIGNALS = ['ABRT', 'ALRM', 'FPE', 'HUP', 'ILL', 'INT',\n                   'QUIT', 'SEGV', 'TERM', 'USR1', 'USR2', 'KILL',\n                   'PIPE'];\n\nvar DEFAULT_KEX = [\n  'diffie-hellman-group14-sha1' // REQUIRED\n];\nvar SUPPORTED_KEX = [\n  'diffie-hellman-group1-sha1'  // REQUIRED\n];\nif (semver.gte(process.version, '0.11.12')) {\n  // https://tools.ietf.org/html/rfc4419#section-4\n  DEFAULT_KEX = [\n    'diffie-hellman-group-exchange-sha256'\n  ].concat(DEFAULT_KEX);\n  SUPPORTED_KEX = [\n    'diffie-hellman-group-exchange-sha1'\n  ].concat(SUPPORTED_KEX);\n}\nif (semver.gte(process.version, '0.11.14')) {\n  // https://tools.ietf.org/html/rfc5656#section-10.1\n  DEFAULT_KEX = [\n    'ecdh-sha2-nistp256',\n    'ecdh-sha2-nistp384',\n    'ecdh-sha2-nistp521'\n  ].concat(DEFAULT_KEX);\n}\nvar KEX_BUF = new Buffer(DEFAULT_KEX.join(','), 'ascii');\nSUPPORTED_KEX = DEFAULT_KEX.concat(SUPPORTED_KEX);\n\nvar DEFAULT_SERVER_HOST_KEY = [\n  'ssh-rsa'\n];\nvar SUPPORTED_SERVER_HOST_KEY = [\n  'ssh-dss'\n];\nif (semver.gte(process.version, '5.2.0')) {\n  // ECDSA keys are only supported in v5.2.0+ because of a crypto change that\n  // made it possible to (efficiently) generate an ECDSA public key from a\n  // private key (commit nodejs/node#da5ac55c83eb2c09cfb3baf7875529e8f1113529)\n  DEFAULT_SERVER_HOST_KEY.push(\n    'ecdsa-sha2-nistp256',\n    'ecdsa-sha2-nistp384',\n    'ecdsa-sha2-nistp521'\n  );\n}\nvar SERVER_HOST_KEY_BUF = new Buffer(DEFAULT_SERVER_HOST_KEY.join(','),\n                                     'ascii');\nSUPPORTED_SERVER_HOST_KEY = DEFAULT_SERVER_HOST_KEY.concat(\n  SUPPORTED_SERVER_HOST_KEY\n);\n\nvar DEFAULT_CIPHER = [];\nvar SUPPORTED_CIPHER = [\n  'aes256-cbc',\n  'aes192-cbc',\n  'aes128-cbc',\n  'blowfish-cbc',\n  '3des-cbc',\n\n  // http://tools.ietf.org/html/rfc4345#section-4:\n  'arcfour256',\n  'arcfour128',\n\n  'cast128-cbc',\n  'arcfour'\n];\nif (semver.gte(process.version, '0.11.12')) {\n  // node v0.11.12 introduced support for setting AAD, which is needed for\n  // AES-GCM in SSH2\n  DEFAULT_CIPHER = [\n    // http://tools.ietf.org/html/rfc5647\n    'aes128-gcm',\n    'aes128-gcm@openssh.com',\n    'aes256-gcm',\n    'aes256-gcm@openssh.com'\n  ].concat(DEFAULT_CIPHER);\n}\nDEFAULT_CIPHER = [\n  // http://tools.ietf.org/html/rfc4344#section-4\n  'aes128-ctr',\n  'aes192-ctr',\n  'aes256-ctr'\n].concat(DEFAULT_CIPHER);\nvar CIPHER_BUF = new Buffer(DEFAULT_CIPHER.join(','), 'ascii');\nSUPPORTED_CIPHER = DEFAULT_CIPHER.concat(SUPPORTED_CIPHER);\n\nvar DEFAULT_HMAC = [\n  'hmac-sha2-256',\n  'hmac-sha2-512',\n  'hmac-sha1',\n];\nvar SUPPORTED_HMAC = [\n  'hmac-md5',\n  'hmac-sha2-256-96', // first 96 bits of HMAC-SHA256\n  'hmac-sha2-512-96', // first 96 bits of HMAC-SHA512\n  'hmac-ripemd160',\n  'hmac-sha1-96',     // first 96 bits of HMAC-SHA1\n  'hmac-md5-96'       // first 96 bits of HMAC-MD5\n];\nvar HMAC_BUF = new Buffer(DEFAULT_HMAC.join(','), 'ascii');\nSUPPORTED_HMAC = DEFAULT_HMAC.concat(SUPPORTED_HMAC);\n\nvar DEFAULT_COMPRESS = [\n  'none',\n  'zlib@openssh.com', // ZLIB (LZ77) compression, except\n                      // compression/decompression does not start until after\n                      // successful user authentication\n  'zlib'              // ZLIB (LZ77) compression\n];\nvar SUPPORTED_COMPRESS = [];\nvar COMPRESS_BUF = new Buffer(DEFAULT_COMPRESS.join(','), 'ascii');\nSUPPORTED_COMPRESS = DEFAULT_COMPRESS.concat(SUPPORTED_COMPRESS);\n\nexports.ALGORITHMS = {\n  KEX: DEFAULT_KEX,\n  KEX_BUF: KEX_BUF,\n  SUPPORTED_KEX: SUPPORTED_KEX,\n\n  SERVER_HOST_KEY: DEFAULT_SERVER_HOST_KEY,\n  SERVER_HOST_KEY_BUF: SERVER_HOST_KEY_BUF,\n  SUPPORTED_SERVER_HOST_KEY: SUPPORTED_SERVER_HOST_KEY,\n\n  CIPHER: DEFAULT_CIPHER,\n  CIPHER_BUF: CIPHER_BUF,\n  SUPPORTED_CIPHER: SUPPORTED_CIPHER,\n\n  HMAC: DEFAULT_HMAC,\n  HMAC_BUF: HMAC_BUF,\n  SUPPORTED_HMAC: SUPPORTED_HMAC,\n\n  COMPRESS: DEFAULT_COMPRESS,\n  COMPRESS_BUF: COMPRESS_BUF,\n  SUPPORTED_COMPRESS: SUPPORTED_COMPRESS\n};\nexports.SSH_TO_OPENSSL = {\n  // ECDH key exchange\n  'ecdh-sha2-nistp256': 'prime256v1', // OpenSSL's name for 'secp256r1'\n  'ecdh-sha2-nistp384': 'secp384r1',\n  'ecdh-sha2-nistp521': 'secp521r1',\n  // Ciphers\n  'aes128-gcm': 'aes-128-gcm',\n  'aes256-gcm': 'aes-256-gcm',\n  'aes128-gcm@openssh.com': 'aes-128-gcm',\n  'aes256-gcm@openssh.com': 'aes-256-gcm',\n  '3des-cbc': 'des-ede3-cbc',\n  'blowfish-cbc': 'bf-cbc',\n  'aes256-cbc': 'aes-256-cbc',\n  'aes192-cbc': 'aes-192-cbc',\n  'aes128-cbc': 'aes-128-cbc',\n  'idea-cbc': 'idea-cbc',\n  'cast128-cbc': 'cast-cbc',\n  'rijndael-cbc@lysator.liu.se': 'aes-256-cbc',\n  'arcfour128': 'rc4',\n  'arcfour256': 'rc4',\n  'arcfour512': 'rc4',\n  'arcfour': 'rc4',\n  'camellia128-cbc': 'camellia-128-cbc',\n  'camellia192-cbc': 'camellia-192-cbc',\n  'camellia256-cbc': 'camellia-256-cbc',\n  'camellia128-cbc@openssh.com': 'camellia-128-cbc',\n  'camellia192-cbc@openssh.com': 'camellia-192-cbc',\n  'camellia256-cbc@openssh.com': 'camellia-256-cbc',\n  '3des-ctr': 'des-ede3',\n  'blowfish-ctr': 'bf-ecb',\n  'aes256-ctr': 'aes-256-ctr',\n  'aes192-ctr': 'aes-192-ctr',\n  'aes128-ctr': 'aes-128-ctr',\n  'cast128-ctr': 'cast5-ecb',\n  'camellia128-ctr': 'camellia-128-ecb',\n  'camellia192-ctr': 'camellia-192-ecb',\n  'camellia256-ctr': 'camellia-256-ecb',\n  'camellia128-ctr@openssh.com': 'camellia-128-ecb',\n  'camellia192-ctr@openssh.com': 'camellia-192-ecb',\n  'camellia256-ctr@openssh.com': 'camellia-256-ecb',\n  // HMAC\n  'hmac-sha1-96': 'sha1',\n  'hmac-sha1': 'sha1',\n  'hmac-sha2-256': 'sha256',\n  'hmac-sha2-256-96': 'sha256',\n  'hmac-sha2-512': 'sha512',\n  'hmac-sha2-512-96': 'sha512',\n  'hmac-md5-96': 'md5',\n  'hmac-md5': 'md5',\n  'hmac-ripemd160': 'ripemd160'\n};\n\nvar BUGS = exports.BUGS = {\n  BAD_DHGEX: 1,\n  OLD_EXIT: 2,\n  DYN_RPORT_BUG: 4\n};\n\nexports.BUGGY_IMPLS = [\n  [ 'Cisco-1.25', BUGS.BAD_DHGEX ],\n  [ /^[0-9.]+$/, BUGS.OLD_EXIT ], // old SSH.com implementations\n  [ /^OpenSSH_5\\.\\d+/, BUGS.DYN_RPORT_BUG ]\n];\n","import { Component, Input, ViewChild, ElementRef } from '@angular/core'\nimport { NgbActiveModal } from '@ng-bootstrap/ng-bootstrap'\n\n@Component({\n    template: require('./promptModal.component.pug'),\n})\nexport class PromptModalComponent {\n    @Input() value: string\n    @Input() password: boolean\n    @ViewChild('input') input: ElementRef\n\n    constructor (\n        private modalInstance: NgbActiveModal,\n    ) { }\n\n    ngOnInit () {\n        setTimeout(() => {\n            this.input.nativeElement.focus()\n        })\n    }\n\n    ok () {\n        this.modalInstance.close(this.value)\n    }\n\n    cancel () {\n        this.modalInstance.close('')\n    }\n}\n","import { Component } from '@angular/core'\nimport { NgbActiveModal } from '@ng-bootstrap/ng-bootstrap'\nimport { ElectronService, HostAppService } from 'terminus-core'\nimport { PasswordStorageService } from '../services/passwordStorage.service'\nimport { SSHConnection, LoginScript } from '../api'\n\n@Component({\n    template: require('./editConnectionModal.component.pug'),\n})\nexport class EditConnectionModalComponent {\n    connection: SSHConnection\n    newScript: LoginScript\n    hasSavedPassword: boolean\n\n    constructor (\n        private modalInstance: NgbActiveModal,\n        private electron: ElectronService,\n        private hostApp: HostAppService,\n        private passwordStorage: PasswordStorageService,\n    ) {\n        this.newScript = { expect: '', send: '' }\n    }\n\n    async ngOnInit () {\n        this.hasSavedPassword = !!(await this.passwordStorage.loadPassword(this.connection))\n    }\n\n    clearSavedPassword () {\n        this.hasSavedPassword = false\n        this.passwordStorage.deletePassword(this.connection)\n    }\n\n    selectPrivateKey () {\n        let path = this.electron.dialog.showOpenDialog(\n            this.hostApp.getWindow(),\n            {\n                title: 'Select private key',\n            }\n        )\n        if (path) {\n            this.connection.privateKey = path[0]\n        }\n    }\n\n    save () {\n        this.modalInstance.close(this.connection)\n    }\n\n    cancel () {\n        this.modalInstance.dismiss()\n    }\n\n    moveScriptUp (script: LoginScript) {\n        let index = this.connection.scripts.indexOf(script)\n        if (index > 0) {\n            this.connection.scripts.splice(index, 1)\n            this.connection.scripts.splice(index - 1, 0, script)\n        }\n    }\n\n    moveScriptDown (script: LoginScript) {\n        let index = this.connection.scripts.indexOf(script)\n        if (index >= 0 && index < this.connection.scripts.length - 1) {\n            this.connection.scripts.splice(index, 1)\n            this.connection.scripts.splice(index + 1, 0, script)\n        }\n    }\n\n    deleteScript (script: LoginScript) {\n        if (confirm(`Delete?`)) {\n            this.connection.scripts = this.connection.scripts.filter(x => x !== script)\n        }\n    }\n\n    addScript () {\n        if (!this.connection.scripts) {\n            this.connection.scripts = []\n        }\n        this.connection.scripts.push({...this.newScript})\n        this.clearScript()\n    }\n\n    clearScript () {\n        this.newScript.expect = ''\n        this.newScript.send = ''\n        this.newScript.isRegex = false\n        this.newScript.optional = false\n    }\n}\n","import { Component } from '@angular/core'\nimport { NgbActiveModal } from '@ng-bootstrap/ng-bootstrap'\nimport { ToastrService } from 'ngx-toastr'\nimport { ConfigService, AppService } from 'terminus-core'\nimport { SettingsTabComponent } from 'terminus-settings'\nimport { SSHService } from '../services/ssh.service'\nimport { SSHConnection, ISSHConnectionGroup } from '../api'\n\n@Component({\n    template: require('./sshModal.component.pug'),\n    styles: [require('./sshModal.component.scss')],\n})\nexport class SSHModalComponent {\n    connections: SSHConnection[]\n    childFolders: ISSHConnectionGroup[]\n    quickTarget: string\n    lastConnection: SSHConnection\n    childGroups: ISSHConnectionGroup[]\n    groupCollapsed: {[id: string]: boolean} = {}\n\n    constructor (\n        public modalInstance: NgbActiveModal,\n        private config: ConfigService,\n        private ssh: SSHService,\n        private app: AppService,\n        private toastr: ToastrService,\n    ) { }\n\n    ngOnInit () {\n        this.connections = this.config.store.ssh.connections\n        if (window.localStorage.lastConnection) {\n            this.lastConnection = JSON.parse(window.localStorage.lastConnection)\n        }\n        this.refresh()\n    }\n\n    quickConnect () {\n        let user = 'root'\n        let host = this.quickTarget\n        let port = 22\n        if (host.includes('@')) {\n            [user, host] = host.split('@')\n        }\n        if (host.includes(':')) {\n            port = parseInt(host.split(':')[1])\n            host = host.split(':')[0]\n        }\n\n        let connection: SSHConnection = {\n            name: this.quickTarget,\n            host, user, port\n        }\n        window.localStorage.lastConnection = JSON.stringify(connection)\n        this.connect(connection)\n    }\n\n    clearLastConnection () {\n        window.localStorage.lastConnection = null\n        this.lastConnection = null\n    }\n\n    connect (connection: SSHConnection) {\n        this.close()\n        this.ssh.connect(connection).catch(error => {\n            this.toastr.error(`Could not connect: ${error}`)\n        }).then(() => {\n            setTimeout(() => {\n                this.app.activeTab.emitFocused()\n            })\n        })\n    }\n\n    manageConnections () {\n        this.close()\n        this.app.openNewTab(SettingsTabComponent, { activeTab: 'ssh' })\n    }\n\n    close () {\n        this.modalInstance.close()\n    }\n\n    refresh () {\n        this.childGroups = []\n\n        let connections = this.connections\n        if (this.quickTarget) {\n            connections = connections.filter(connection => (connection.name + connection.group).toLowerCase().includes(this.quickTarget))\n        }\n\n        for (let connection of connections) {\n            connection.group = connection.group || null\n            let group = this.childGroups.find(x => x.name === connection.group)\n            if (!group) {\n                group = {\n                    name: connection.group,\n                    connections: [],\n                }\n                this.childGroups.push(group)\n            }\n            group.connections.push(connection)\n        }\n    }\n}\n","import { Injectable, NgZone } from '@angular/core'\nimport { NgbModal } from '@ng-bootstrap/ng-bootstrap'\nimport { Client } from 'ssh2'\nimport * as fs from 'mz/fs'\nimport * as path from 'path'\nimport { ToastrService } from 'ngx-toastr'\nimport { AppService, HostAppService, Platform, Logger, LogService } from 'terminus-core'\nimport { TerminalTabComponent } from 'terminus-terminal'\nimport { SSHConnection, SSHSession } from '../api'\nimport { PromptModalComponent } from '../components/promptModal.component'\nimport { PasswordStorageService } from './passwordStorage.service'\nconst { SSH2Stream } = require('ssh2-streams')\n\n@Injectable()\nexport class SSHService {\n    private logger: Logger\n\n    constructor (\n        log: LogService,\n        private app: AppService,\n        private zone: NgZone,\n        private ngbModal: NgbModal,\n        private hostApp: HostAppService,\n        private passwordStorage: PasswordStorageService,\n        private toastr: ToastrService,\n    ) {\n        this.logger = log.create('ssh')\n    }\n\n    async connect (connection: SSHConnection): Promise<TerminalTabComponent> {\n        let privateKey: string = null\n        let privateKeyPassphrase: string = null\n        let privateKeyPath = connection.privateKey\n        if (!privateKeyPath) {\n            let userKeyPath = path.join(process.env.HOME, '.ssh', 'id_rsa')\n            if (await fs.exists(userKeyPath)) {\n                this.logger.info('Using user\\'s default private key:', userKeyPath)\n                privateKeyPath = userKeyPath\n            }\n        }\n\n        if (privateKeyPath) {\n            try {\n                privateKey = (await fs.readFile(privateKeyPath)).toString()\n            } catch (error) {\n                this.toastr.warning('Could not read the private key file')\n            }\n\n            if (privateKey) {\n                this.logger.info('Loaded private key from', privateKeyPath)\n\n                let encrypted = privateKey.includes('ENCRYPTED')\n                if (privateKeyPath.toLowerCase().endsWith('.ppk')) {\n                    encrypted = encrypted || privateKey.includes('Encryption:') && !privateKey.includes('Encryption: none')\n                }\n                if (encrypted) {\n                    let modal = this.ngbModal.open(PromptModalComponent)\n                    modal.componentInstance.prompt = 'Private key passphrase'\n                    modal.componentInstance.password = true\n                    try {\n                        privateKeyPassphrase = await modal.result\n                    } catch (_err) { } // tslint:disable-line\n                }\n            }\n        }\n\n        let ssh = new Client()\n        let connected = false\n        let savedPassword: string = null\n        await new Promise((resolve, reject) => {\n            ssh.on('ready', () => {\n                connected = true\n                if (savedPassword) {\n                    this.passwordStorage.savePassword(connection, savedPassword)\n                }\n                this.zone.run(resolve)\n            })\n            ssh.on('error', error => {\n                this.passwordStorage.deletePassword(connection)\n                this.zone.run(() => {\n                    if (connected) {\n                        this.toastr.error(error.toString())\n                    } else {\n                        reject(error)\n                    }\n                })\n            })\n            ssh.on('keyboard-interactive', (name, instructions, instructionsLang, prompts, finish) => this.zone.run(async () => {\n                console.log(name, instructions, instructionsLang)\n                let results = []\n                for (let prompt of prompts) {\n                    let modal = this.ngbModal.open(PromptModalComponent)\n                    modal.componentInstance.prompt = prompt.prompt\n                    modal.componentInstance.password = !prompt.echo\n                    results.push(await modal.result)\n                }\n                finish(results)\n            }))\n\n            let agent: string = null\n            if (this.hostApp.platform === Platform.Windows) {\n                agent = 'pageant'\n            } else {\n                agent = process.env.SSH_AUTH_SOCK\n            }\n\n            ssh.connect({\n                host: connection.host,\n                port: connection.port || 22,\n                username: connection.user,\n                password: connection.privateKey ? undefined : '',\n                privateKey,\n                passphrase: privateKeyPassphrase,\n                tryKeyboard: true,\n                agent,\n                agentForward: !!agent,\n                keepaliveInterval: connection.keepaliveInterval,\n                keepaliveCountMax: connection.keepaliveCountMax,\n                readyTimeout: connection.readyTimeout,\n            })\n\n            let keychainPasswordUsed = false\n\n            ;(ssh as any).config.password = () => this.zone.run(async () => {\n                if (connection.password) {\n                    this.logger.info('Using preset password')\n                    return connection.password\n                }\n\n                if (!keychainPasswordUsed) {\n                    let password = await this.passwordStorage.loadPassword(connection)\n                    if (password) {\n                        this.logger.info('Using saved password')\n                        keychainPasswordUsed = true\n                        return password\n                    }\n                }\n\n                let modal = this.ngbModal.open(PromptModalComponent)\n                modal.componentInstance.prompt = `Password for ${connection.user}@${connection.host}`\n                modal.componentInstance.password = true\n                savedPassword = await modal.result\n                return savedPassword\n            })\n        })\n\n        try {\n            let shell = await new Promise((resolve, reject) => {\n                ssh.shell({ term: 'xterm-256color' }, (err, shell) => {\n                    if (err) {\n                        reject(err)\n                    } else {\n                        resolve(shell)\n                    }\n                })\n            })\n\n            let session = new SSHSession(shell, connection)\n\n            return this.zone.run(() => this.app.openNewTab(\n                TerminalTabComponent,\n                { session, sessionOptions: {} }\n            ) as TerminalTabComponent)\n        } catch (error) {\n            console.log(error)\n            throw error\n        }\n    }\n}\n\nconst _authPassword = SSH2Stream.prototype.authPassword\nSSH2Stream.prototype.authPassword = async function (username, passwordFn) {\n    _authPassword.bind(this)(username, await passwordFn())\n}\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\n// If you have no idea what ASN.1 or BER is, see this:\n// ftp://ftp.rsa.com/pub/pkcs/ascii/layman.asc\n\nvar Ber = require('./ber/index');\n\n\n\n///--- Exported API\n\nmodule.exports = {\n\n  Ber: Ber,\n\n  BerReader: Ber.Reader,\n\n  BerWriter: Ber.Writer\n\n};\n","exports = module.exports = SemVer;\n\n// The debug function is excluded entirely from the minified version.\n/* nomin */ var debug;\n/* nomin */ if (typeof process === 'object' &&\n    /* nomin */ process.env &&\n    /* nomin */ process.env.NODE_DEBUG &&\n    /* nomin */ /\\bsemver\\b/i.test(process.env.NODE_DEBUG))\n  /* nomin */ debug = function() {\n    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);\n    /* nomin */ args.unshift('SEMVER');\n    /* nomin */ console.log.apply(console, args);\n    /* nomin */ };\n/* nomin */ else\n  /* nomin */ debug = function() {};\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexports.SEMVER_SPEC_VERSION = '2.0.0';\n\nvar MAX_LENGTH = 256;\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\n// Max safe segment length for coercion.\nvar MAX_SAFE_COMPONENT_LENGTH = 16;\n\n// The actual regexps go on exports.re\nvar re = exports.re = [];\nvar src = exports.src = [];\nvar R = 0;\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\nvar NUMERICIDENTIFIER = R++;\nsrc[NUMERICIDENTIFIER] = '0|[1-9]\\\\d*';\nvar NUMERICIDENTIFIERLOOSE = R++;\nsrc[NUMERICIDENTIFIERLOOSE] = '[0-9]+';\n\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\nvar NONNUMERICIDENTIFIER = R++;\nsrc[NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*';\n\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\nvar MAINVERSION = R++;\nsrc[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')';\n\nvar MAINVERSIONLOOSE = R++;\nsrc[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\nvar PRERELEASEIDENTIFIER = R++;\nsrc[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +\n                            '|' + src[NONNUMERICIDENTIFIER] + ')';\n\nvar PRERELEASEIDENTIFIERLOOSE = R++;\nsrc[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +\n                                 '|' + src[NONNUMERICIDENTIFIER] + ')';\n\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\nvar PRERELEASE = R++;\nsrc[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +\n                  '(?:\\\\.' + src[PRERELEASEIDENTIFIER] + ')*))';\n\nvar PRERELEASELOOSE = R++;\nsrc[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +\n                       '(?:\\\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\nvar BUILDIDENTIFIER = R++;\nsrc[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\nvar BUILD = R++;\nsrc[BUILD] = '(?:\\\\+(' + src[BUILDIDENTIFIER] +\n             '(?:\\\\.' + src[BUILDIDENTIFIER] + ')*))';\n\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\nvar FULL = R++;\nvar FULLPLAIN = 'v?' + src[MAINVERSION] +\n                src[PRERELEASE] + '?' +\n                src[BUILD] + '?';\n\nsrc[FULL] = '^' + FULLPLAIN + '$';\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\nvar LOOSEPLAIN = '[v=\\\\s]*' + src[MAINVERSIONLOOSE] +\n                 src[PRERELEASELOOSE] + '?' +\n                 src[BUILD] + '?';\n\nvar LOOSE = R++;\nsrc[LOOSE] = '^' + LOOSEPLAIN + '$';\n\nvar GTLT = R++;\nsrc[GTLT] = '((?:<|>)?=?)';\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\nvar XRANGEIDENTIFIERLOOSE = R++;\nsrc[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*';\nvar XRANGEIDENTIFIER = R++;\nsrc[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\\\*';\n\nvar XRANGEPLAIN = R++;\nsrc[XRANGEPLAIN] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:' + src[PRERELEASE] + ')?' +\n                   src[BUILD] + '?' +\n                   ')?)?';\n\nvar XRANGEPLAINLOOSE = R++;\nsrc[XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:' + src[PRERELEASELOOSE] + ')?' +\n                        src[BUILD] + '?' +\n                        ')?)?';\n\nvar XRANGE = R++;\nsrc[XRANGE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAIN] + '$';\nvar XRANGELOOSE = R++;\nsrc[XRANGELOOSE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAINLOOSE] + '$';\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\nvar COERCE = R++;\nsrc[COERCE] = '(?:^|[^\\\\d])' +\n              '(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +\n              '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +\n              '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +\n              '(?:$|[^\\\\d])';\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\nvar LONETILDE = R++;\nsrc[LONETILDE] = '(?:~>?)';\n\nvar TILDETRIM = R++;\nsrc[TILDETRIM] = '(\\\\s*)' + src[LONETILDE] + '\\\\s+';\nre[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');\nvar tildeTrimReplace = '$1~';\n\nvar TILDE = R++;\nsrc[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';\nvar TILDELOOSE = R++;\nsrc[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\nvar LONECARET = R++;\nsrc[LONECARET] = '(?:\\\\^)';\n\nvar CARETTRIM = R++;\nsrc[CARETTRIM] = '(\\\\s*)' + src[LONECARET] + '\\\\s+';\nre[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');\nvar caretTrimReplace = '$1^';\n\nvar CARET = R++;\nsrc[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';\nvar CARETLOOSE = R++;\nsrc[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\nvar COMPARATORLOOSE = R++;\nsrc[COMPARATORLOOSE] = '^' + src[GTLT] + '\\\\s*(' + LOOSEPLAIN + ')$|^$';\nvar COMPARATOR = R++;\nsrc[COMPARATOR] = '^' + src[GTLT] + '\\\\s*(' + FULLPLAIN + ')$|^$';\n\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\nvar COMPARATORTRIM = R++;\nsrc[COMPARATORTRIM] = '(\\\\s*)' + src[GTLT] +\n                      '\\\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';\n\n// this one has to use the /g flag\nre[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');\nvar comparatorTrimReplace = '$1$2$3';\n\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\nvar HYPHENRANGE = R++;\nsrc[HYPHENRANGE] = '^\\\\s*(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s+-\\\\s+' +\n                   '(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s*$';\n\nvar HYPHENRANGELOOSE = R++;\nsrc[HYPHENRANGELOOSE] = '^\\\\s*(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s+-\\\\s+' +\n                        '(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s*$';\n\n// Star ranges basically just allow anything at all.\nvar STAR = R++;\nsrc[STAR] = '(<|>)?=?\\\\s*\\\\*';\n\n// Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\nfor (var i = 0; i < R; i++) {\n  debug(i, src[i]);\n  if (!re[i])\n    re[i] = new RegExp(src[i]);\n}\n\nexports.parse = parse;\nfunction parse(version, loose) {\n  if (version instanceof SemVer)\n    return version;\n\n  if (typeof version !== 'string')\n    return null;\n\n  if (version.length > MAX_LENGTH)\n    return null;\n\n  var r = loose ? re[LOOSE] : re[FULL];\n  if (!r.test(version))\n    return null;\n\n  try {\n    return new SemVer(version, loose);\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.valid = valid;\nfunction valid(version, loose) {\n  var v = parse(version, loose);\n  return v ? v.version : null;\n}\n\n\nexports.clean = clean;\nfunction clean(version, loose) {\n  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);\n  return s ? s.version : null;\n}\n\nexports.SemVer = SemVer;\n\nfunction SemVer(version, loose) {\n  if (version instanceof SemVer) {\n    if (version.loose === loose)\n      return version;\n    else\n      version = version.version;\n  } else if (typeof version !== 'string') {\n    throw new TypeError('Invalid Version: ' + version);\n  }\n\n  if (version.length > MAX_LENGTH)\n    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')\n\n  if (!(this instanceof SemVer))\n    return new SemVer(version, loose);\n\n  debug('SemVer', version, loose);\n  this.loose = loose;\n  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);\n\n  if (!m)\n    throw new TypeError('Invalid Version: ' + version);\n\n  this.raw = version;\n\n  // these are actually numbers\n  this.major = +m[1];\n  this.minor = +m[2];\n  this.patch = +m[3];\n\n  if (this.major > MAX_SAFE_INTEGER || this.major < 0)\n    throw new TypeError('Invalid major version')\n\n  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)\n    throw new TypeError('Invalid minor version')\n\n  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)\n    throw new TypeError('Invalid patch version')\n\n  // numberify any prerelease numeric ids\n  if (!m[4])\n    this.prerelease = [];\n  else\n    this.prerelease = m[4].split('.').map(function(id) {\n      if (/^[0-9]+$/.test(id)) {\n        var num = +id;\n        if (num >= 0 && num < MAX_SAFE_INTEGER)\n          return num;\n      }\n      return id;\n    });\n\n  this.build = m[5] ? m[5].split('.') : [];\n  this.format();\n}\n\nSemVer.prototype.format = function() {\n  this.version = this.major + '.' + this.minor + '.' + this.patch;\n  if (this.prerelease.length)\n    this.version += '-' + this.prerelease.join('.');\n  return this.version;\n};\n\nSemVer.prototype.toString = function() {\n  return this.version;\n};\n\nSemVer.prototype.compare = function(other) {\n  debug('SemVer.compare', this.version, this.loose, other);\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return this.compareMain(other) || this.comparePre(other);\n};\n\nSemVer.prototype.compareMain = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return compareIdentifiers(this.major, other.major) ||\n         compareIdentifiers(this.minor, other.minor) ||\n         compareIdentifiers(this.patch, other.patch);\n};\n\nSemVer.prototype.comparePre = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  // NOT having a prerelease is > having one\n  if (this.prerelease.length && !other.prerelease.length)\n    return -1;\n  else if (!this.prerelease.length && other.prerelease.length)\n    return 1;\n  else if (!this.prerelease.length && !other.prerelease.length)\n    return 0;\n\n  var i = 0;\n  do {\n    var a = this.prerelease[i];\n    var b = other.prerelease[i];\n    debug('prerelease compare', i, a, b);\n    if (a === undefined && b === undefined)\n      return 0;\n    else if (b === undefined)\n      return 1;\n    else if (a === undefined)\n      return -1;\n    else if (a === b)\n      continue;\n    else\n      return compareIdentifiers(a, b);\n  } while (++i);\n};\n\n// preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\nSemVer.prototype.inc = function(release, identifier) {\n  switch (release) {\n    case 'premajor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor = 0;\n      this.major++;\n      this.inc('pre', identifier);\n      break;\n    case 'preminor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor++;\n      this.inc('pre', identifier);\n      break;\n    case 'prepatch':\n      // If this is already a prerelease, it will bump to the next version\n      // drop any prereleases that might already exist, since they are not\n      // relevant at this point.\n      this.prerelease.length = 0;\n      this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n    // If the input is a non-prerelease version, this acts the same as\n    // prepatch.\n    case 'prerelease':\n      if (this.prerelease.length === 0)\n        this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n\n    case 'major':\n      // If this is a pre-major version, bump up to the same major version.\n      // Otherwise increment major.\n      // 1.0.0-5 bumps to 1.0.0\n      // 1.1.0 bumps to 2.0.0\n      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)\n        this.major++;\n      this.minor = 0;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'minor':\n      // If this is a pre-minor version, bump up to the same minor version.\n      // Otherwise increment minor.\n      // 1.2.0-5 bumps to 1.2.0\n      // 1.2.1 bumps to 1.3.0\n      if (this.patch !== 0 || this.prerelease.length === 0)\n        this.minor++;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'patch':\n      // If this is not a pre-release version, it will increment the patch.\n      // If it is a pre-release it will bump up to the same patch version.\n      // 1.2.0-5 patches to 1.2.0\n      // 1.2.0 patches to 1.2.1\n      if (this.prerelease.length === 0)\n        this.patch++;\n      this.prerelease = [];\n      break;\n    // This probably shouldn't be used publicly.\n    // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n    case 'pre':\n      if (this.prerelease.length === 0)\n        this.prerelease = [0];\n      else {\n        var i = this.prerelease.length;\n        while (--i >= 0) {\n          if (typeof this.prerelease[i] === 'number') {\n            this.prerelease[i]++;\n            i = -2;\n          }\n        }\n        if (i === -1) // didn't increment anything\n          this.prerelease.push(0);\n      }\n      if (identifier) {\n        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n        if (this.prerelease[0] === identifier) {\n          if (isNaN(this.prerelease[1]))\n            this.prerelease = [identifier, 0];\n        } else\n          this.prerelease = [identifier, 0];\n      }\n      break;\n\n    default:\n      throw new Error('invalid increment argument: ' + release);\n  }\n  this.format();\n  this.raw = this.version;\n  return this;\n};\n\nexports.inc = inc;\nfunction inc(version, release, loose, identifier) {\n  if (typeof(loose) === 'string') {\n    identifier = loose;\n    loose = undefined;\n  }\n\n  try {\n    return new SemVer(version, loose).inc(release, identifier).version;\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.diff = diff;\nfunction diff(version1, version2) {\n  if (eq(version1, version2)) {\n    return null;\n  } else {\n    var v1 = parse(version1);\n    var v2 = parse(version2);\n    if (v1.prerelease.length || v2.prerelease.length) {\n      for (var key in v1) {\n        if (key === 'major' || key === 'minor' || key === 'patch') {\n          if (v1[key] !== v2[key]) {\n            return 'pre'+key;\n          }\n        }\n      }\n      return 'prerelease';\n    }\n    for (var key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return key;\n        }\n      }\n    }\n  }\n}\n\nexports.compareIdentifiers = compareIdentifiers;\n\nvar numeric = /^[0-9]+$/;\nfunction compareIdentifiers(a, b) {\n  var anum = numeric.test(a);\n  var bnum = numeric.test(b);\n\n  if (anum && bnum) {\n    a = +a;\n    b = +b;\n  }\n\n  return (anum && !bnum) ? -1 :\n         (bnum && !anum) ? 1 :\n         a < b ? -1 :\n         a > b ? 1 :\n         0;\n}\n\nexports.rcompareIdentifiers = rcompareIdentifiers;\nfunction rcompareIdentifiers(a, b) {\n  return compareIdentifiers(b, a);\n}\n\nexports.major = major;\nfunction major(a, loose) {\n  return new SemVer(a, loose).major;\n}\n\nexports.minor = minor;\nfunction minor(a, loose) {\n  return new SemVer(a, loose).minor;\n}\n\nexports.patch = patch;\nfunction patch(a, loose) {\n  return new SemVer(a, loose).patch;\n}\n\nexports.compare = compare;\nfunction compare(a, b, loose) {\n  return new SemVer(a, loose).compare(new SemVer(b, loose));\n}\n\nexports.compareLoose = compareLoose;\nfunction compareLoose(a, b) {\n  return compare(a, b, true);\n}\n\nexports.rcompare = rcompare;\nfunction rcompare(a, b, loose) {\n  return compare(b, a, loose);\n}\n\nexports.sort = sort;\nfunction sort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.compare(a, b, loose);\n  });\n}\n\nexports.rsort = rsort;\nfunction rsort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.rcompare(a, b, loose);\n  });\n}\n\nexports.gt = gt;\nfunction gt(a, b, loose) {\n  return compare(a, b, loose) > 0;\n}\n\nexports.lt = lt;\nfunction lt(a, b, loose) {\n  return compare(a, b, loose) < 0;\n}\n\nexports.eq = eq;\nfunction eq(a, b, loose) {\n  return compare(a, b, loose) === 0;\n}\n\nexports.neq = neq;\nfunction neq(a, b, loose) {\n  return compare(a, b, loose) !== 0;\n}\n\nexports.gte = gte;\nfunction gte(a, b, loose) {\n  return compare(a, b, loose) >= 0;\n}\n\nexports.lte = lte;\nfunction lte(a, b, loose) {\n  return compare(a, b, loose) <= 0;\n}\n\nexports.cmp = cmp;\nfunction cmp(a, op, b, loose) {\n  var ret;\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a === b;\n      break;\n    case '!==':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a !== b;\n      break;\n    case '': case '=': case '==': ret = eq(a, b, loose); break;\n    case '!=': ret = neq(a, b, loose); break;\n    case '>': ret = gt(a, b, loose); break;\n    case '>=': ret = gte(a, b, loose); break;\n    case '<': ret = lt(a, b, loose); break;\n    case '<=': ret = lte(a, b, loose); break;\n    default: throw new TypeError('Invalid operator: ' + op);\n  }\n  return ret;\n}\n\nexports.Comparator = Comparator;\nfunction Comparator(comp, loose) {\n  if (comp instanceof Comparator) {\n    if (comp.loose === loose)\n      return comp;\n    else\n      comp = comp.value;\n  }\n\n  if (!(this instanceof Comparator))\n    return new Comparator(comp, loose);\n\n  debug('comparator', comp, loose);\n  this.loose = loose;\n  this.parse(comp);\n\n  if (this.semver === ANY)\n    this.value = '';\n  else\n    this.value = this.operator + this.semver.version;\n\n  debug('comp', this);\n}\n\nvar ANY = {};\nComparator.prototype.parse = function(comp) {\n  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var m = comp.match(r);\n\n  if (!m)\n    throw new TypeError('Invalid comparator: ' + comp);\n\n  this.operator = m[1];\n  if (this.operator === '=')\n    this.operator = '';\n\n  // if it literally is just '>' or '' then allow anything.\n  if (!m[2])\n    this.semver = ANY;\n  else\n    this.semver = new SemVer(m[2], this.loose);\n};\n\nComparator.prototype.toString = function() {\n  return this.value;\n};\n\nComparator.prototype.test = function(version) {\n  debug('Comparator.test', version, this.loose);\n\n  if (this.semver === ANY)\n    return true;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  return cmp(version, this.operator, this.semver, this.loose);\n};\n\nComparator.prototype.intersects = function(comp, loose) {\n  if (!(comp instanceof Comparator)) {\n    throw new TypeError('a Comparator is required');\n  }\n\n  var rangeTmp;\n\n  if (this.operator === '') {\n    rangeTmp = new Range(comp.value, loose);\n    return satisfies(this.value, rangeTmp, loose);\n  } else if (comp.operator === '') {\n    rangeTmp = new Range(this.value, loose);\n    return satisfies(comp.semver, rangeTmp, loose);\n  }\n\n  var sameDirectionIncreasing =\n    (this.operator === '>=' || this.operator === '>') &&\n    (comp.operator === '>=' || comp.operator === '>');\n  var sameDirectionDecreasing =\n    (this.operator === '<=' || this.operator === '<') &&\n    (comp.operator === '<=' || comp.operator === '<');\n  var sameSemVer = this.semver.version === comp.semver.version;\n  var differentDirectionsInclusive =\n    (this.operator === '>=' || this.operator === '<=') &&\n    (comp.operator === '>=' || comp.operator === '<=');\n  var oppositeDirectionsLessThan =\n    cmp(this.semver, '<', comp.semver, loose) &&\n    ((this.operator === '>=' || this.operator === '>') &&\n    (comp.operator === '<=' || comp.operator === '<'));\n  var oppositeDirectionsGreaterThan =\n    cmp(this.semver, '>', comp.semver, loose) &&\n    ((this.operator === '<=' || this.operator === '<') &&\n    (comp.operator === '>=' || comp.operator === '>'));\n\n  return sameDirectionIncreasing || sameDirectionDecreasing ||\n    (sameSemVer && differentDirectionsInclusive) ||\n    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;\n};\n\n\nexports.Range = Range;\nfunction Range(range, loose) {\n  if (range instanceof Range) {\n    if (range.loose === loose) {\n      return range;\n    } else {\n      return new Range(range.raw, loose);\n    }\n  }\n\n  if (range instanceof Comparator) {\n    return new Range(range.value, loose);\n  }\n\n  if (!(this instanceof Range))\n    return new Range(range, loose);\n\n  this.loose = loose;\n\n  // First, split based on boolean or ||\n  this.raw = range;\n  this.set = range.split(/\\s*\\|\\|\\s*/).map(function(range) {\n    return this.parseRange(range.trim());\n  }, this).filter(function(c) {\n    // throw out any that are not relevant for whatever reason\n    return c.length;\n  });\n\n  if (!this.set.length) {\n    throw new TypeError('Invalid SemVer Range: ' + range);\n  }\n\n  this.format();\n}\n\nRange.prototype.format = function() {\n  this.range = this.set.map(function(comps) {\n    return comps.join(' ').trim();\n  }).join('||').trim();\n  return this.range;\n};\n\nRange.prototype.toString = function() {\n  return this.range;\n};\n\nRange.prototype.parseRange = function(range) {\n  var loose = this.loose;\n  range = range.trim();\n  debug('range', range, loose);\n  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];\n  range = range.replace(hr, hyphenReplace);\n  debug('hyphen replace', range);\n  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);\n  debug('comparator trim', range, re[COMPARATORTRIM]);\n\n  // `~ 1.2.3` => `~1.2.3`\n  range = range.replace(re[TILDETRIM], tildeTrimReplace);\n\n  // `^ 1.2.3` => `^1.2.3`\n  range = range.replace(re[CARETTRIM], caretTrimReplace);\n\n  // normalize spaces\n  range = range.split(/\\s+/).join(' ');\n\n  // At this point, the range is completely trimmed and\n  // ready to be split into comparators.\n\n  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var set = range.split(' ').map(function(comp) {\n    return parseComparator(comp, loose);\n  }).join(' ').split(/\\s+/);\n  if (this.loose) {\n    // in loose mode, throw out any that are not valid comparators\n    set = set.filter(function(comp) {\n      return !!comp.match(compRe);\n    });\n  }\n  set = set.map(function(comp) {\n    return new Comparator(comp, loose);\n  });\n\n  return set;\n};\n\nRange.prototype.intersects = function(range, loose) {\n  if (!(range instanceof Range)) {\n    throw new TypeError('a Range is required');\n  }\n\n  return this.set.some(function(thisComparators) {\n    return thisComparators.every(function(thisComparator) {\n      return range.set.some(function(rangeComparators) {\n        return rangeComparators.every(function(rangeComparator) {\n          return thisComparator.intersects(rangeComparator, loose);\n        });\n      });\n    });\n  });\n};\n\n// Mostly just for testing and legacy API reasons\nexports.toComparators = toComparators;\nfunction toComparators(range, loose) {\n  return new Range(range, loose).set.map(function(comp) {\n    return comp.map(function(c) {\n      return c.value;\n    }).join(' ').trim().split(' ');\n  });\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nfunction parseComparator(comp, loose) {\n  debug('comp', comp);\n  comp = replaceCarets(comp, loose);\n  debug('caret', comp);\n  comp = replaceTildes(comp, loose);\n  debug('tildes', comp);\n  comp = replaceXRanges(comp, loose);\n  debug('xrange', comp);\n  comp = replaceStars(comp, loose);\n  debug('stars', comp);\n  return comp;\n}\n\nfunction isX(id) {\n  return !id || id.toLowerCase() === 'x' || id === '*';\n}\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\nfunction replaceTildes(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceTilde(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceTilde(comp, loose) {\n  var r = loose ? re[TILDELOOSE] : re[TILDE];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('tilde', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p))\n      // ~1.2 == >=1.2.0 <1.3.0\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    else if (pr) {\n      debug('replaceTilde pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      ret = '>=' + M + '.' + m + '.' + p + pr +\n            ' <' + M + '.' + (+m + 1) + '.0';\n    } else\n      // ~1.2.3 == >=1.2.3 <1.3.0\n      ret = '>=' + M + '.' + m + '.' + p +\n            ' <' + M + '.' + (+m + 1) + '.0';\n\n    debug('tilde return', ret);\n    return ret;\n  });\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\nfunction replaceCarets(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceCaret(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceCaret(comp, loose) {\n  debug('caret', comp, loose);\n  var r = loose ? re[CARETLOOSE] : re[CARET];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('caret', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p)) {\n      if (M === '0')\n        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n      else\n        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';\n    } else if (pr) {\n      debug('replaceCaret pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p + pr +\n              ' <' + (+M + 1) + '.0.0';\n    } else {\n      debug('no pr');\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p +\n              ' <' + (+M + 1) + '.0.0';\n    }\n\n    debug('caret return', ret);\n    return ret;\n  });\n}\n\nfunction replaceXRanges(comp, loose) {\n  debug('replaceXRanges', comp, loose);\n  return comp.split(/\\s+/).map(function(comp) {\n    return replaceXRange(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceXRange(comp, loose) {\n  comp = comp.trim();\n  var r = loose ? re[XRANGELOOSE] : re[XRANGE];\n  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr);\n    var xM = isX(M);\n    var xm = xM || isX(m);\n    var xp = xm || isX(p);\n    var anyX = xp;\n\n    if (gtlt === '=' && anyX)\n      gtlt = '';\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0';\n      } else {\n        // nothing is forbidden\n        ret = '*';\n      }\n    } else if (gtlt && anyX) {\n      // replace X with 0\n      if (xm)\n        m = 0;\n      if (xp)\n        p = 0;\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        // >1.2.3 => >= 1.2.4\n        gtlt = '>=';\n        if (xm) {\n          M = +M + 1;\n          m = 0;\n          p = 0;\n        } else if (xp) {\n          m = +m + 1;\n          p = 0;\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<';\n        if (xm)\n          M = +M + 1;\n        else\n          m = +m + 1;\n      }\n\n      ret = gtlt + M + '.' + m + '.' + p;\n    } else if (xm) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    } else if (xp) {\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    }\n\n    debug('xRange return', ret);\n\n    return ret;\n  });\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nfunction replaceStars(comp, loose) {\n  debug('replaceStars', comp, loose);\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[STAR], '');\n}\n\n// This function is passed to string.replace(re[HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0\nfunction hyphenReplace($0,\n                       from, fM, fm, fp, fpr, fb,\n                       to, tM, tm, tp, tpr, tb) {\n\n  if (isX(fM))\n    from = '';\n  else if (isX(fm))\n    from = '>=' + fM + '.0.0';\n  else if (isX(fp))\n    from = '>=' + fM + '.' + fm + '.0';\n  else\n    from = '>=' + from;\n\n  if (isX(tM))\n    to = '';\n  else if (isX(tm))\n    to = '<' + (+tM + 1) + '.0.0';\n  else if (isX(tp))\n    to = '<' + tM + '.' + (+tm + 1) + '.0';\n  else if (tpr)\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;\n  else\n    to = '<=' + to;\n\n  return (from + ' ' + to).trim();\n}\n\n\n// if ANY of the sets match ALL of its comparators, then pass\nRange.prototype.test = function(version) {\n  if (!version)\n    return false;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  for (var i = 0; i < this.set.length; i++) {\n    if (testSet(this.set[i], version))\n      return true;\n  }\n  return false;\n};\n\nfunction testSet(set, version) {\n  for (var i = 0; i < set.length; i++) {\n    if (!set[i].test(version))\n      return false;\n  }\n\n  if (version.prerelease.length) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (var i = 0; i < set.length; i++) {\n      debug(set[i].semver);\n      if (set[i].semver === ANY)\n        continue;\n\n      if (set[i].semver.prerelease.length > 0) {\n        var allowed = set[i].semver;\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch)\n          return true;\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false;\n  }\n\n  return true;\n}\n\nexports.satisfies = satisfies;\nfunction satisfies(version, range, loose) {\n  try {\n    range = new Range(range, loose);\n  } catch (er) {\n    return false;\n  }\n  return range.test(version);\n}\n\nexports.maxSatisfying = maxSatisfying;\nfunction maxSatisfying(versions, range, loose) {\n  var max = null;\n  var maxSV = null;\n  try {\n    var rangeObj = new Range(range, loose);\n  } catch (er) {\n    return null;\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) { // satisfies(v, range, loose)\n      if (!max || maxSV.compare(v) === -1) { // compare(max, v, true)\n        max = v;\n        maxSV = new SemVer(max, loose);\n      }\n    }\n  })\n  return max;\n}\n\nexports.minSatisfying = minSatisfying;\nfunction minSatisfying(versions, range, loose) {\n  var min = null;\n  var minSV = null;\n  try {\n    var rangeObj = new Range(range, loose);\n  } catch (er) {\n    return null;\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) { // satisfies(v, range, loose)\n      if (!min || minSV.compare(v) === 1) { // compare(min, v, true)\n        min = v;\n        minSV = new SemVer(min, loose);\n      }\n    }\n  })\n  return min;\n}\n\nexports.validRange = validRange;\nfunction validRange(range, loose) {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, loose).range || '*';\n  } catch (er) {\n    return null;\n  }\n}\n\n// Determine if version is less than all the versions possible in the range\nexports.ltr = ltr;\nfunction ltr(version, range, loose) {\n  return outside(version, range, '<', loose);\n}\n\n// Determine if version is greater than all the versions possible in the range.\nexports.gtr = gtr;\nfunction gtr(version, range, loose) {\n  return outside(version, range, '>', loose);\n}\n\nexports.outside = outside;\nfunction outside(version, range, hilo, loose) {\n  version = new SemVer(version, loose);\n  range = new Range(range, loose);\n\n  var gtfn, ltefn, ltfn, comp, ecomp;\n  switch (hilo) {\n    case '>':\n      gtfn = gt;\n      ltefn = lte;\n      ltfn = lt;\n      comp = '>';\n      ecomp = '>=';\n      break;\n    case '<':\n      gtfn = lt;\n      ltefn = gte;\n      ltfn = gt;\n      comp = '<';\n      ecomp = '<=';\n      break;\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, loose)) {\n    return false;\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i];\n\n    var high = null;\n    var low = null;\n\n    comparators.forEach(function(comparator) {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator;\n      low = low || comparator;\n      if (gtfn(comparator.semver, high.semver, loose)) {\n        high = comparator;\n      } else if (ltfn(comparator.semver, low.semver, loose)) {\n        low = comparator;\n      }\n    });\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false;\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false;\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexports.prerelease = prerelease;\nfunction prerelease(version, loose) {\n  var parsed = parse(version, loose);\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null;\n}\n\nexports.intersects = intersects;\nfunction intersects(r1, r2, loose) {\n  r1 = new Range(r1, loose)\n  r2 = new Range(r2, loose)\n  return r1.intersects(r2)\n}\n\nexports.coerce = coerce;\nfunction coerce(version) {\n  if (version instanceof SemVer)\n    return version;\n\n  if (typeof version !== 'string')\n    return null;\n\n  var match = version.match(re[COERCE]);\n\n  if (match == null)\n    return null;\n\n  return parse((match[1] || '0') + '.' + (match[2] || '0') + '.' + (match[3] || '0')); \n}\n","var inherits = require('util').inherits;\nvar DuplexStream = require('stream').Duplex;\nvar ReadableStream = require('stream').Readable;\nvar WritableStream = require('stream').Writable;\n\nvar STDERR = require('ssh2-streams').constants.CHANNEL_EXTENDED_DATATYPE.STDERR;\n\nvar PACKET_SIZE = 32 * 1024;\nvar MAX_WINDOW = 1 * 1024 * 1024;\nvar WINDOW_THRESHOLD = MAX_WINDOW / 2;\nvar CUSTOM_EVENTS = [\n  'CHANNEL_EOF',\n  'CHANNEL_CLOSE',\n  'CHANNEL_DATA',\n  'CHANNEL_EXTENDED_DATA',\n  'CHANNEL_WINDOW_ADJUST',\n  'CHANNEL_SUCCESS',\n  'CHANNEL_FAILURE',\n  'CHANNEL_REQUEST'\n];\nvar CUSTOM_EVENTS_LEN = CUSTOM_EVENTS.length;\n\nfunction Channel(info, client, opts) {\n  var streamOpts = {\n    highWaterMark: MAX_WINDOW,\n    allowHalfOpen: (!opts || (opts && opts.allowHalfOpen !== false))\n  };\n\n  this.allowHalfOpen = streamOpts.allowHalfOpen;\n\n  DuplexStream.call(this, streamOpts);\n\n  var self = this;\n  var server = opts && opts.server;\n\n  this.server = server;\n  this.type = info.type;\n  this.subtype = undefined;\n  /*\n    incoming and outgoing contain these properties:\n    {\n      id: undefined,\n      window: undefined,\n      packetSize: undefined,\n      state: 'closed'\n    }\n  */\n  var incoming = this.incoming = info.incoming;\n  var incomingId = incoming.id;\n  var outgoing = this.outgoing = info.outgoing;\n  var callbacks = this._callbacks = [];\n  var exitCode;\n  var exitSignal;\n  var exitDump;\n  var exitDesc;\n  var exitLang;\n\n  this._client = client;\n  this._hasX11 = false;\n\n  var channels = client._channels;\n  var sshstream = client._sshstream;\n\n  function ondrain() {\n    if (self._waitClientDrain) {\n      self._waitClientDrain = false;\n      if (!self._waitWindow) {\n        if (self._chunk)\n          self._write(self._chunk, null, self._chunkcb);\n        else if (self._chunkcb)\n          self._chunkcb();\n        else if (self._chunkErr)\n          self.stderr._write(self._chunkErr, null, self._chunkcbErr);\n        else if (self._chunkcbErr)\n          self._chunkcbErr();\n      }\n    }\n  }\n  client._sock.on('drain', ondrain);\n\n  sshstream.once('CHANNEL_EOF:' + incomingId, function() {\n    if (incoming.state === 'closed' || incoming.state === 'eof')\n      return;\n    incoming.state = 'eof';\n\n    if (self.readable)\n      self.push(null);\n    if (!server && self.stderr.readable)\n      self.stderr.push(null);\n  }).once('CHANNEL_CLOSE:' + incomingId, function() {\n    if (incoming.state === 'closed')\n      return;\n    incoming.state = 'closed';\n\n    if (self.readable)\n      self.push(null);\n    if (server && self.stderr.writable)\n      self.stderr.end();\n    else if (!server && self.stderr.readable)\n      self.stderr.push(null);\n\n    if (outgoing.state === 'open' || outgoing.state === 'eof')\n      self.close();\n    if (outgoing.state === 'closing')\n      outgoing.state = 'closed';\n\n    delete channels[incomingId];\n\n    var state = self._writableState;\n    client._sock.removeListener('drain', ondrain);\n    if (!state.ending && !state.finished)\n      self.end();\n\n    // Take care of any outstanding channel requests\n    self._callbacks = [];\n    for (var i = 0; i < callbacks.length; ++i)\n      callbacks[i](true);\n    callbacks = self._callbacks;\n\n    if (!server) {\n      // align more with node child processes, where the close event gets the\n      // same arguments as the exit event\n      if (!self.readable) {\n        if (exitCode === null) {\n          self.emit('close', exitCode, exitSignal, exitDump, exitDesc,\n                    exitLang);\n        } else\n          self.emit('close', exitCode);\n      } else {\n        self.once('end', function() {\n          if (exitCode === null) {\n            self.emit('close', exitCode, exitSignal, exitDump, exitDesc,\n                      exitLang);\n          } else\n            self.emit('close', exitCode);\n        });\n      }\n\n      if (!self.stderr.readable)\n        self.stderr.emit('close');\n      else {\n        self.stderr.once('end', function() {\n          self.stderr.emit('close');\n        });\n      }\n    } else { // Server mode\n      if (!self.readable)\n        self.emit('close');\n      else {\n        self.once('end', function() {\n          self.emit('close');\n        });\n      }\n    }\n\n    for (var i = 0; i < CUSTOM_EVENTS_LEN; ++i)\n      sshstream.removeAllListeners(CUSTOM_EVENTS[i] + ':' + incomingId);\n  }).on('CHANNEL_DATA:' + incomingId, function(data) {\n    // the remote party should not be sending us data if there is no window\n    // space available ...\n    if (incoming.window === 0)\n      return;\n\n    incoming.window -= data.length;\n\n    if (!self.push(data)) {\n      self._waitChanDrain = true;\n      return;\n    }\n\n    if (incoming.window <= WINDOW_THRESHOLD)\n      windowAdjust(self);\n  }).on('CHANNEL_WINDOW_ADJUST:' + incomingId, function(amt) {\n    // the server is allowing us to send `amt` more bytes of data\n    outgoing.window += amt;\n\n    if (self._waitWindow) {\n      self._waitWindow = false;\n      if (!self._waitClientDrain) {\n        if (self._chunk)\n          self._write(self._chunk, null, self._chunkcb);\n        else if (self._chunkcb)\n          self._chunkcb();\n        else if (self._chunkErr)\n          self.stderr._write(self._chunkErr, null, self._chunkcbErr);\n        else if (self._chunkcbErr)\n          self._chunkcbErr();\n      }\n    }\n  }).on('CHANNEL_SUCCESS:' + incomingId, function() {\n    if (server) {\n      sshstream._kalast = Date.now();\n      sshstream._kacnt = 0;\n    } else\n      client._resetKA();\n    if (callbacks.length)\n      callbacks.shift()(false);\n  }).on('CHANNEL_FAILURE:' + incomingId, function() {\n    if (server) {\n      sshstream._kalast = Date.now();\n      sshstream._kacnt = 0;\n    } else\n      client._resetKA();\n    if (callbacks.length)\n      callbacks.shift()(true);\n  }).on('CHANNEL_REQUEST:' + incomingId, function(info) {\n    if (!server) {\n      if (info.request === 'exit-status') {\n        self.emit('exit', exitCode = info.code);\n        return;\n      } else if (info.request === 'exit-signal') {\n        self.emit('exit',\n                  exitCode = null,\n                  exitSignal = 'SIG' + info.signal,\n                  exitDump = info.coredump,\n                  exitDesc = info.description,\n                  exitLang = info.lang);\n        return;\n      }\n    }\n\n    // keepalive request? OpenSSH will send one as a channel request if there\n    // is a channel open\n\n    if (info.wantReply)\n      sshstream.channelFailure(outgoing.id);\n  });\n\n  this.stdin = this.stdout = this;\n\n  if (server)\n    this.stderr = new ServerStderr(this);\n  else {\n    this.stderr = new ReadableStream(streamOpts);\n    this.stderr._read = function(n) {\n      if (self._waitChanDrain) {\n        self._waitChanDrain = false;\n        if (incoming.window <= WINDOW_THRESHOLD)\n          windowAdjust(self);\n      }\n    };\n\n    sshstream.on('CHANNEL_EXTENDED_DATA:' + incomingId,\n      function(type, data) {\n        // the remote party should not be sending us data if there is no window\n        // space available ...\n        if (incoming.window === 0)\n          return;\n\n        incoming.window -= data.length;\n\n        if (!self.stderr.push(data)) {\n          self._waitChanDrain = true;\n          return;\n        }\n\n        if (incoming.window <= WINDOW_THRESHOLD)\n          windowAdjust(self);\n      }\n    );\n  }\n\n  // outgoing data\n  this._waitClientDrain = false; // Client stream-level backpressure\n  this._waitWindow = false; // SSH-level backpressure\n\n  // incoming data\n  this._waitChanDrain = false; // Channel Readable side backpressure\n\n  this._chunk = undefined;\n  this._chunkcb = undefined;\n  this._chunkErr = undefined;\n  this._chunkcbErr = undefined;\n\n  function onFinish() {\n    self.eof();\n    if (server || (!server && !self.allowHalfOpen))\n      self.close();\n    self.writable = false;\n  }\n  this.on('finish', onFinish)\n      .on('prefinish', onFinish); // for node v0.11+\n  function onEnd() {\n    self.readable = false;\n  }\n  this.on('end', onEnd)\n      .on('close', onEnd);\n}\ninherits(Channel, DuplexStream);\n\nChannel.prototype.eof = function() {\n  var ret = true;\n  var outgoing = this.outgoing;\n\n  if (outgoing.state === 'open') {\n    outgoing.state = 'eof';\n    ret = this._client._sshstream.channelEOF(outgoing.id);\n  }\n\n  return ret;\n};\n\nChannel.prototype.close = function() {\n  var ret = true;\n  var outgoing = this.outgoing;\n\n  if (outgoing.state === 'open' || outgoing.state === 'eof') {\n    outgoing.state = 'closing';\n    ret = this._client._sshstream.channelClose(outgoing.id);\n  }\n\n  return ret;\n};\n\nChannel.prototype._read = function(n) {\n  if (this._waitChanDrain) {\n    this._waitChanDrain = false;\n    if (this.incoming.window <= WINDOW_THRESHOLD)\n      windowAdjust(this);\n  }\n};\n\nChannel.prototype._write = function(data, encoding, cb) {\n  var sshstream = this._client._sshstream;\n  var outgoing = this.outgoing;\n  var packetSize = outgoing.packetSize;\n  var id = outgoing.id;\n  var window = outgoing.window;\n  var len = data.length;\n  var p = 0;\n  var ret;\n  var buf;\n  var sliceLen;\n\n  if (outgoing.state !== 'open')\n    return;\n\n  while (len - p > 0 && window > 0) {\n    sliceLen = len - p;\n    if (sliceLen > window)\n      sliceLen = window;\n    if (sliceLen > packetSize)\n      sliceLen = packetSize;\n\n    ret = sshstream.channelData(id, data.slice(p, p + sliceLen));\n\n    p += sliceLen;\n    window -= sliceLen;\n\n    if (!ret) {\n      this._waitClientDrain = true;\n      this._chunk = undefined;\n      this._chunkcb = cb;\n      break;\n    }\n  }\n\n  outgoing.window = window;\n\n  if (len - p > 0) {\n    if (window === 0)\n      this._waitWindow = true;\n    if (p > 0) {\n      // partial\n      buf = new Buffer(len - p);\n      data.copy(buf, 0, p);\n      this._chunk = buf;\n    } else\n      this._chunk = data;\n    this._chunkcb = cb;\n    return;\n  }\n\n  if (!this._waitClientDrain)\n    cb();\n};\n\nChannel.prototype.destroy = function() {\n  this.end();\n};\n\n// session type-specific methods\nChannel.prototype.setWindow = function(rows, cols, height, width) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  if (this.type === 'session'\n      && (this.subtype === 'shell' || this.subtype === 'exec')\n      && this.writable\n      && this.outgoing.state === 'open') {\n    return this._client._sshstream.windowChange(this.outgoing.id,\n                                                rows,\n                                                cols,\n                                                height,\n                                                width);\n  }\n\n  return true;\n};\nChannel.prototype.signal = function(signalName) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  if (this.type === 'session'\n      && this.writable\n      && this.outgoing.state === 'open')\n    return this._client._sshstream.signal(this.outgoing.id, signalName);\n\n  return true;\n};\nChannel.prototype.exit = function(name, coreDumped, msg) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  if (this.type === 'session'\n      && this.writable\n      && this.outgoing.state === 'open') {\n    if (typeof name === 'number')\n      return this._client._sshstream.exitStatus(this.outgoing.id, name);\n    else {\n      return this._client._sshstream.exitSignal(this.outgoing.id,\n                                                name,\n                                                coreDumped,\n                                                msg);\n    }\n  }\n\n  return true;\n};\n\nChannel.MAX_WINDOW = MAX_WINDOW;\nChannel.PACKET_SIZE = PACKET_SIZE;\n\nfunction windowAdjust(self) {\n  if (self.outgoing.state !== 'open')\n    return true;\n  var amt = MAX_WINDOW - self.incoming.window;\n  if (amt <= 0)\n    return true;\n  self.incoming.window += amt;\n  return self._client._sshstream.channelWindowAdjust(self.outgoing.id, amt);\n}\n\nfunction ServerStderr(channel) {\n  WritableStream.call(this, { highWaterMark: MAX_WINDOW });\n  this._channel = channel;\n}\ninherits(ServerStderr, WritableStream);\n\nServerStderr.prototype._write = function(data, encoding, cb) {\n  var channel = this._channel;\n  var sshstream = channel._client._sshstream;\n  var outgoing = channel.outgoing;\n  var packetSize = outgoing.packetSize;\n  var id = outgoing.id;\n  var window = outgoing.window;\n  var len = data.length;\n  var p = 0;\n  var ret;\n  var buf;\n  var sliceLen;\n\n  if (channel.outgoing.state !== 'open')\n    return;\n\n  while (len - p > 0 && window > 0) {\n    sliceLen = len - p;\n    if (sliceLen > window)\n      sliceLen = window;\n    if (sliceLen > packetSize)\n      sliceLen = packetSize;\n\n    ret = sshstream.channelExtData(id, data.slice(p, p + sliceLen), STDERR);\n\n    p += sliceLen;\n    window -= sliceLen;\n\n    if (!ret) {\n      channel._waitClientDrain = true;\n      channel._chunkErr = undefined;\n      channel._chunkcbErr = cb;\n      break;\n    }\n  }\n\n  outgoing.window = window;\n\n  if (len - p > 0) {\n    if (window === 0)\n      channel._waitWindow = true;\n    if (p > 0) {\n      // partial\n      buf = new Buffer(len - p);\n      data.copy(buf, 0, p);\n      channel._chunkErr = buf;\n    } else\n      channel._chunkErr = data;\n    channel._chunkcbErr = cb;\n    return;\n  }\n\n  if (!channel._waitClientDrain)\n    cb();\n};\n\nmodule.exports = Channel;\n","module.exports = __WEBPACK_EXTERNAL_MODULE__27__;","module.exports = require('./register')().Promise\n","'use strict'\n\nvar fs = require('fs')\n\nmodule.exports = clone(fs)\n\nfunction clone (obj) {\n  if (obj === null || typeof obj !== 'object')\n    return obj\n\n  if (obj instanceof Object)\n    var copy = { __proto__: obj.__proto__ }\n  else\n    var copy = Object.create(null)\n\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n  })\n\n  return copy\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__30__;","import { Component } from '@angular/core'\nimport { NgbModal } from '@ng-bootstrap/ng-bootstrap'\nimport { ConfigService } from 'terminus-core'\nimport { SSHConnection, ISSHConnectionGroup } from '../api'\nimport { EditConnectionModalComponent } from './editConnectionModal.component'\nimport { PromptModalComponent } from './promptModal.component'\n\n@Component({\n    template: require('./sshSettingsTab.component.pug'),\n})\nexport class SSHSettingsTabComponent {\n    connections: SSHConnection[]\n    childGroups: ISSHConnectionGroup[]\n    groupCollapsed: {[id: string]: boolean} = {}\n\n    constructor (\n        public config: ConfigService,\n        private ngbModal: NgbModal,\n    ) {\n        this.connections = this.config.store.ssh.connections\n        this.refresh()\n    }\n\n    createConnection () {\n        let connection: SSHConnection = {\n            name: '',\n            host: '',\n            port: 22,\n            user: 'root',\n        }\n\n        let modal = this.ngbModal.open(EditConnectionModalComponent)\n        modal.componentInstance.connection = connection\n        modal.result.then(result => {\n            this.connections.push(result)\n            this.config.store.ssh.connections = this.connections\n            this.config.save()\n            this.refresh()\n        })\n    }\n\n    editConnection (connection: SSHConnection) {\n        let modal = this.ngbModal.open(EditConnectionModalComponent)\n        modal.componentInstance.connection = Object.assign({}, connection)\n        modal.result.then(result => {\n            Object.assign(connection, result)\n            this.config.save()\n            this.refresh()\n        })\n    }\n\n    deleteConnection (connection: SSHConnection) {\n        if (confirm(`Delete \"${connection.name}\"?`)) {\n            this.connections = this.connections.filter(x => x !== connection)\n            this.config.store.ssh.connections = this.connections\n            this.config.save()\n            this.refresh()\n        }\n    }\n\n    editGroup (group: ISSHConnectionGroup) {\n        let modal = this.ngbModal.open(PromptModalComponent)\n        modal.componentInstance.prompt = 'New group name'\n        modal.componentInstance.value = group.name\n        modal.result.then(result => {\n            if (result) {\n                for (let connection of this.connections.filter(x => x.group === group.name)) {\n                    connection.group = result\n                }\n                this.config.save()\n                this.refresh()\n            }\n        })\n    }\n\n    deleteGroup (group: ISSHConnectionGroup) {\n        if (confirm(`Delete \"${group}\"?`)) {\n            for (let connection of this.connections.filter(x => x.group === group.name)) {\n                connection.group = null\n            }\n            this.config.save()\n            this.refresh()\n        }\n    }\n\n    refresh () {\n        this.childGroups = []\n\n        for (let connection of this.connections) {\n            connection.group = connection.group || null\n            let group = this.childGroups.find(x => x.name === connection.group)\n            if (!group) {\n                group = {\n                    name: connection.group,\n                    connections: [],\n                }\n                this.childGroups.push(group)\n            }\n            group.connections.push(connection)\n        }\n    }\n}\n","import { NgModule } from '@angular/core'\nimport { CommonModule } from '@angular/common'\nimport { FormsModule } from '@angular/forms'\nimport { NgbModule } from '@ng-bootstrap/ng-bootstrap'\nimport { ToastrModule } from 'ngx-toastr'\nimport { ToolbarButtonProvider, ConfigProvider } from 'terminus-core'\nimport TerminusCoreModule from 'terminus-core'\nimport { SettingsTabProvider } from 'terminus-settings'\n\nimport { EditConnectionModalComponent } from './components/editConnectionModal.component'\nimport { SSHModalComponent } from './components/sshModal.component'\nimport { PromptModalComponent } from './components/promptModal.component'\nimport { SSHSettingsTabComponent } from './components/sshSettingsTab.component'\nimport { SSHService } from './services/ssh.service'\nimport { PasswordStorageService } from './services/passwordStorage.service'\n\nimport { ButtonProvider } from './buttonProvider'\nimport { SSHConfigProvider } from './config'\nimport { SSHSettingsTabProvider } from './settings'\n\n@NgModule({\n    imports: [\n        NgbModule,\n        CommonModule,\n        FormsModule,\n        ToastrModule,\n        TerminusCoreModule,\n    ],\n    providers: [\n        PasswordStorageService,\n        SSHService,\n        { provide: ToolbarButtonProvider, useClass: ButtonProvider, multi: true },\n        { provide: ConfigProvider, useClass: SSHConfigProvider, multi: true },\n        { provide: SettingsTabProvider, useClass: SSHSettingsTabProvider, multi: true },\n    ],\n    entryComponents: [\n        EditConnectionModalComponent,\n        PromptModalComponent,\n        SSHModalComponent,\n        SSHSettingsTabComponent,\n    ],\n    declarations: [\n        EditConnectionModalComponent,\n        PromptModalComponent,\n        SSHModalComponent,\n        SSHSettingsTabComponent,\n    ],\n})\nexport default class SSHModule { }\n","module.exports = __WEBPACK_EXTERNAL_MODULE__33__;","module.exports = __WEBPACK_EXTERNAL_MODULE__34__;","if(typeof __WEBPACK_EXTERNAL_MODULE__35__ === 'undefined') {var e = new Error(\"Cannot find module 'xkeychain'\"); e.code = 'MODULE_NOT_FOUND'; throw e;}\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__35__;","if(typeof __WEBPACK_EXTERNAL_MODULE__36__ === 'undefined') {var e = new Error(\"Cannot find module 'wincredmgr'\"); e.code = 'MODULE_NOT_FOUND'; throw e;}\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__36__;","var pug = require(\"!../../../node_modules/pug-runtime/index.js\");\n\nfunction template(locals) {var pug_html = \"\", pug_mixins = {}, pug_interp;pug_html = pug_html + \"\\u003Cdiv class=\\\"modal-body\\\"\\u003E\\u003Cngb-tabset type=\\\"pills\\\" [activeId]=\\\"basic\\\"\\u003E\\u003Cngb-tab id=\\\"basic\\\"\\u003E\\u003Cng-template ngbTabTitle\\u003EBasic Setting\\u003C\\u002Fng-template\\u003E\\u003Cng-template ngbTabContent\\u003E\\u003Cdiv class=\\\"form-group\\\"\\u003E\\u003Clabel\\u003EName\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\\"form-control\\\" type=\\\"text\\\" autofocus [(ngModel)]=\\\"connection.name\\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"form-group\\\"\\u003E\\u003Clabel\\u003EGroup\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\\"form-control\\\" type=\\\"text\\\" placeholder=\\\"Ungrouped\\\" [(ngModel)]=\\\"connection.group\\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"form-group\\\"\\u003E\\u003Clabel\\u003EHost\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\\"form-control\\\" type=\\\"text\\\" [(ngModel)]=\\\"connection.host\\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"form-group\\\"\\u003E\\u003Clabel\\u003EPort\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\\"form-control\\\" type=\\\"number\\\" placeholder=\\\"22\\\" [(ngModel)]=\\\"connection.port\\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"form-group\\\"\\u003E\\u003Clabel\\u003EUsername\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\\"form-control\\\" type=\\\"text\\\" [(ngModel)]=\\\"connection.user\\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"alert alert-info d-flex bg-transparent text-white align-items-center\\\" *ngIf=\\\"hasSavedPassword\\\"\\u003E\\u003Cdiv class=\\\"mr-auto\\\"\\u003EThere is a saved password for this connection\\u003C\\u002Fdiv\\u003E\\u003Cbutton class=\\\"btn btn-danger ml-4\\\" (click)=\\\"clearSavedPassword()\\\"\\u003EForget\\u003C\\u002Fbutton\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"form-group\\\"\\u003E\\u003Clabel\\u003EPrivate key \\u003C\\u002Flabel\\u003E\\u003Cdiv class=\\\"input-group\\\"\\u003E\\u003Cinput class=\\\"form-control\\\" type=\\\"text\\\" placeholder=\\\"Key file path\\\" [(ngModel)]=\\\"connection.privateKey\\\"\\u003E\\u003Cdiv class=\\\"input-group-btn\\\"\\u003E\\u003Cbutton class=\\\"btn btn-secondary\\\" (click)=\\\"selectPrivateKey()\\\"\\u003E\\u003Ci class=\\\"fa fa-folder-open\\\"\\u003E\\u003C\\u002Fi\\u003E\\u003C\\u002Fbutton\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fng-template\\u003E\\u003C\\u002Fngb-tab\\u003E\\u003Cngb-tab id=\\\"advanced\\\"\\u003E\\u003Cng-template ngbTabTitle\\u003EAdvanced Setting\\u003C\\u002Fng-template\\u003E\\u003Cng-template ngbTabContent\\u003E\\u003Cdiv class=\\\"form-group\\\"\\u003E\\u003Clabel\\u003EKeep Alive Interval (Milliseconds)\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\\"form-control\\\" type=\\\"number\\\" placeholder=\\\"0\\\" [(ngModel)]=\\\"connection.keepaliveInterval\\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"form-group\\\"\\u003E\\u003Clabel\\u003EMax Keep Alive Count\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\\"form-control\\\" type=\\\"number\\\" placeholder=\\\"3\\\" [(ngModel)]=\\\"connection.keepaliveCountMax\\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"form-group\\\"\\u003E\\u003Clabel\\u003EReady Timeout (Milliseconds)\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\\"form-control\\\" type=\\\"number\\\" placeholder=\\\"20000\\\" [(ngModel)]=\\\"connection.readyTimeout\\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fng-template\\u003E\\u003C\\u002Fngb-tab\\u003E\\u003Cngb-tab id=\\\"scripts\\\"\\u003E\\u003Cng-template ngbTabTitle\\u003ELogin Scripts\\u003C\\u002Fng-template\\u003E\\u003Cng-template ngbTabContent\\u003E\\u003Ctable\\u003E\\u003Ctr\\u003E\\u003Cth\\u003EString to expect\\u003C\\u002Fth\\u003E\\u003Cth\\u003EString to be sent\\u003C\\u002Fth\\u003E\\u003Cth\\u003ERegex\\u003C\\u002Fth\\u003E\\u003Cth\\u003EOptional\\u003C\\u002Fth\\u003E\\u003Cth\\u003EActions\\u003C\\u002Fth\\u003E\\u003C\\u002Ftr\\u003E\\u003Ctr *ngFor=\\\"let script of connection.scripts\\\"\\u003E\\u003Ctd\\u003E\\u003Cinput class=\\\"form-control\\\" type=\\\"text\\\" [(ngModel)]=\\\"script.expect\\\"\\u003E\\u003C\\u002Ftd\\u003E\\u003Ctd\\u003E\\u003Cinput class=\\\"form-control\\\" type=\\\"text\\\" [(ngModel)]=\\\"script.send\\\"\\u003E\\u003C\\u002Ftd\\u003E\\u003Ctd\\u003E\\u003Ctoggle [(ngModel)]=\\\"script.isRegex\\\"\\u003E\\u003C\\u002Ftoggle\\u003E\\u003C\\u002Ftd\\u003E\\u003Ctd\\u003E\\u003Ctoggle [(ngModel)]=\\\"script.optional\\\"\\u003E\\u003C\\u002Ftoggle\\u003E\\u003C\\u002Ftd\\u003E\\u003Ctd\\u003E\\u003Cdiv class=\\\"input-group flex-nowrap\\\"\\u003E\\u003Cbutton class=\\\"btn btn-outline-info ml-0\\\" (click)=\\\"moveScriptUp(script)\\\"\\u003E\\u003Ci class=\\\"fa fa-arrow-up\\\"\\u003E\\u003C\\u002Fi\\u003E\\u003C\\u002Fbutton\\u003E\\u003Cbutton class=\\\"btn btn-outline-info ml-0\\\" (click)=\\\"moveScriptDown(script)\\\"\\u003E\\u003Ci class=\\\"fa fa-arrow-down\\\"\\u003E\\u003C\\u002Fi\\u003E\\u003C\\u002Fbutton\\u003E\\u003Cbutton class=\\\"btn btn-outline-danger ml-0\\\" (click)=\\\"deleteScript(script)\\\"\\u003E\\u003Ci class=\\\"fa fa-trash-o\\\"\\u003E\\u003C\\u002Fi\\u003E\\u003C\\u002Fbutton\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Ftd\\u003E\\u003C\\u002Ftr\\u003E\\u003Ctr\\u003E\\u003Ctd\\u003E\\u003Cinput class=\\\"form-control\\\" type=\\\"text\\\" placeholder=\\\"Enter a string to expect\\\" [(ngModel)]=\\\"newScript.expect\\\"\\u003E\\u003C\\u002Ftd\\u003E\\u003Ctd\\u003E\\u003Cinput class=\\\"form-control\\\" type=\\\"text\\\" placeholder=\\\"Enter a string to be sent\\\" [(ngModel)]=\\\"newScript.send\\\"\\u003E\\u003C\\u002Ftd\\u003E\\u003Ctd\\u003E\\u003Ctoggle [(ngModel)]=\\\"newScript.isRegex\\\"\\u003E\\u003C\\u002Ftoggle\\u003E\\u003C\\u002Ftd\\u003E\\u003Ctd\\u003E\\u003Ctoggle [(ngModel)]=\\\"newScript.optional\\\"\\u003E\\u003C\\u002Ftoggle\\u003E\\u003C\\u002Ftd\\u003E\\u003Ctd\\u003E\\u003Cdiv class=\\\"input-group flex-nowrap\\\"\\u003E\\u003Cbutton class=\\\"btn btn-outline-info ml-0\\\" (click)=\\\"addScript()\\\"\\u003E\\u003Ci class=\\\"fa fa-check\\\"\\u003E\\u003C\\u002Fi\\u003E\\u003C\\u002Fbutton\\u003E\\u003Cbutton class=\\\"btn btn-outline-danger ml-0\\\" (click)=\\\"clearScript()\\\"\\u003E\\u003Ci class=\\\"fa fa-trash-o\\\"\\u003E\\u003C\\u002Fi\\u003E\\u003C\\u002Fbutton\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Ftd\\u003E\\u003C\\u002Ftr\\u003E\\u003C\\u002Ftable\\u003E\\u003C\\u002Fng-template\\u003E\\u003C\\u002Fngb-tab\\u003E\\u003C\\u002Fngb-tabset\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"modal-footer\\\"\\u003E\\u003Cbutton class=\\\"btn btn-outline-primary\\\" (click)=\\\"save()\\\"\\u003ESave\\u003C\\u002Fbutton\\u003E\\u003Cbutton class=\\\"btn btn-outline-danger\\\" (click)=\\\"cancel()\\\"\\u003ECancel\\u003C\\u002Fbutton\\u003E\\u003C\\u002Fdiv\\u003E\";;return pug_html;};\nmodule.exports = template;\n\nmodule.exports = module.exports.apply(module, [])","var crypto = require('crypto');\nvar Socket = require('net').Socket;\nvar dnsLookup = require('dns').lookup;\nvar EventEmitter = require('events').EventEmitter;\nvar inherits = require('util').inherits;\nvar HASHES = crypto.getHashes();\n\nvar ssh2_streams = require('ssh2-streams');\nvar SSH2Stream = ssh2_streams.SSH2Stream;\nvar SFTPStream = ssh2_streams.SFTPStream;\nvar consts = ssh2_streams.constants;\nvar BUGS = consts.BUGS;\nvar ALGORITHMS = consts.ALGORITHMS;\nvar parseKey = ssh2_streams.utils.parseKey;\nvar decryptKey = ssh2_streams.utils.decryptKey;\nvar genPublicKey = ssh2_streams.utils.genPublicKey;\n\nvar Channel = require('./Channel');\nvar agentQuery = require('./agent');\nvar SFTPWrapper = require('./SFTPWrapper');\n\nvar MAX_CHANNEL = Math.pow(2, 32) - 1;\nvar RE_OPENSSH = /^OpenSSH_(?:(?![0-4])\\d)|(?:\\d{2,})/;\nvar DEBUG_NOOP = function(msg) {};\n\nfunction Client() {\n  if (!(this instanceof Client))\n    return new Client();\n\n  EventEmitter.call(this);\n\n  this.config = {\n    host: undefined,\n    port: undefined,\n    forceIPv4: undefined,\n    forceIPv6: undefined,\n    keepaliveCountMax: undefined,\n    keepaliveInterval: undefined,\n    readyTimeout: undefined,\n\n    username: undefined,\n    password: undefined,\n    privateKey: undefined,\n    publicKey: undefined,\n    tryKeyboard: undefined,\n    agent: undefined,\n    allowAgentFwd: undefined,\n\n    hostHashAlgo: undefined,\n    hostHashCb: undefined,\n    strictVendor: undefined,\n    debug: undefined\n  };\n\n  this._readyTimeout = undefined;\n  this._channels = undefined;\n  this._callbacks = undefined;\n  this._forwarding = undefined;\n  this._forwardingUnix = undefined;\n  this._acceptX11 = undefined;\n  this._agentFwdEnabled = undefined;\n  this._curChan = undefined;\n  this._remoteVer = undefined;\n\n  this._sshstream = undefined;\n  this._sock = undefined;\n  this._resetKA = undefined;\n}\ninherits(Client, EventEmitter);\n\nClient.prototype.connect = function(cfg) {\n  var self = this;\n\n  if (this._sock && this._sock.writable) {\n    this.once('close', function() {\n      self.connect(cfg);\n    });\n    this.end();\n    return;\n  }\n\n  this.config.host = cfg.hostname || cfg.host || 'localhost';\n  this.config.port = cfg.port || 22;\n  this.config.forceIPv4 = cfg.forceIPv4 || false;\n  this.config.forceIPv6 = cfg.forceIPv6 || false;\n  this.config.keepaliveCountMax = (typeof cfg.keepaliveCountMax === 'number'\n                                   && cfg.keepaliveCountMax >= 0\n                                   ? cfg.keepaliveCountMax\n                                   : 3);\n  this.config.keepaliveInterval = (typeof cfg.keepaliveInterval === 'number'\n                                   && cfg.keepaliveInterval > 0\n                                   ? cfg.keepaliveInterval\n                                   : 0);\n  this.config.readyTimeout = (typeof cfg.readyTimeout === 'number'\n                              && cfg.readyTimeout >= 0\n                              ? cfg.readyTimeout\n                              : 20000);\n\n  var algorithms = {\n    kex: undefined,\n    kexBuf: undefined,\n    cipher: undefined,\n    cipherBuf: undefined,\n    serverHostKey: undefined,\n    serverHostKeyBuf: undefined,\n    hmac: undefined,\n    hmacBuf: undefined,\n    compress: undefined,\n    compressBuf: undefined\n  };\n  var i;\n  if (typeof cfg.algorithms === 'object' && cfg.algorithms !== null) {\n    var algosSupported;\n    var algoList;\n\n    algoList = cfg.algorithms.kex;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_KEX;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1)\n          throw new Error('Unsupported key exchange algorithm: ' + algoList[i]);\n      }\n      algorithms.kex = algoList;\n    }\n\n    algoList = cfg.algorithms.cipher;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_CIPHER;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1)\n          throw new Error('Unsupported cipher algorithm: ' + algoList[i]);\n      }\n      algorithms.cipher = algoList;\n    }\n\n    algoList = cfg.algorithms.serverHostKey;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_SERVER_HOST_KEY;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1) {\n          throw new Error('Unsupported server host key algorithm: '\n                           + algoList[i]);\n        }\n      }\n      algorithms.serverHostKey = algoList;\n    }\n\n    algoList = cfg.algorithms.hmac;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_HMAC;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1)\n          throw new Error('Unsupported HMAC algorithm: ' + algoList[i]);\n      }\n      algorithms.hmac = algoList;\n    }\n\n    algoList = cfg.algorithms.compress;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_COMPRESS;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1)\n          throw new Error('Unsupported compression algorithm: ' + algoList[i]);\n      }\n      algorithms.compress = algoList;\n    }\n  }\n  if (algorithms.compress === undefined) {\n    if (cfg.compress) {\n      algorithms.compress = ['zlib@openssh.com', 'zlib'];\n      if (cfg.compress !== 'force')\n        algorithms.compress.push('none');\n    } else if (cfg.compress === false)\n      algorithms.compress = ['none'];\n  }\n\n  if (typeof cfg.username === 'string')\n    this.config.username = cfg.username;\n  else if (typeof cfg.user === 'string')\n    this.config.username = cfg.user;\n  else\n    throw new Error('Invalid username');\n\n  this.config.password = (typeof cfg.password === 'string'\n                          ? cfg.password\n                          : undefined);\n  this.config.privateKey = (typeof cfg.privateKey === 'string'\n                            || Buffer.isBuffer(cfg.privateKey)\n                            ? cfg.privateKey\n                            : undefined);\n  this.config.publicKey = undefined;\n  this.config.localHostname = (typeof cfg.localHostname === 'string'\n                               && cfg.localHostname.length\n                               ? cfg.localHostname\n                               : undefined);\n  this.config.localUsername = (typeof cfg.localUsername === 'string'\n                               && cfg.localUsername.length\n                               ? cfg.localUsername\n                               : undefined);\n  this.config.tryKeyboard = (cfg.tryKeyboard === true);\n  this.config.agent = (typeof cfg.agent === 'string' && cfg.agent.length\n                       ? cfg.agent\n                       : undefined);\n  this.config.allowAgentFwd = (cfg.agentForward === true\n                               && this.config.agent !== undefined);\n\n  this.config.strictVendor = (typeof cfg.strictVendor === 'boolean'\n                              ? cfg.strictVendor\n                              : true);\n\n  var debug = this.config.debug = (typeof cfg.debug === 'function'\n                                   ? cfg.debug\n                                   : DEBUG_NOOP);\n\n  if (cfg.agentForward === true && !this.config.allowAgentFwd)\n    throw new Error('You must set a valid agent path to allow agent forwarding');\n\n  var callbacks = this._callbacks = [];\n  this._channels = {};\n  this._forwarding = {};\n  this._forwardingUnix = {};\n  this._acceptX11 = 0;\n  this._agentFwdEnabled = false;\n  this._curChan = -1;\n  this._remoteVer = undefined;\n\n  if (this.config.privateKey) {\n    var privKeyInfo = parseKey(this.config.privateKey);\n    if (privKeyInfo instanceof Error)\n      throw new Error('Cannot parse privateKey: ' + privKeyInfo.message);\n    if (!privKeyInfo.private)\n      throw new Error('privateKey value does not contain a (valid) private key');\n    if (privKeyInfo.encryption) {\n      if (typeof cfg.passphrase !== 'string')\n        throw new Error('Encrypted private key detected, but no passphrase given');\n      decryptKey(privKeyInfo, cfg.passphrase);\n    }\n    this.config.privateKey = privKeyInfo;\n    this.config.publicKey = genPublicKey(privKeyInfo);\n  }\n\n  var stream = this._sshstream = new SSH2Stream({\n    algorithms: algorithms,\n    debug: (debug === DEBUG_NOOP ? undefined : debug)\n  });\n  var sock = this._sock = (cfg.sock || new Socket());\n\n  // drain stderr if we are connection hopping using an exec stream\n  if (this._sock.stderr)\n    this._sock.stderr.resume();\n\n  // keepalive-related\n  var kainterval = this.config.keepaliveInterval;\n  var kacountmax = this.config.keepaliveCountMax;\n  var kacount = 0;\n  var katimer;\n  function sendKA() {\n    if (++kacount > kacountmax) {\n      clearInterval(katimer);\n      if (sock.readable) {\n        var err = new Error('Keepalive timeout');\n        err.level = 'client-timeout';\n        self.emit('error', err);\n        sock.destroy();\n      }\n      return;\n    }\n    if (sock.writable) {\n      // append dummy callback to keep correct callback order\n      callbacks.push(resetKA);\n      stream.ping();\n    } else\n      clearInterval(katimer);\n  }\n  function resetKA() {\n    if (kainterval > 0) {\n      kacount = 0;\n      clearInterval(katimer);\n      if (sock.writable)\n        katimer = setInterval(sendKA, kainterval);\n    }\n  }\n  this._resetKA = resetKA;\n\n  stream.on('USERAUTH_BANNER', function(msg) {\n    self.emit('banner', msg);\n  });\n\n  sock.on('connect', function() {\n    debug('DEBUG: Client: Connected');\n    self.emit('connect');\n    if (!cfg.sock)\n      stream.pipe(sock).pipe(stream);\n  }).on('timeout', function() {\n    self.emit('timeout');\n  }).on('error', function(err) {\n    clearTimeout(self._readyTimeout);\n    err.level = 'client-socket';\n    self.emit('error', err);\n  }).on('end', function() {\n    stream.unpipe(sock);\n    clearTimeout(self._readyTimeout);\n    clearInterval(katimer);\n    self.emit('end');\n  }).on('close', function() {\n    stream.unpipe(sock);\n    clearTimeout(self._readyTimeout);\n    clearInterval(katimer);\n    self.emit('close');\n\n    // notify outstanding channel requests of disconnection ...\n    var callbacks_ = callbacks;\n    var err = new Error('No response from server');\n    callbacks = self._callbacks = [];\n    for (i = 0; i < callbacks_.length; ++i)\n      callbacks_[i](err);\n\n    // simulate error for any channels waiting to be opened. this is safe\n    // against successfully opened channels because the success and failure\n    // event handlers are automatically removed when a success/failure response\n    // is received\n    var chanNos = Object.keys(self._channels);\n    self._channels = {};\n    for (i = 0; i < chanNos.length; ++i) {\n      stream.emit('CHANNEL_OPEN_FAILURE:' + chanNos[i], err);\n      // emitting CHANNEL_CLOSE should be safe too and should help for any\n      // special channels which might otherwise keep the process alive, such\n      // as agent forwarding channels which have open unix sockets ...\n      stream.emit('CHANNEL_CLOSE:' + chanNos[i]);\n    }\n  });\n  stream.on('drain', function() {\n    self.emit('drain');\n  }).once('header', function(header) {\n    self._remoteVer = header.versions.software;\n    if (header.greeting)\n      self.emit('greeting', header.greeting);\n  }).on('continue', function() {\n    self.emit('continue');\n  }).on('error', function(err) {\n    err.level = 'protocol';\n    self.emit('error', err);\n  });\n\n  if (typeof cfg.hostVerifier === 'function') {\n    if (HASHES.indexOf(cfg.hostHash) === -1)\n      throw new Error('Invalid host hash algorithm: ' + cfg.hostHash);\n    var hashCb = cfg.hostVerifier;\n    var hasher = crypto.createHash(cfg.hostHash);\n    stream.once('fingerprint', function(key, verify) {\n      hasher.update(key);\n      var ret = hashCb(hasher.digest('hex'), verify);\n      if (ret !== undefined)\n        verify(ret);\n    });\n  }\n\n  // begin authentication handling =============================================\n  var auths = ['none'];\n  var curAuth;\n  var agentKeys;\n  var agentKeyPos = 0;\n  if (this.config.password !== undefined)\n    auths.push('password');\n  if (this.config.publicKey !== undefined)\n    auths.push('publickey');\n  if (this.config.agent !== undefined)\n    auths.push('agent');\n  if (this.config.tryKeyboard)\n    auths.push('keyboard-interactive');\n  if (this.config.publicKey !== undefined\n      && this.config.localHostname !== undefined\n      && this.config.localUsername !== undefined)\n    auths.push('hostbased');\n  function tryNextAuth() {\n    // TODO: better shutdown\n    if (!auths.length) {\n      stream.removeListener('USERAUTH_FAILURE', onUSERAUTH_FAILURE);\n      stream.removeListener('USERAUTH_PK_OK', onUSERAUTH_PK_OK);\n      var err = new Error('All configured authentication methods failed');\n      err.level = 'client-authentication';\n      self.emit('error', err);\n      if (stream.writable)\n        self.end();\n      return;\n    }\n\n    curAuth = auths.shift();\n    switch (curAuth) {\n      case 'password':\n        stream.authPassword(self.config.username, self.config.password);\n      break;\n      case 'publickey':\n        stream.authPK(self.config.username, self.config.publicKey);\n        stream.once('USERAUTH_PK_OK', onUSERAUTH_PK_OK);\n      break;\n      case 'hostbased':\n        function hostbasedCb(buf, cb) {\n          var algo;\n          switch (self.config.privateKey.fulltype) {\n            case 'ssh-rsa':\n              algo = 'RSA-SHA1';\n              break;\n            case 'ssh-dss':\n              algo = 'DSA-SHA1';\n              break;\n            case 'ecdsa-sha2-nistp256':\n              algo = 'sha256';\n              break;\n            case 'ecdsa-sha2-nistp384':\n              algo = 'sha384';\n              break;\n            case 'ecdsa-sha2-nistp521':\n              algo = 'sha512';\n              break;\n          }\n          var signature = crypto.createSign(algo);\n          signature.update(buf);\n          signature = trySign(signature, self.config.privateKey.privateOrig);\n          if (signature instanceof Error) {\n            signature.message = 'Error while signing data with privateKey: '\n                                + signature.message;\n            signature.level = 'client-authentication';\n            self.emit('error', signature);\n            return tryNextAuth();\n          }\n\n          cb(signature);\n        }\n        stream.authHostbased(self.config.username,\n                             self.config.publicKey,\n                             self.config.localHostname,\n                             self.config.localUsername,\n                             hostbasedCb);\n      break;\n      case 'agent':\n        agentQuery(self.config.agent, function(err, keys) {\n          if (err) {\n            err.level = 'agent';\n            self.emit('error', err);\n            agentKeys = undefined;\n            return tryNextAuth();\n          } else if (keys.length === 0) {\n            debug('DEBUG: Agent: No keys stored in agent');\n            agentKeys = undefined;\n            return tryNextAuth();\n          }\n\n          agentKeys = keys;\n          agentKeyPos = 0;\n\n          stream.authPK(self.config.username, keys[0]);\n          stream.once('USERAUTH_PK_OK', onUSERAUTH_PK_OK);\n        });\n      break;\n      case 'keyboard-interactive':\n        stream.authKeyboard(self.config.username);\n        stream.on('USERAUTH_INFO_REQUEST', onUSERAUTH_INFO_REQUEST);\n      break;\n      case 'none':\n        stream.authNone(self.config.username);\n      break;\n    }\n  }\n  function tryNextAgentKey() {\n    if (curAuth === 'agent') {\n      if (agentKeyPos >= agentKeys.length)\n        return;\n      if (++agentKeyPos >= agentKeys.length) {\n        debug('DEBUG: Agent: No more keys left to try');\n        debug('DEBUG: Client: agent auth failed');\n        agentKeys = undefined;\n        tryNextAuth();\n      } else {\n        debug('DEBUG: Agent: Trying key #' + (agentKeyPos + 1));\n        stream.authPK(self.config.username, agentKeys[agentKeyPos]);\n        stream.once('USERAUTH_PK_OK', onUSERAUTH_PK_OK);\n      }\n    }\n  }\n  function onUSERAUTH_INFO_REQUEST(name, instructions, lang, prompts) {\n    var nprompts = (Array.isArray(prompts) ? prompts.length : 0);\n    if (nprompts === 0) {\n      debug('DEBUG: Client: Sending automatic USERAUTH_INFO_RESPONSE');\n      return stream.authInfoRes();\n    }\n    // we sent a keyboard-interactive user authentication request and now the\n    // server is sending us the prompts we need to present to the user\n    self.emit('keyboard-interactive',\n              name,\n              instructions,\n              lang,\n              prompts,\n              function(answers) {\n                stream.authInfoRes(answers);\n              });\n  }\n  function onUSERAUTH_PK_OK() {\n    if (curAuth === 'agent') {\n      var agentKey = agentKeys[agentKeyPos];\n      var keyLen = agentKey.readUInt32BE(0, true);\n      var pubKeyFullType = agentKey.toString('ascii', 4, 4 + keyLen);\n      var pubKeyType = pubKeyFullType.slice(4);\n      // Check that we support the key type first\n      switch (pubKeyFullType) {\n        case 'ssh-rsa':\n        case 'ssh-dss':\n        case 'ecdsa-sha2-nistp256':\n        case 'ecdsa-sha2-nistp384':\n        case 'ecdsa-sha2-nistp521':\n          break;\n        default:\n          debug('DEBUG: Agent: Skipping unsupported key type: '\n                + pubKeyFullType);\n          return tryNextAgentKey();\n      }\n      stream.authPK(self.config.username, \n                    agentKey,\n                    function(buf, cb) {\n        agentQuery(self.config.agent,\n                   agentKey,\n                   pubKeyType,\n                   buf,\n                   function(err, signed) {\n          if (err) {\n            err.level = 'agent';\n            self.emit('error', err);\n          } else {\n            var sigFullTypeLen = signed.readUInt32BE(0, true);\n            if (4 + sigFullTypeLen + 4 < signed.length) {\n              var sigFullType = signed.toString('ascii', 4, 4 + sigFullTypeLen);\n              if (sigFullType !== pubKeyFullType) {\n                err = new Error('Agent key/signature type mismatch');\n                err.level = 'agent';\n                self.emit('error', err);\n              } else {\n                // skip algoLen + algo + sigLen\n                return cb(signed.slice(4 + sigFullTypeLen + 4));\n              }\n            }\n          }\n\n          tryNextAgentKey();\n        });\n      });\n    } else if (curAuth === 'publickey') {\n      stream.authPK(self.config.username,\n                    self.config.publicKey,\n                    function(buf, cb) {\n        var algo;\n        switch (self.config.privateKey.fulltype) {\n          case 'ssh-rsa':\n            algo = 'RSA-SHA1';\n            break;\n          case 'ssh-dss':\n            algo = 'DSA-SHA1';\n            break;\n          case 'ecdsa-sha2-nistp256':\n            algo = 'sha256';\n            break;\n          case 'ecdsa-sha2-nistp384':\n            algo = 'sha384';\n            break;\n          case 'ecdsa-sha2-nistp521':\n            algo = 'sha512';\n            break;\n        }\n        var signature = crypto.createSign(algo);\n        signature.update(buf);\n        signature = trySign(signature, self.config.privateKey.privateOrig);\n        if (signature instanceof Error) {\n          signature.message = 'Error while signing data with privateKey: '\n                              + signature.message;\n          signature.level = 'client-authentication';\n          self.emit('error', signature);\n          return tryNextAuth();\n        }\n        cb(signature);\n      });\n    }\n  }\n  function onUSERAUTH_FAILURE(authsLeft, partial) {\n    stream.removeListener('USERAUTH_PK_OK', onUSERAUTH_PK_OK);\n    stream.removeListener('USERAUTH_INFO_REQUEST', onUSERAUTH_INFO_REQUEST);\n    if (curAuth === 'agent') {\n      debug('DEBUG: Client: Agent key #' + (agentKeyPos + 1) + ' failed');\n      return tryNextAgentKey();\n    } else\n      debug('DEBUG: Client: ' + curAuth + ' auth failed');\n\n    tryNextAuth();\n  }\n  stream.once('USERAUTH_SUCCESS', function() {\n    auths = undefined;\n    stream.removeListener('USERAUTH_FAILURE', onUSERAUTH_FAILURE);\n    stream.removeListener('USERAUTH_INFO_REQUEST', onUSERAUTH_INFO_REQUEST);\n    /*if (self.config.agent && self._agentKeys)\n      self._agentKeys = undefined;*/\n\n    // start keepalive mechanism\n    resetKA();\n\n    clearTimeout(self._readyTimeout);\n\n    self.emit('ready');\n  }).on('USERAUTH_FAILURE', onUSERAUTH_FAILURE);\n  // end authentication handling ===============================================\n\n  // handle initial handshake completion\n  stream.once('ready', function() {\n    stream.service('ssh-userauth');\n    stream.once('SERVICE_ACCEPT', function(svcName) {\n      if (svcName === 'ssh-userauth')\n        tryNextAuth();\n    });\n  });\n\n  // handle incoming requests from server, typically a forwarded TCP or X11\n  // connection\n  stream.on('CHANNEL_OPEN', function(info) {\n    onCHANNEL_OPEN(self, info);\n  });\n\n  // handle responses for tcpip-forward and other global requests\n  stream.on('REQUEST_SUCCESS', function(data) {\n    if (callbacks.length)\n      callbacks.shift()(false, data);\n  }).on('REQUEST_FAILURE', function() {\n    if (callbacks.length)\n      callbacks.shift()(true);\n  });\n\n  stream.on('GLOBAL_REQUEST', function(name, wantReply, data) {\n    // auto-reject all global requests, this can be especially useful if the\n    // server is sending us dummy keepalive global requests\n    if (wantReply)\n      stream.requestFailure();\n  });\n\n  if (!cfg.sock) {\n    var host = this.config.host;\n    var forceIPv4 = this.config.forceIPv4;\n    var forceIPv6 = this.config.forceIPv6;\n\n    debug('DEBUG: Client: Trying '\n          + host\n          + ' on port '\n          + this.config.port\n          + ' ...');\n\n    function doConnect() {\n      startTimeout();\n      self._sock.connect(self.config.port, host);\n      self._sock.setNoDelay(true);\n      self._sock.setMaxListeners(0);\n      self._sock.setTimeout(typeof cfg.timeout === 'number' ? cfg.timeout : 0);\n    }\n\n    if ((!forceIPv4 && !forceIPv6) || (forceIPv4 && forceIPv6))\n      doConnect();\n    else {\n      dnsLookup(host, (forceIPv4 ? 4 : 6), function(err, address, family) {\n        if (err) {\n          var error = new Error('Error while looking up '\n                                + (forceIPv4 ? 'IPv4' : 'IPv6')\n                                + ' address for host '\n                                + host\n                                + ': ' + err);\n          clearTimeout(self._readyTimeout);\n          error.level = 'client-dns';\n          self.emit('error', error);\n          self.emit('close');\n          return;\n        }\n        host = address;\n        doConnect();\n      });\n    }\n  } else {\n    startTimeout();\n    stream.pipe(sock).pipe(stream);\n  }\n\n  function startTimeout() {\n    if (self.config.readyTimeout > 0) {\n      self._readyTimeout = setTimeout(function() {\n        var err = new Error('Timed out while waiting for handshake');\n        err.level = 'client-timeout';\n        self.emit('error', err);\n        sock.destroy();\n      }, self.config.readyTimeout);\n    }\n  }\n};\n\nClient.prototype.end = function() {\n  if (this._sock\n      && this._sock.writable\n      && this._sshstream\n      && this._sshstream.writable)\n    return this._sshstream.disconnect();\n  return false;\n};\n\nClient.prototype.destroy = function() {\n  this._sock && this._sock.destroy();\n};\n\nClient.prototype.exec = function(cmd, opts, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  var self = this;\n  var extraOpts = { allowHalfOpen: (opts.allowHalfOpen !== false) };\n\n  return openChannel(this, 'session', extraOpts, function(err, chan) {\n    if (err)\n      return cb(err);\n\n    var todo = [];\n\n    function reqCb(err) {\n      if (err) {\n        chan.close();\n        return cb(err);\n      }\n      if (todo.length)\n        todo.shift()();\n    }\n\n    if (self.config.allowAgentFwd === true\n        || (opts\n            && opts.agentForward === true\n            && self.config.agent !== undefined)) {\n      todo.push(function() {\n        reqAgentFwd(chan, reqCb);\n      });\n    }\n\n    if (typeof opts === 'object') {\n      if (typeof opts.env === 'object')\n        reqEnv(chan, opts.env);\n      if (typeof opts.pty === 'object' || opts.pty === true)\n        todo.push(function() { reqPty(chan, opts.pty, reqCb); });\n      if (typeof opts.x11 === 'object'\n          || opts.x11 === 'number'\n          || opts.x11 === true)\n        todo.push(function() { reqX11(chan, opts.x11, reqCb); });\n    }\n\n    todo.push(function() { reqExec(chan, cmd, opts, cb); });\n    todo.shift()();\n  });\n};\n\nClient.prototype.shell = function(wndopts, opts, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  // start an interactive terminal/shell session\n  var self = this;\n\n  if (typeof wndopts === 'function') {\n    cb = wndopts;\n    wndopts = opts = undefined;\n  } else if (typeof opts === 'function') {\n    cb = opts;\n    opts = undefined;\n  }\n  if (wndopts && (wndopts.x11 !== undefined || wndopts.env !== undefined)) {\n    opts = wndopts;\n    wndopts = undefined;\n  }\n\n  return openChannel(this, 'session', function(err, chan) {\n    if (err)\n      return cb(err);\n\n    var todo = [];\n\n    function reqCb(err) {\n      if (err) {\n        chan.close();\n        return cb(err);\n      }\n      if (todo.length)\n        todo.shift()();\n    }\n\n    if (self.config.allowAgentFwd === true\n        || (opts\n            && opts.agentForward === true\n            && self.config.agent !== undefined)) {\n      todo.push(function() {\n        reqAgentFwd(chan, reqCb);\n      });\n    }\n\n    if (wndopts !== false)\n      todo.push(function() { reqPty(chan, wndopts, reqCb); });\n\n    if (typeof opts === 'object') {\n      if (typeof opts.env === 'object')\n        reqEnv(chan, opts.env);\n      if (typeof opts.x11 === 'object'\n          || opts.x11 === 'number'\n          || opts.x11 === true)\n        todo.push(function() { reqX11(chan, opts.x11, reqCb); });\n    }\n\n    todo.push(function() { reqShell(chan, cb); });\n    todo.shift()();\n  });\n};\n\nClient.prototype.subsys = function(name, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n\treturn openChannel(this, 'session', function(err, chan) {\n\t\tif (err)\n\t\t\treturn cb(err);\n\n\t\treqSubsystem(chan, name, function(err, stream) {\n\t\t\tif (err)\n\t\t\t\treturn cb(err);\n\n\t\t\tcb(undefined, stream);\n\t\t});\n\t});\n};\n\nClient.prototype.sftp = function(cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  var self = this;\n\n  // start an SFTP session\n  return openChannel(this, 'session', function(err, chan) {\n    if (err)\n      return cb(err);\n\n    reqSubsystem(chan, 'sftp', function(err, stream) {\n      if (err)\n        return cb(err);\n\n      var serverIdentRaw = self._sshstream._state.incoming.identRaw;\n      var cfg = { debug: self.config.debug };\n      var sftp = new SFTPStream(cfg, serverIdentRaw);\n\n      function onError(err) {\n        sftp.removeListener('ready', onReady);\n        stream.removeListener('exit', onExit);\n        cb(err);\n      }\n\n      function onReady() {\n        sftp.removeListener('error', onError);\n        stream.removeListener('exit', onExit);\n        cb(undefined, new SFTPWrapper(sftp));\n      }\n\n      function onExit(code, signal) {\n        sftp.removeListener('ready', onReady);\n        sftp.removeListener('error', onError);\n        var msg;\n        if (typeof code === 'number') {\n          msg = 'Received exit code '\n                + code\n                + ' while establishing SFTP session';\n        } else {\n          msg = 'Received signal '\n                + signal\n                + ' while establishing SFTP session';\n        }\n        var err = new Error(msg);\n        err.code = code;\n        err.signal = signal;\n        cb(err);\n      }\n\n      sftp.once('error', onError)\n          .once('ready', onReady)\n          .once('close', function() {\n            stream.end();\n          });\n\n      // OpenSSH server sends an exit-status if there was a problem spinning up\n      // an sftp server child process, so we listen for that here in order to\n      // properly raise an error.\n      stream.once('exit', onExit);\n\n      sftp.pipe(stream).pipe(sftp);\n    });\n  });\n};\n\nClient.prototype.forwardIn = function(bindAddr, bindPort, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  // send a request for the server to start forwarding TCP connections to us\n  // on a particular address and port\n\n  var self = this;\n  var wantReply = (typeof cb === 'function');\n\n  if (wantReply) {\n    this._callbacks.push(function(had_err, data) {\n      if (had_err) {\n        return cb(had_err !== true\n                  ? had_err\n                  : new Error('Unable to bind to ' + bindAddr + ':' + bindPort));\n      }\n\n      var realPort = bindPort;\n      if (bindPort === 0 && data && data.length >= 4) {\n        realPort = data.readUInt32BE(0, true);\n        if (!(self._sshstream.remoteBugs & BUGS.DYN_RPORT_BUG))\n          bindPort = realPort;\n      }\n\n      self._forwarding[bindAddr + ':' + bindPort] = realPort;\n\n      cb(undefined, realPort);\n    });\n  }\n\n  return this._sshstream.tcpipForward(bindAddr, bindPort, wantReply);\n};\n\nClient.prototype.unforwardIn = function(bindAddr, bindPort, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  // send a request to stop forwarding us new connections for a particular\n  // address and port\n\n  var self = this;\n  var wantReply = (typeof cb === 'function');\n\n  if (wantReply) {\n    this._callbacks.push(function(had_err) {\n      if (had_err) {\n        return cb(had_err !== true\n                  ? had_err\n                  : new Error('Unable to unbind from '\n                              + bindAddr + ':' + bindPort));\n      }\n\n      delete self._forwarding[bindAddr + ':' + bindPort];\n\n      cb();\n    });\n  }\n\n  return this._sshstream.cancelTcpipForward(bindAddr, bindPort, wantReply);\n};\n\nClient.prototype.forwardOut = function(srcIP, srcPort, dstIP, dstPort, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  // send a request to forward a TCP connection to the server\n\n  var cfg = {\n    srcIP: srcIP,\n    srcPort: srcPort,\n    dstIP: dstIP,\n    dstPort: dstPort\n  };\n\n  return openChannel(this, 'direct-tcpip', cfg, cb);\n};\n\nClient.prototype.openssh_noMoreSessions = function(cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  var wantReply = (typeof cb === 'function');\n\n  if (!this.config.strictVendor\n      || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {\n    if (wantReply) {\n      this._callbacks.push(function(had_err) {\n        if (had_err) {\n          return cb(had_err !== true\n                    ? had_err\n                    : new Error('Unable to disable future sessions'));\n        }\n\n        cb();\n      });\n    }\n\n    return this._sshstream.openssh_noMoreSessions(wantReply);\n  } else if (wantReply) {\n    process.nextTick(function() {\n      cb(new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    });\n  }\n\n  return true;\n};\n\nClient.prototype.openssh_forwardInStreamLocal = function(socketPath, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  var wantReply = (typeof cb === 'function');\n  var self = this;\n\n  if (!this.config.strictVendor\n      || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {\n    if (wantReply) {\n      this._callbacks.push(function(had_err) {\n        if (had_err) {\n          return cb(had_err !== true\n                    ? had_err\n                    : new Error('Unable to bind to ' + socketPath));\n        }\n        self._forwardingUnix[socketPath] = true;\n        cb();\n      });\n    }\n\n    return this._sshstream.openssh_streamLocalForward(socketPath, wantReply);\n  } else if (wantReply) {\n    process.nextTick(function() {\n      cb(new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    });\n  }\n\n  return true;\n};\n\nClient.prototype.openssh_unforwardInStreamLocal = function(socketPath, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  var wantReply = (typeof cb === 'function');\n  var self = this;\n\n  if (!this.config.strictVendor\n      || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {\n    if (wantReply) {\n      this._callbacks.push(function(had_err) {\n        if (had_err) {\n          return cb(had_err !== true\n                    ? had_err\n                    : new Error('Unable to unbind on ' + socketPath));\n        }\n        delete self._forwardingUnix[socketPath];\n        cb();\n      });\n    }\n\n    return this._sshstream.openssh_cancelStreamLocalForward(socketPath,\n                                                            wantReply);\n  } else if (wantReply) {\n    process.nextTick(function() {\n      cb(new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    });\n  }\n\n  return true;\n};\n\nClient.prototype.openssh_forwardOutStreamLocal = function(socketPath, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  if (!this.config.strictVendor\n      || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {\n    var cfg = { socketPath: socketPath };\n    return openChannel(this, 'direct-streamlocal@openssh.com', cfg, cb);\n  } else {\n    process.nextTick(function() {\n      cb(new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    });\n  }\n\n  return true;\n};\n\nfunction openChannel(self, type, opts, cb) {\n  // ask the server to open a channel for some purpose\n  // (e.g. session (sftp, exec, shell), or forwarding a TCP connection\n  var localChan = nextChannel(self);\n  var initWindow = Channel.MAX_WINDOW;\n  var maxPacket = Channel.PACKET_SIZE;\n  var ret = true;\n\n  if (localChan === false)\n    return cb(new Error('No free channels available'));\n\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  self._channels[localChan] = true;\n\n  var sshstream = self._sshstream;\n  sshstream.once('CHANNEL_OPEN_CONFIRMATION:' + localChan, onSuccess)\n           .once('CHANNEL_OPEN_FAILURE:' + localChan, onFailure)\n           .once('CHANNEL_CLOSE:' + localChan, onFailure);\n\n  if (type === 'session')\n    ret = sshstream.session(localChan, initWindow, maxPacket);\n  else if (type === 'direct-tcpip')\n    ret = sshstream.directTcpip(localChan, initWindow, maxPacket, opts);\n  else if (type === 'direct-streamlocal@openssh.com') {\n    ret = sshstream.openssh_directStreamLocal(localChan,\n                                              initWindow,\n                                              maxPacket,\n                                              opts);\n  }\n\n  return ret;\n\n  function onSuccess(info) {\n    sshstream.removeListener('CHANNEL_OPEN_FAILURE:' + localChan, onFailure);\n    sshstream.removeListener('CHANNEL_CLOSE:' + localChan, onFailure);\n\n    var chaninfo = {\n      type: type,\n      incoming: {\n        id: localChan,\n        window: initWindow,\n        packetSize: maxPacket,\n        state: 'open'\n      },\n      outgoing: {\n        id: info.sender,\n        window: info.window,\n        packetSize: info.packetSize,\n        state: 'open'\n      }\n    };\n    cb(undefined, new Channel(chaninfo, self));\n  }\n\n  function onFailure(info) {\n    sshstream.removeListener('CHANNEL_OPEN_CONFIRMATION:' + localChan,\n                             onSuccess);\n    sshstream.removeListener('CHANNEL_OPEN_FAILURE:' + localChan, onFailure);\n    sshstream.removeListener('CHANNEL_CLOSE:' + localChan, onFailure);\n\n    delete self._channels[localChan];\n\n    var err;\n    if (info instanceof Error)\n      err = info;\n    else if (typeof info === 'object' && info !== null) {\n      err = new Error('(SSH) Channel open failure: ' + info.description);\n      err.reason = info.reason;\n      err.lang = info.lang;\n    } else {\n      err = new Error('(SSH) Channel open failure: '\n                      + 'server closed channel unexpectedly');\n      err.reason = err.lang = '';\n    }\n    cb(err);\n  }\n}\n\nfunction nextChannel(self) {\n  // get the next available channel number\n\n  // optimized path\n  if (self._curChan < MAX_CHANNEL)\n    return ++self._curChan;\n\n  // slower lookup path\n  for (var i = 0, channels = self._channels; i < MAX_CHANNEL; ++i)\n    if (!channels[i])\n      return i;\n\n  return false;\n}\n\nfunction reqX11(chan, screen, cb) {\n  // asks server to start sending us X11 connections\n  var cfg = {\n    single: false,\n    protocol: 'MIT-MAGIC-COOKIE-1',\n    cookie: crypto.randomBytes(16).toString('hex'),\n    screen: (typeof screen === 'number' ? screen : 0)\n  };\n\n  if (typeof screen === 'function')\n    cb = screen;\n  else if (typeof screen === 'object') {\n    if (typeof screen.single === 'boolean')\n      cfg.single = screen.single;\n    if (typeof screen.screen === 'number')\n      cfg.screen = screen.screen;\n  }\n\n  var wantReply = (typeof cb === 'function');\n\n  if (chan.outgoing.state !== 'open') {\n    wantReply && cb(new Error('Channel is not open'));\n    return true;\n  }\n\n  if (wantReply) {\n    chan._callbacks.push(function(had_err) {\n      if (had_err) {\n        return cb(had_err !== true\n                  ? had_err\n                  : new Error('Unable to request X11'));\n      }\n\n      chan._hasX11 = true;\n      ++chan._client._acceptX11;\n      chan.once('close', function() {\n        if (chan._client._acceptX11)\n          --chan._client._acceptX11;\n      });\n\n      cb();\n    });\n  }\n\n  return chan._client._sshstream.x11Forward(chan.outgoing.id, cfg, wantReply);\n}\n\nfunction reqPty(chan, opts, cb) {\n  var rows = 24;\n  var cols = 80;\n  var width = 640;\n  var height = 480;\n  var term = 'vt100';\n\n  if (typeof opts === 'function')\n    cb = opts;\n  else if (typeof opts === 'object') {\n    if (typeof opts.rows === 'number')\n      rows = opts.rows;\n    if (typeof opts.cols === 'number')\n      cols = opts.cols;\n    if (typeof opts.width === 'number')\n      width = opts.width;\n    if (typeof opts.height === 'number')\n      height = opts.height;\n    if (typeof opts.term === 'string')\n      term = opts.term;\n  }\n\n  var wantReply = (typeof cb === 'function');\n\n  if (chan.outgoing.state !== 'open') {\n    wantReply && cb(new Error('Channel is not open'));\n    return true;\n  }\n\n  if (wantReply) {\n    chan._callbacks.push(function(had_err) {\n      if (had_err) {\n        return cb(had_err !== true\n                  ? had_err\n                  : new Error('Unable to request a pseudo-terminal'));\n      }\n      cb();\n    });\n  }\n\n  return chan._client._sshstream.pty(chan.outgoing.id,\n                                     rows,\n                                     cols,\n                                     height,\n                                     width,\n                                     term,\n                                     null,\n                                     wantReply);\n}\n\nfunction reqAgentFwd(chan, cb) {\n  var wantReply = (typeof cb === 'function');\n\n  if (chan.outgoing.state !== 'open') {\n    wantReply && cb(new Error('Channel is not open'));\n    return true;\n  } else if (chan._client._agentFwdEnabled) {\n    wantReply && cb(false);\n    return true;\n  }\n\n  chan._client._agentFwdEnabled = true;\n\n  chan._callbacks.push(function(had_err) {\n    if (had_err) {\n      chan._client._agentFwdEnabled = false;\n      wantReply && cb(had_err !== true\n                      ? had_err\n                      : new Error('Unable to request agent forwarding'));\n      return;\n    }\n\n    wantReply && cb();\n  });\n\n  return chan._client._sshstream.openssh_agentForward(chan.outgoing.id, true);\n}\n\nfunction reqShell(chan, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return true;\n  }\n  chan._callbacks.push(function(had_err) {\n    if (had_err) {\n      return cb(had_err !== true\n                ? had_err\n                : new Error('Unable to open shell'));\n    }\n    chan.subtype = 'shell';\n    cb(undefined, chan);\n  });\n\n  return chan._client._sshstream.shell(chan.outgoing.id, true);\n}\n\nfunction reqExec(chan, cmd, opts, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return true;\n  }\n  chan._callbacks.push(function(had_err) {\n    if (had_err) {\n      return cb(had_err !== true\n                ? had_err\n                : new Error('Unable to exec'));\n    }\n    chan.subtype = 'exec';\n    chan.allowHalfOpen = (opts.allowHalfOpen !== false);\n    cb(undefined, chan);\n  });\n\n  return chan._client._sshstream.exec(chan.outgoing.id, cmd, true);\n}\n\nfunction reqEnv(chan, env) {\n  if (chan.outgoing.state !== 'open')\n    return true;\n  var ret = true;\n  var keys = Object.keys(env || {});\n  var key;\n  var val;\n\n  for (var i = 0, len = keys.length; i < len; ++i) {\n    key = keys[i];\n    val = env[key];\n    ret = chan._client._sshstream.env(chan.outgoing.id, key, val, false);\n  }\n\n  return ret;\n}\n\nfunction reqSubsystem(chan, name, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return true;\n  }\n  chan._callbacks.push(function(had_err) {\n    if (had_err) {\n      return cb(had_err !== true\n                ? had_err\n                : new Error('Unable to start subsystem: ' + name));\n    }\n    chan.subtype = 'subsystem';\n    cb(undefined, chan);\n  });\n\n  return chan._client._sshstream.subsystem(chan.outgoing.id, name, true);\n}\n\nfunction onCHANNEL_OPEN(self, info) {\n  // the server is trying to open a channel with us, this is usually when\n  // we asked the server to forward us connections on some port and now they\n  // are asking us to accept/deny an incoming connection on their side\n\n  var localChan = false;\n  var reason;\n\n  function accept() {\n    var chaninfo = {\n      type: info.type,\n      incoming: {\n        id: localChan,\n        window: Channel.MAX_WINDOW,\n        packetSize: Channel.PACKET_SIZE,\n        state: 'open'\n      },\n      outgoing: {\n        id: info.sender,\n        window: info.window,\n        packetSize: info.packetSize,\n        state: 'open'\n      }\n    };\n    var stream = new Channel(chaninfo, self);\n\n    self._sshstream.channelOpenConfirm(info.sender,\n                                       localChan,\n                                       Channel.MAX_WINDOW,\n                                       Channel.PACKET_SIZE);\n    return stream;\n  }\n  function reject() {\n    if (reason === undefined) {\n      if (localChan === false)\n        reason = consts.CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;\n      else\n        reason = consts.CHANNEL_OPEN_FAILURE.CONNECT_FAILED;\n    }\n\n    self._sshstream.channelOpenFail(info.sender, reason, '', '');\n  }\n\n  if (info.type === 'forwarded-tcpip'\n      || info.type === 'x11'\n      || info.type === 'auth-agent@openssh.com'\n      || info.type === 'forwarded-streamlocal@openssh.com') {\n\n    // check for conditions for automatic rejection\n    var rejectConn = (\n     (info.type === 'forwarded-tcpip'\n      && self._forwarding[info.data.destIP\n                         + ':'\n                         + info.data.destPort] === undefined)\n     || (info.type === 'forwarded-streamlocal@openssh.com'\n         && self._forwardingUnix[info.data.socketPath] === undefined)\n     || (info.type === 'x11' && self._acceptX11 === 0)\n     || (info.type === 'auth-agent@openssh.com'\n         && !self._agentFwdEnabled)\n    );\n\n    if (!rejectConn) {\n      localChan = nextChannel(self);\n\n      if (localChan === false) {\n        self.config.debug('DEBUG: Client: Automatic rejection of incoming channel open: no channels available');\n        rejectConn = true;\n      } else\n        self._channels[localChan] = true;\n    } else {\n      reason = consts.CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n      self.config.debug('DEBUG: Client: Automatic rejection of incoming channel open: unexpected channel open for: '\n                        + info.type);\n    }\n\n    // TODO: automatic rejection after some timeout?\n\n    if (rejectConn)\n      reject();\n\n    if (localChan !== false) {\n      if (info.type === 'forwarded-tcpip') {\n        if (info.data.destPort === 0) {\n          info.data.destPort = self._forwarding[info.data.destIP\n                                                + ':'\n                                                + info.data.destPort];\n        }\n        self.emit('tcp connection', info.data, accept, reject);\n      } else if (info.type === 'x11') {\n        self.emit('x11', info.data, accept, reject);\n      } else if (info.type === 'forwarded-streamlocal@openssh.com') {\n        self.emit('unix connection', info.data, accept, reject);\n      } else {\n        agentQuery(self.config.agent, accept, reject);\n      }\n    }\n  } else {\n    // automatically reject any unsupported channel open requests\n    self.config.debug('DEBUG: Client: Automatic rejection of incoming channel open: unsupported type: '\n                      + info.type);\n    reason = consts.CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;\n    reject();\n  }\n}\n\nfunction trySign(sig, key) {\n  try {\n    return sig.sign(key);\n  } catch (err) {\n    return err;\n  }\n}\n\nClient.Client = Client;\nClient.Server = require('./server');\n// pass some useful utilities on to end user (e.g. parseKey(), genPublicKey())\nClient.utils = ssh2_streams.utils;\n// expose useful SFTPStream constants for sftp server usage\nClient.SFTP_STATUS_CODE = SFTPStream.STATUS_CODE;\nClient.SFTP_OPEN_MODE = SFTPStream.OPEN_MODE;\n\nmodule.exports = Client; // backwards compatibility\n","module.exports = require(\"dns\");","// TODO: support EXTENDED request packets\n\nvar TransformStream = require('stream').Transform;\nvar ReadableStream = require('stream').Readable;\nvar WritableStream = require('stream').Writable;\nvar constants = require('fs').constants || process.binding('constants');\nvar util = require('util');\nvar inherits = util.inherits;\nvar isDate = util.isDate;\nvar listenerCount = require('events').EventEmitter.listenerCount;\nvar fs = require('fs');\n\nvar readString = require('./utils').readString;\nvar readInt = require('./utils').readInt;\n\nvar ATTR = {\n  SIZE: 0x00000001,\n  UIDGID: 0x00000002,\n  PERMISSIONS: 0x00000004,\n  ACMODTIME: 0x00000008,\n  EXTENDED: 0x80000000\n};\n\nvar STATUS_CODE = {\n  OK: 0,\n  EOF: 1,\n  NO_SUCH_FILE: 2,\n  PERMISSION_DENIED: 3,\n  FAILURE: 4,\n  BAD_MESSAGE: 5,\n  NO_CONNECTION: 6,\n  CONNECTION_LOST: 7,\n  OP_UNSUPPORTED: 8\n};\nObject.keys(STATUS_CODE).forEach(function(key) {\n  STATUS_CODE[STATUS_CODE[key]] = key;\n});\nvar STATUS_CODE_STR = {\n  0: 'No error',\n  1: 'End of file',\n  2: 'No such file or directory',\n  3: 'Permission denied',\n  4: 'Failure',\n  5: 'Bad message',\n  6: 'No connection',\n  7: 'Connection lost',\n  8: 'Operation unsupported'\n};\nSFTPStream.STATUS_CODE = STATUS_CODE;\n\nvar REQUEST = {\n  INIT: 1,\n  OPEN: 3,\n  CLOSE: 4,\n  READ: 5,\n  WRITE: 6,\n  LSTAT: 7,\n  FSTAT: 8,\n  SETSTAT: 9,\n  FSETSTAT: 10,\n  OPENDIR: 11,\n  READDIR: 12,\n  REMOVE: 13,\n  MKDIR: 14,\n  RMDIR: 15,\n  REALPATH: 16,\n  STAT: 17,\n  RENAME: 18,\n  READLINK: 19,\n  SYMLINK: 20,\n  EXTENDED: 200\n};\nObject.keys(REQUEST).forEach(function(key) {\n  REQUEST[REQUEST[key]] = key;\n});\n\nvar RESPONSE = {\n  VERSION: 2,\n  STATUS: 101,\n  HANDLE: 102,\n  DATA: 103,\n  NAME: 104,\n  ATTRS: 105,\n  EXTENDED: 201\n};\nObject.keys(RESPONSE).forEach(function(key) {\n  RESPONSE[RESPONSE[key]] = key;\n});\n\nvar OPEN_MODE = {\n  READ: 0x00000001,\n  WRITE: 0x00000002,\n  APPEND: 0x00000004,\n  CREAT: 0x00000008,\n  TRUNC: 0x00000010,\n  EXCL: 0x00000020\n};\nSFTPStream.OPEN_MODE = OPEN_MODE;\n\nvar MAX_PKT_LEN = 34000;\nvar MAX_REQID = Math.pow(2, 32) - 1;\nvar CLIENT_VERSION_BUFFER = new Buffer([0, 0, 0, 5 /* length */,\n                                        REQUEST.INIT,\n                                        0, 0, 0, 3 /* version */]);\nvar SERVER_VERSION_BUFFER = new Buffer([0, 0, 0, 5 /* length */,\n                                        RESPONSE.VERSION,\n                                        0, 0, 0, 3 /* version */]);\n/*\n  http://tools.ietf.org/html/draft-ietf-secsh-filexfer-02:\n\n     The maximum size of a packet is in practice determined by the client\n     (the maximum size of read or write requests that it sends, plus a few\n     bytes of packet overhead).  All servers SHOULD support packets of at\n     least 34000 bytes (where the packet size refers to the full length,\n     including the header above).  This should allow for reads and writes\n     of at most 32768 bytes.\n\n  OpenSSH caps this to 256kb instead of the ~34kb as mentioned in the sftpv3\n  spec.\n*/\nvar RE_OPENSSH = /^SSH-2.0-(?:OpenSSH|dropbear)/;\nvar OPENSSH_MAX_DATA_LEN = (256 * 1024) - (2 * 1024)/*account for header data*/;\n\nfunction DEBUG_NOOP(msg) {}\n\nfunction SFTPStream(cfg, remoteIdentRaw) {\n  if (typeof cfg === 'string' && !remoteIdentRaw) {\n    remoteIdentRaw = cfg;\n    cfg = undefined;\n  }\n  if (typeof cfg !== 'object' || !cfg)\n    cfg = {};\n\n  TransformStream.call(this, {\n    highWaterMark: (typeof cfg.highWaterMark === 'number'\n                    ? cfg.highWaterMark\n                    : 32 * 1024)\n  });\n\n  this.debug = (typeof cfg.debug === 'function' ? cfg.debug : DEBUG_NOOP);\n  this.server = (cfg.server ? true : false);\n  this._isOpenSSH = (remoteIdentRaw && RE_OPENSSH.test(remoteIdentRaw));\n  this._needContinue = false;\n  this._state = {\n    // common\n    status: 'packet_header',\n    writeReqid: -1,\n    pktLeft: undefined,\n    pktHdrBuf: new Buffer(9), // room for pktLen + pktType + req id\n    pktBuf: undefined,\n    pktType: undefined,\n    version: undefined,\n    extensions: {},\n\n    // client\n    maxDataLen: (this._isOpenSSH ? OPENSSH_MAX_DATA_LEN : 32768),\n    requests: {}\n  };\n\n  var self = this;\n  this.on('end', function() {\n    self.readable = false;\n  }).on('finish', onFinish)\n    .on('prefinish', onFinish);\n  function onFinish() {\n    self.writable = false;\n    self._cleanup(false);\n  }\n\n  if (!this.server)\n    this.push(CLIENT_VERSION_BUFFER);\n}\ninherits(SFTPStream, TransformStream);\n\nSFTPStream.prototype.__read = TransformStream.prototype._read;\nSFTPStream.prototype._read = function(n) {\n  if (this._needContinue) {\n    this._needContinue = false;\n    this.emit('continue');\n  }\n  return this.__read(n);\n};\nSFTPStream.prototype.__push = TransformStream.prototype.push;\nSFTPStream.prototype.push = function(chunk, encoding) {\n  if (!this.readable)\n    return false;\n  if (chunk === null)\n    this.readable = false;\n  var ret = this.__push(chunk, encoding);\n  this._needContinue = (ret === false);\n  return ret;\n};\n\nSFTPStream.prototype._cleanup = function(callback) {\n  var state = this._state;\n\n  state.pktBuf = undefined; // give GC something to do\n\n  var requests = state.requests;\n  var keys = Object.keys(requests);\n  var len = keys.length;\n  if (len) {\n    if (this.readable) {\n      var err = new Error('SFTP session ended early');\n      for (var i = 0, cb; i < len; ++i)\n        (cb = requests[keys[i]].cb) && cb(err);\n    }\n    state.requests = {};\n  }\n\n  if (this.readable)\n    this.push(null);\n  if (!this._readableState.endEmitted && !this._readableState.flowing) {\n    // Ugh!\n    this.resume();\n  }\n  if (callback !== false) {\n    this.debug('DEBUG[SFTP]: Parser: Malformed packet');\n    callback && callback(new Error('Malformed packet'));\n  }\n};\n\nSFTPStream.prototype._transform = function(chunk, encoding, callback) {\n  var state = this._state;\n  var server = this.server;\n  var status = state.status;\n  var pktType = state.pktType;\n  var pktBuf = state.pktBuf;\n  var pktLeft = state.pktLeft;\n  var version = state.version;\n  var pktHdrBuf = state.pktHdrBuf;\n  var requests = state.requests;\n  var debug = this.debug;\n  var chunkLen = chunk.length;\n  var chunkPos = 0;\n  var buffer;\n  var chunkLeft;\n  var id;\n\n  while (true) {\n    if (status === 'discard') {\n      chunkLeft = (chunkLen - chunkPos);\n      if (pktLeft <= chunkLeft) {\n        chunkPos += pktLeft;\n        pktLeft = 0;\n        status = 'packet_header';\n        buffer = pktBuf = undefined;\n      } else {\n        pktLeft -= chunkLeft;\n        break;\n      }\n    } else if (pktBuf !== undefined) {\n      chunkLeft = (chunkLen - chunkPos);\n      if (pktLeft <= chunkLeft) {\n        chunk.copy(pktBuf,\n                   pktBuf.length - pktLeft,\n                   chunkPos,\n                   chunkPos + pktLeft);\n        chunkPos += pktLeft;\n        pktLeft = 0;\n        buffer = pktBuf;\n        pktBuf = undefined;\n        continue;\n      } else {\n        chunk.copy(pktBuf, pktBuf.length - pktLeft, chunkPos);\n        pktLeft -= chunkLeft;\n        break;\n      }\n    } else if (status === 'packet_header') {\n      if (!buffer) {\n        pktLeft = 5;\n        pktBuf = pktHdrBuf;\n      } else {\n        // here we read the right-most 5 bytes from buffer (pktHdrBuf)\n        pktLeft = buffer.readUInt32BE(4, true) - 1; // account for type byte\n        pktType = buffer[8];\n\n        if (server) {\n          if (version === undefined && pktType !== REQUEST.INIT) {\n            debug('DEBUG[SFTP]: Parser: Unexpected packet before init');\n            this._cleanup(false);\n            return callback(new Error('Unexpected packet before init'));\n          } else if (version !== undefined && pktType === REQUEST.INIT) {\n            debug('DEBUG[SFTP]: Parser: Unexpected duplicate init');\n            status = 'bad_pkt';\n          } else if (pktLeft > MAX_PKT_LEN) {\n            var msg = 'Packet length ('\n                      + pktLeft\n                      + ') exceeds max length ('\n                      + MAX_PKT_LEN\n                      + ')';\n            debug('DEBUG[SFTP]: Parser: ' + msg);\n            this._cleanup(false);\n            return callback(new Error(msg));\n          } else if (pktType === REQUEST.EXTENDED) {\n            status = 'bad_pkt';\n          } else if (REQUEST[pktType] === undefined) {\n            debug('DEBUG[SFTP]: Parser: Unsupported packet type: ' + pktType);\n            status = 'discard';\n          }\n        } else if (version === undefined && pktType !== RESPONSE.VERSION) {\n          debug('DEBUG[SFTP]: Parser: Unexpected packet before version');\n          this._cleanup(false);\n          return callback(new Error('Unexpected packet before version'));\n        } else if (version !== undefined && pktType === RESPONSE.VERSION) {\n          debug('DEBUG[SFTP]: Parser: Unexpected duplicate version');\n          status = 'bad_pkt';\n        } else if (RESPONSE[pktType] === undefined) {\n          status = 'discard';\n        }\n\n        if (status === 'bad_pkt') {\n          // copy original packet info\n          pktHdrBuf.writeUInt32BE(pktLeft, 0, true);\n          pktHdrBuf[4] = pktType;\n\n          pktLeft = 4;\n          pktBuf = pktHdrBuf;\n        } else {\n          pktBuf = new Buffer(pktLeft);\n          status = 'payload';\n        }\n      }\n    } else if (status === 'payload') {\n      if (pktType === RESPONSE.VERSION || pktType === REQUEST.INIT) {\n        /*\n          uint32 version\n          <extension data>\n        */\n        version = state.version = readInt(buffer, 0, this, callback);\n        if (version === false)\n          return;\n        if (version < 3) {\n          this._cleanup(false);\n          return callback(new Error('Incompatible SFTP version: ' + version));\n        } else if (server)\n          this.push(SERVER_VERSION_BUFFER);\n\n        var buflen = buffer.length;\n        var extname;\n        var extdata;\n        buffer._pos = 4;\n        while (buffer._pos < buflen) {\n          extname = readString(buffer, buffer._pos, 'ascii', this, callback);\n          if (extname === false)\n            return;\n          extdata = readString(buffer, buffer._pos, 'ascii', this, callback);\n          if (extdata === false)\n            return;\n          if (state.extensions[extname])\n            state.extensions[extname].push(extdata);\n          else\n            state.extensions[extname] = [ extdata ];\n        }\n\n        this.emit('ready');\n      } else {\n        /*\n          All other packets (client and server) begin with a (client) request\n          id:\n          uint32     id\n        */\n        id = readInt(buffer, 0, this, callback);\n        if (id === false)\n          return;\n\n        var filename;\n        var attrs;\n        var handle;\n        var data;\n\n        if (!server) {\n          var req = requests[id];\n          var cb = req && req.cb;\n          debug('DEBUG[SFTP]: Parser: Response: ' + RESPONSE[pktType]);\n          if (req && cb) {\n            if (pktType === RESPONSE.STATUS) {\n              /*\n                uint32     error/status code\n                string     error message (ISO-10646 UTF-8)\n                string     language tag\n              */\n              var code = readInt(buffer, 4, this, callback);\n              if (code === false)\n                return;\n              if (code === STATUS_CODE.OK) {\n                cb();\n              } else {\n                // We borrow OpenSSH behavior here, specifically we make the\n                // message and language fields optional, despite the\n                // specification requiring them (even if they are empty). This\n                // helps to avoid problems with buggy implementations that do\n                // not fully conform to the SFTP(v3) specification.\n                var msg;\n                var lang = '';\n                if (buffer.length >= 12) {\n                  msg = readString(buffer, 8, 'utf8', this, callback);\n                  if (msg === false)\n                    return;\n                  if ((buffer._pos + 4) < buffer.length) {\n                    lang = readString(buffer,\n                                      buffer._pos,\n                                      'ascii',\n                                      this,\n                                      callback);\n                    if (lang === false)\n                      return;\n                  }\n                }\n                var err = new Error(msg\n                                    || STATUS_CODE_STR[code]\n                                    || 'Unknown status');\n                err.code = code;\n                err.lang = lang;\n                cb(err);\n              }\n            } else if (pktType === RESPONSE.HANDLE) {\n              /*\n                string     handle\n              */\n              handle = readString(buffer, 4, this, callback);\n              if (handle === false)\n                return;\n              cb(undefined, handle);\n            } else if (pktType === RESPONSE.DATA) {\n              /*\n                string     data\n              */\n              if (req.buffer) {\n                // we have already pre-allocated space to store the data\n                var dataLen = readInt(buffer, 4, this, callback);\n                if (dataLen === false)\n                  return;\n                var reqBufLen = req.buffer.length;\n                if (dataLen > reqBufLen) {\n                  // truncate response data to fit expected size\n                  buffer.writeUInt32BE(reqBufLen, 4, true);\n                }\n                data = readString(buffer, 4, req.buffer, this, callback);\n                if (data === false)\n                  return;\n                cb(undefined, data, dataLen);\n              } else {\n                data = readString(buffer, 4, this, callback);\n                if (data === false)\n                  return;\n                cb(undefined, data);\n              }\n            } else if (pktType === RESPONSE.NAME) {\n              /*\n                uint32     count\n                repeats count times:\n                        string     filename\n                        string     longname\n                        ATTRS      attrs\n              */\n              var namesLen = readInt(buffer, 4, this, callback);\n              if (namesLen === false)\n                return;\n              var names = [],\n                  longname;\n              buffer._pos = 8;\n              for (var i = 0; i < namesLen; ++i) {\n                // we are going to assume UTF-8 for filenames despite the SFTPv3\n                // spec not specifying an encoding because the specs for newer\n                // versions of the protocol all explicitly specify UTF-8 for\n                // filenames\n                filename = readString(buffer,\n                                      buffer._pos,\n                                      'utf8',\n                                      this,\n                                      callback);\n                if (filename === false)\n                  return;\n                // `longname` only exists in SFTPv3 and since it typically will\n                // contain the filename, we assume it is also UTF-8\n                longname = readString(buffer,\n                                      buffer._pos,\n                                      'utf8',\n                                      this,\n                                      callback);\n                if (longname === false)\n                  return;\n                attrs = readAttrs(buffer, buffer._pos, this, callback);\n                if (attrs === false)\n                  return;\n                names.push({\n                  filename: filename,\n                  longname: longname,\n                  attrs: attrs\n                });\n              }\n              cb(undefined, names);\n            } else if (pktType === RESPONSE.ATTRS) {\n              /*\n                ATTRS      attrs\n              */\n              attrs = readAttrs(buffer, 4, this, callback);\n              if (attrs === false)\n                return;\n              cb(undefined, attrs);\n            } else if (pktType === RESPONSE.EXTENDED) {\n              if (req.extended) {\n                switch (req.extended) {\n                  case 'statvfs@openssh.com':\n                  case 'fstatvfs@openssh.com':\n                    /*\n                      uint64    f_bsize   // file system block size\n                      uint64    f_frsize  // fundamental fs block size\n                      uint64    f_blocks  // number of blocks (unit f_frsize)\n                      uint64    f_bfree   // free blocks in file system\n                      uint64    f_bavail  // free blocks for non-root\n                      uint64    f_files   // total file inodes\n                      uint64    f_ffree   // free file inodes\n                      uint64    f_favail  // free file inodes for to non-root\n                      uint64    f_fsid    // file system id\n                      uint64    f_flag    // bit mask of f_flag values\n                      uint64    f_namemax // maximum filename length\n                    */\n                    var stats = {\n                      f_bsize: undefined,\n                      f_frsize: undefined,\n                      f_blocks: undefined,\n                      f_bfree: undefined,\n                      f_bavail: undefined,\n                      f_files: undefined,\n                      f_ffree: undefined,\n                      f_favail: undefined,\n                      f_sid: undefined,\n                      f_flag: undefined,\n                      f_namemax: undefined\n                    };\n                    stats.f_bsize = readUInt64BE(buffer, 4, this, callback);\n                    if (stats.f_bsize === false)\n                      return;\n                    stats.f_frsize = readUInt64BE(buffer, 12, this, callback);\n                    if (stats.f_frsize === false)\n                      return;\n                    stats.f_blocks = readUInt64BE(buffer, 20, this, callback);\n                    if (stats.f_blocks === false)\n                      return;\n                    stats.f_bfree = readUInt64BE(buffer, 28, this, callback);\n                    if (stats.f_bfree === false)\n                      return;\n                    stats.f_bavail = readUInt64BE(buffer, 36, this, callback);\n                    if (stats.f_bavail === false)\n                      return;\n                    stats.f_files = readUInt64BE(buffer, 44, this, callback);\n                    if (stats.f_files === false)\n                      return;\n                    stats.f_ffree = readUInt64BE(buffer, 52, this, callback);\n                    if (stats.f_ffree === false)\n                      return;\n                    stats.f_favail = readUInt64BE(buffer, 60, this, callback);\n                    if (stats.f_favail === false)\n                      return;\n                    stats.f_sid = readUInt64BE(buffer, 68, this, callback);\n                    if (stats.f_sid === false)\n                      return;\n                    stats.f_flag = readUInt64BE(buffer, 76, this, callback);\n                    if (stats.f_flag === false)\n                      return;\n                    stats.f_namemax = readUInt64BE(buffer, 84, this, callback);\n                    if (stats.f_namemax === false)\n                      return;\n                    cb(undefined, stats);\n                  break;\n                }\n              }\n              // XXX: at least provide the raw buffer data to the callback in\n              // case of unexpected extended response?\n              cb();\n            }\n          }\n          if (req)\n            delete requests[id];\n        } else {\n          // server\n          var evName = REQUEST[pktType];\n          var offset;\n          var path;\n\n          debug('DEBUG[SFTP]: Parser: Request: ' + evName);\n          if (listenerCount(this, evName)) {\n            if (pktType === REQUEST.OPEN) {\n              /*\n                string        filename\n                uint32        pflags\n                ATTRS         attrs\n              */\n              filename = readString(buffer, 4, 'utf8', this, callback);\n              if (filename === false)\n                return;\n              var pflags = readInt(buffer, buffer._pos, this, callback);\n              if (pflags === false)\n                return;\n              attrs = readAttrs(buffer, buffer._pos + 4, this, callback);\n              if (attrs === false)\n                return;\n              this.emit(evName, id, filename, pflags, attrs);\n            } else if (pktType === REQUEST.CLOSE\n                       || pktType === REQUEST.FSTAT\n                       || pktType === REQUEST.READDIR) {\n              /*\n                string     handle\n              */\n              handle = readString(buffer, 4, this, callback);\n              if (handle === false)\n                return;\n              this.emit(evName, id, handle);\n            } else if (pktType === REQUEST.READ) {\n              /*\n                string     handle\n                uint64     offset\n                uint32     len\n              */\n              handle = readString(buffer, 4, this, callback);\n              if (handle === false)\n                return;\n              offset = readUInt64BE(buffer, buffer._pos, this, callback);\n              if (offset === false)\n                return;\n              var len = readInt(buffer, buffer._pos, this, callback);\n              if (len === false)\n                return;\n              this.emit(evName, id, handle, offset, len);\n            } else if (pktType === REQUEST.WRITE) {\n              /*\n                string     handle\n                uint64     offset\n                string     data\n              */\n              handle = readString(buffer, 4, this, callback);\n              if (handle === false)\n                return;\n              offset = readUInt64BE(buffer, buffer._pos, this, callback);\n              if (offset === false)\n                return;\n              data = readString(buffer, buffer._pos, this, callback);\n              if (data === false)\n                return;\n              this.emit(evName, id, handle, offset, data);\n            } else if (pktType === REQUEST.LSTAT\n                       || pktType === REQUEST.STAT\n                       || pktType === REQUEST.OPENDIR\n                       || pktType === REQUEST.REMOVE\n                       || pktType === REQUEST.RMDIR\n                       || pktType === REQUEST.REALPATH\n                       || pktType === REQUEST.READLINK) {\n              /*\n                string     path\n              */\n              path = readString(buffer, 4, 'utf8', this, callback);\n              if (path === false)\n                return;\n              this.emit(evName, id, path);\n            } else if (pktType === REQUEST.SETSTAT\n                       || pktType === REQUEST.MKDIR) {\n              /*\n                string     path\n                ATTRS      attrs\n              */\n              path = readString(buffer, 4, 'utf8', this, callback);\n              if (path === false)\n                return;\n              attrs = readAttrs(buffer, buffer._pos, this, callback);\n              if (attrs === false)\n                return;\n              this.emit(evName, id, path, attrs);\n            } else if (pktType === REQUEST.FSETSTAT) {\n              /*\n                string     handle\n                ATTRS      attrs\n              */\n              handle = readString(buffer, 4, this, callback);\n              if (handle === false)\n                return;\n              attrs = readAttrs(buffer, buffer._pos, this, callback);\n              if (attrs === false)\n                return;\n              this.emit(evName, id, handle, attrs);\n            } else if (pktType === REQUEST.RENAME\n                       || pktType === REQUEST.SYMLINK) {\n              /*\n                RENAME:\n                  string     oldpath\n                  string     newpath\n                SYMLINK:\n                  string     linkpath\n                  string     targetpath\n              */\n              var str1;\n              var str2;\n              str1 = readString(buffer, 4, 'utf8', this, callback);\n              if (str1 === false)\n                return;\n              str2 = readString(buffer, buffer._pos, 'utf8', this, callback);\n              if (str2 === false)\n                return;\n              if (pktType === REQUEST.SYMLINK && this._isOpenSSH) {\n                // OpenSSH has linkpath and targetpath positions switched\n                this.emit(evName, id, str2, str1);\n              } else\n                this.emit(evName, id, str1, str2);\n            }\n          } else {\n            // automatically reject request if no handler for request type\n            this.status(id, STATUS_CODE.OP_UNSUPPORTED);\n          }\n        }\n      }\n\n      // prepare for next packet\n      status = 'packet_header';\n      buffer = pktBuf = undefined;\n    } else if (status === 'bad_pkt') {\n      if (server && buffer[4] !== REQUEST.INIT) {\n        var errCode = (buffer[4] === REQUEST.EXTENDED\n                       ? STATUS_CODE.OP_UNSUPPORTED\n                       : STATUS_CODE.FAILURE);\n\n        // no request id for init/version packets, so we have no way to send a\n        // status response, so we just close up shop ...\n        if (buffer[4] === REQUEST.INIT || buffer[4] === RESPONSE.VERSION)\n          return this._cleanup(callback);\n\n        id = readInt(buffer, 5, this, callback);\n        if (id === false)\n          return;\n        this.status(id, errCode);\n      }\n\n      // by this point we have already read the type byte and the id bytes, so\n      // we subtract those from the number of bytes to skip\n      pktLeft = buffer.readUInt32BE(0, true) - 5;\n\n      status = 'discard';\n    }\n\n    if (chunkPos >= chunkLen)\n      break;\n  }\n\n  state.status = status;\n  state.pktType = pktType;\n  state.pktBuf = pktBuf;\n  state.pktLeft = pktLeft;\n  state.version = version;\n\n  callback();\n};\n\n// client\nSFTPStream.prototype.createReadStream = function(path, options) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  return new ReadStream(this, path, options);\n};\nSFTPStream.prototype.createWriteStream = function(path, options) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  return new WriteStream(this, path, options);\n};\nSFTPStream.prototype.open = function(path, flags_, attrs, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  if (typeof attrs === 'function') {\n    cb = attrs;\n    attrs = undefined;\n  }\n\n  var flags = stringToFlags(flags_);\n  if (flags === null)\n    throw new Error('Unknown flags string: ' + flags_);\n\n  var attrFlags = 0;\n  var attrBytes = 0;\n  if (typeof attrs === 'string' || typeof attrs === 'number') {\n    attrs = { mode: attrs };\n  }\n  if (typeof attrs === 'object') {\n    attrs = attrsToBytes(attrs);\n    attrFlags = attrs.flags;\n    attrBytes = attrs.nbytes;\n    attrs = attrs.bytes;\n  }\n\n  /*\n    uint32        id\n    string        filename\n    uint32        pflags\n    ATTRS         attrs\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen + 4 + 4 + attrBytes);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.OPEN;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(pathlen, p, true);\n  buf.write(path, p += 4, pathlen, 'utf8');\n  buf.writeUInt32BE(flags, p += pathlen, true);\n  buf.writeUInt32BE(attrFlags, p += 4, true);\n  if (attrs && attrFlags) {\n    p += 4;\n    for (var i = 0, len = attrs.length; i < len; ++i)\n      for (var j = 0, len2 = attrs[i].length; j < len2; ++j)\n        buf[p++] = attrs[i][j];\n  }\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing OPEN');\n  return this.push(buf);\n};\nSFTPStream.prototype.close = function(handle, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     handle\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + handlelen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.CLOSE;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(handlelen, p, true);\n  handle.copy(buf, p += 4);\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing CLOSE');\n  return this.push(buf);\n};\nSFTPStream.prototype.readData = function(handle, buf, off, len, position, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n  else if (!Buffer.isBuffer(buf))\n    throw new Error('buffer is not a Buffer');\n  else if (off >= buf.length)\n    throw new Error('offset is out of bounds');\n  else if (off + len > buf.length)\n    throw new Error('length extends beyond buffer');\n  else if (position === null)\n    throw new Error('null position currently unsupported');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     handle\n    uint64     offset\n    uint32     len\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var pos = position;\n  var out = new Buffer(4 + 1 + 4 + 4 + handlelen + 8 + 4);\n\n  out.writeUInt32BE(out.length - 4, 0, true);\n  out[4] = REQUEST.READ;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  out.writeUInt32BE(reqid, 5, true);\n\n  out.writeUInt32BE(handlelen, p, true);\n  handle.copy(out, p += 4);\n  p += handlelen;\n  for (var i = 7; i >= 0; --i) {\n    out[p + i] = pos & 0xFF;\n    pos /= 256;\n  }\n  out.writeUInt32BE(len, p += 8, true);\n\n  state.requests[reqid] = {\n    cb: function(err, data, nb) {\n      if (err && err.code !== STATUS_CODE.EOF)\n        return cb(err);\n      cb(undefined, nb || 0, data, position);\n    },\n    buffer: buf.slice(off, off + len)\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing READ');\n  return this.push(out);\n};\nSFTPStream.prototype.writeData = function(handle, buf, off, len, position, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n  else if (!Buffer.isBuffer(buf))\n    throw new Error('buffer is not a Buffer');\n  else if (off > buf.length)\n    throw new Error('offset is out of bounds');\n  else if (off + len > buf.length)\n    throw new Error('length extends beyond buffer');\n  else if (position === null)\n    throw new Error('null position currently unsupported');\n\n  var self = this;\n  var state = this._state;\n\n  if (!len) {\n    cb && process.nextTick(function() { cb(undefined, 0); });\n    return;\n  }\n\n  var overflow = (len > state.maxDataLen\n                  ? len - state.maxDataLen\n                  : 0);\n  var origPosition = position;\n\n  if (overflow)\n    len = state.maxDataLen;\n\n  /*\n    uint32     id\n    string     handle\n    uint64     offset\n    string     data\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var out = new Buffer(4 + 1 + 4 + 4 + handlelen + 8 + 4 + len);\n\n  out.writeUInt32BE(out.length - 4, 0, true);\n  out[4] = REQUEST.WRITE;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  out.writeUInt32BE(reqid, 5, true);\n\n  out.writeUInt32BE(handlelen, p, true);\n  handle.copy(out, p += 4);\n  p += handlelen;\n  for (var i = 7; i >= 0; --i) {\n    out[p + i] = position & 0xFF;\n    position /= 256;\n  }\n  out.writeUInt32BE(len, p += 8, true);\n  buf.copy(out, p += 4, off, off + len);\n\n  state.requests[reqid] = {\n    cb: function(err) {\n      if (err)\n        cb && cb(err);\n      else if (overflow) {\n        self.writeData(handle,\n                       buf,\n                       off + len,\n                       overflow,\n                       origPosition + len,\n                       cb);\n      } else\n        cb && cb(undefined, off + len);\n    }\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing WRITE');\n  return this.push(out);\n};\nfunction tryCreateBuffer(size) {\n  try {\n    return new Buffer(size);\n  } catch (ex) {\n    return ex;\n  }\n}\nfunction fastXfer(src, dst, srcPath, dstPath, opts, cb) {\n  var concurrency = 64;\n  var chunkSize = 32768;\n  //var preserve = false;\n  var onstep;\n  var mode;\n\n  if (typeof opts === 'function') {\n    cb = opts;\n  } else if (typeof opts === 'object') {\n    if (typeof opts.concurrency === 'number'\n        && opts.concurrency > 0\n        && !isNaN(opts.concurrency))\n      concurrency = opts.concurrency;\n    if (typeof opts.chunkSize === 'number'\n        && opts.chunkSize > 0\n        && !isNaN(opts.chunkSize))\n      chunkSize = opts.chunkSize;\n    if (typeof opts.step === 'function')\n      onstep = opts.step;\n    //preserve = (opts.preserve ? true : false);\n    if (typeof opts.mode === 'string' || typeof opts.mode === 'number')\n      mode = modeNum(opts.mode);\n  }\n\n  // internal state variables\n  var fsize;\n  var chunk;\n  var psrc = 0;\n  var pdst = 0;\n  var reads = 0;\n  var total = 0;\n  var hadError = false;\n  var srcHandle;\n  var dstHandle;\n  var readbuf;\n  var bufsize = chunkSize * concurrency;\n\n  function onerror(err) {\n    if (hadError)\n      return;\n\n    hadError = true;\n\n    var left = 0;\n    var cbfinal;\n\n    if (srcHandle || dstHandle) {\n      cbfinal = function() {\n        if (--left === 0)\n          cb(err);\n      };\n      if (srcHandle && (src === fs || src.writable))\n        ++left;\n      if (dstHandle && (dst === fs || dst.writable))\n        ++left;\n      if (srcHandle && (src === fs || src.writable))\n        src.close(srcHandle, cbfinal);\n      if (dstHandle && (dst === fs || dst.writable))\n        dst.close(dstHandle, cbfinal);\n    } else\n      cb(err);\n  }\n\n  src.open(srcPath, 'r', function(err, sourceHandle) {\n    if (err)\n      return onerror(err);\n\n    srcHandle = sourceHandle;\n\n    src.fstat(srcHandle, function tryStat(err, attrs) {\n      if (err) {\n        if (src !== fs) {\n          // Try stat() for sftp servers that may not support fstat() for\n          // whatever reason\n          src.stat(srcPath, function(err_, attrs_) {\n            if (err_)\n              return onerror(err);\n            tryStat(null, attrs_);\n          });\n          return;\n        }\n        return onerror(err);\n      }\n      fsize = attrs.size;\n\n      dst.open(dstPath, 'w', function(err, destHandle) {\n        if (err)\n          return onerror(err);\n\n        dstHandle = destHandle;\n\n        if (fsize <= 0)\n          return onerror();\n\n        // Use less memory where possible\n        while (bufsize > fsize) {\n          if (concurrency === 1) {\n            bufsize = fsize;\n            break;\n          }\n          bufsize -= chunkSize;\n          --concurrency;\n        }\n\n        readbuf = tryCreateBuffer(bufsize);\n        if (readbuf instanceof Error)\n          return onerror(readbuf);\n\n        if (mode !== undefined) {\n          dst.fchmod(dstHandle, mode, function tryAgain(err) {\n            if (err) {\n              // Try chmod() for sftp servers that may not support fchmod() for\n              // whatever reason\n              dst.chmod(dstPath, mode, function(err_) {\n                tryAgain();\n              });\n              return;\n            }\n            read();\n          });\n        } else {\n          read();\n        }\n\n        function onread(err, nb, data, dstpos, datapos) {\n          if (err)\n            return onerror(err);\n\n          if (src === fs)\n            dst.writeData(dstHandle, data, datapos || 0, nb, dstpos, writeCb);\n          else\n            dst.write(dstHandle, data, datapos || 0, nb, dstpos, writeCb);\n\n          function writeCb(err) {\n            if (err)\n              return onerror(err);\n\n            total += nb;\n            onstep && onstep(total, nb, fsize);\n\n            if (--reads === 0) {\n              if (total === fsize) {\n                dst.close(dstHandle, function(err) {\n                  dstHandle = undefined;\n                  if (err)\n                    return onerror(err);\n                  src.close(srcHandle, function(err) {\n                    srcHandle = undefined;\n                    if (err)\n                      return onerror(err);\n                    cb();\n                  });\n                });\n              } else\n                read();\n            }\n          }\n        }\n\n        function makeCb(psrc, pdst) {\n          return function(err, nb, data) {\n            onread(err, nb, data, pdst, psrc);\n          };\n        }\n\n        function read() {\n          while (pdst < fsize && reads < concurrency) {\n            chunk = (pdst + chunkSize > fsize ? fsize - pdst : chunkSize);\n            if (src === fs) {\n              src.read(srcHandle,\n                       readbuf,\n                       psrc,\n                       chunk,\n                       pdst,\n                       makeCb(psrc, pdst));\n            } else\n              src.readData(srcHandle, readbuf, psrc, chunk, pdst, onread);\n            psrc += chunk;\n            pdst += chunk;\n            ++reads;\n          }\n          psrc = 0;\n        }\n      });\n    });\n  });\n}\nSFTPStream.prototype.fastGet = function(remotePath, localPath, opts, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  fastXfer(this, fs, remotePath, localPath, opts, cb);\n};\nSFTPStream.prototype.fastPut = function(localPath, remotePath, opts, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  fastXfer(fs, this, localPath, remotePath, opts, cb);\n};\nSFTPStream.prototype.readFile = function(path, options, callback_) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var callback;\n  if (typeof callback_ === 'function') {\n    callback = callback_;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  var self = this;\n\n  if (typeof options === 'string')\n    options = { encoding: options, flag: 'r' };\n  else if (!options)\n    options = { encoding: null, flag: 'r' };\n  else if (typeof options !== 'object')\n    throw new TypeError('Bad arguments');\n\n  var encoding = options.encoding;\n  if (encoding && !Buffer.isEncoding(encoding))\n    throw new Error('Unknown encoding: ' + encoding);\n\n  // first, stat the file, so we know the size.\n  var size;\n  var buffer; // single buffer with file data\n  var buffers; // list for when size is unknown\n  var pos = 0;\n  var handle;\n\n  // SFTPv3 does not support using -1 for read position, so we have to track\n  // read position manually\n  var bytesRead = 0;\n\n  var flag = options.flag || 'r';\n  this.open(path, flag, 438 /*=0666*/, function(er, handle_) {\n    if (er)\n      return callback && callback(er);\n    handle = handle_;\n\n    self.fstat(handle, function tryStat(er, st) {\n      if (er) {\n        // Try stat() for sftp servers that may not support fstat() for\n        // whatever reason\n        self.stat(path, function(er_, st_) {\n          if (er_) {\n            return self.close(handle, function() {\n              callback && callback(er);\n            });\n          }\n          tryStat(null, st_);\n        });\n        return;\n      }\n\n      size = st.size || 0;\n      if (size === 0) {\n        // the kernel lies about many files.\n        // Go ahead and try to read some bytes.\n        buffers = [];\n        return read();\n      }\n\n      buffer = new Buffer(size);\n      read();\n    });\n  });\n\n  function read() {\n    if (size === 0) {\n      buffer = new Buffer(8192);\n      self.readData(handle, buffer, 0, 8192, bytesRead, afterRead);\n    } else\n      self.readData(handle, buffer, pos, size - pos, bytesRead, afterRead);\n  }\n\n  function afterRead(er, nbytes) {\n    if (er) {\n      return self.close(handle, function() {\n        return callback && callback(er);\n      });\n    }\n\n    if (nbytes === 0)\n      return close();\n\n    bytesRead += nbytes;\n    pos += nbytes;\n    if (size !== 0) {\n      if (pos === size)\n        close();\n      else\n        read();\n    } else {\n      // unknown size, just read until we don't get bytes.\n      buffers.push(buffer.slice(0, nbytes));\n      read();\n    }\n  }\n\n  function close() {\n    self.close(handle, function(er) {\n      if (size === 0) {\n        // collected the data into the buffers list.\n        buffer = Buffer.concat(buffers, pos);\n      } else if (pos < size)\n        buffer = buffer.slice(0, pos);\n\n      if (encoding)\n        buffer = buffer.toString(encoding);\n      return callback && callback(er, buffer);\n    });\n  }\n};\nfunction writeAll(self, handle, buffer, offset, length, position, callback_) {\n  var callback = (typeof callback_ === 'function' ? callback_ : undefined);\n\n  self.writeData(handle,\n                 buffer,\n                 offset,\n                 length,\n                 position,\n                 function(writeErr, written) {\n    if (writeErr) {\n      return self.close(handle, function() {\n        callback && callback(writeErr);\n      });\n    }\n    if (written === length)\n      self.close(handle, callback);\n    else {\n      offset += written;\n      length -= written;\n      position += written;\n      writeAll(self, handle, buffer, offset, length, position, callback);\n    }\n  });\n}\nSFTPStream.prototype.writeFile = function(path, data, options, callback_) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var callback;\n  if (typeof callback_ === 'function') {\n    callback = callback_;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  var self = this;\n\n  if (typeof options === 'string')\n    options = { encoding: options, mode: 438, flag: 'w' };\n  else if (!options)\n    options = { encoding: 'utf8', mode: 438 /*=0666*/, flag: 'w' };\n  else if (typeof options !== 'object')\n    throw new TypeError('Bad arguments');\n\n  if (options.encoding && !Buffer.isEncoding(options.encoding))\n    throw new Error('Unknown encoding: ' + options.encoding);\n\n  var flag = options.flag || 'w';\n  this.open(path, flag, options.mode, function(openErr, handle) {\n    if (openErr)\n      callback && callback(openErr);\n    else {\n      var buffer = (Buffer.isBuffer(data)\n                    ? data\n                    : new Buffer('' + data, options.encoding || 'utf8'));\n      var position = (/a/.test(flag) ? null : 0);\n\n      // SFTPv3 does not support the notion of 'current position'\n      // (null position), so we just attempt to append to the end of the file\n      // instead\n      if (position === null) {\n        self.fstat(handle, function tryStat(er, st) {\n          if (er) {\n            // Try stat() for sftp servers that may not support fstat() for\n            // whatever reason\n            self.stat(path, function(er_, st_) {\n              if (er_) {\n                return self.close(handle, function() {\n                  callback && callback(er);\n                });\n              }\n              tryStat(null, st_);\n            });\n            return;\n          }\n          writeAll(self, handle, buffer, 0, buffer.length, st.size, callback);\n        });\n        return;\n      }\n      writeAll(self, handle, buffer, 0, buffer.length, position, callback);\n    }\n  });\n};\nSFTPStream.prototype.appendFile = function(path, data, options, callback_) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var callback;\n  if (typeof callback_ === 'function') {\n    callback = callback_;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  if (typeof options === 'string')\n    options = { encoding: options, mode: 438, flag: 'a' };\n  else if (!options)\n    options = { encoding: 'utf8', mode: 438 /*=0666*/, flag: 'a' };\n  else if (typeof options !== 'object')\n    throw new TypeError('Bad arguments');\n\n  if (!options.flag)\n    options = util._extend({ flag: 'a' }, options);\n  this.writeFile(path, data, options, callback);\n};\nSFTPStream.prototype.exists = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  this.stat(path, function(err) {\n    cb && cb(err ? false : true);\n  });\n};\nSFTPStream.prototype.unlink = function(filename, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     filename\n  */\n  var fnamelen = Buffer.byteLength(filename);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + fnamelen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.REMOVE;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(fnamelen, p, true);\n  buf.write(filename, p += 4, fnamelen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing REMOVE');\n  return this.push(buf);\n};\nSFTPStream.prototype.rename = function(oldPath, newPath, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     oldpath\n    string     newpath\n  */\n  var oldlen = Buffer.byteLength(oldPath);\n  var newlen = Buffer.byteLength(newPath);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + oldlen + 4 + newlen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.RENAME;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(oldlen, p, true);\n  buf.write(oldPath, p += 4, oldlen, 'utf8');\n  buf.writeUInt32BE(newlen, p += oldlen, true);\n  buf.write(newPath, p += 4, newlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing RENAME');\n  return this.push(buf);\n};\nSFTPStream.prototype.mkdir = function(path, attrs, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var flags = 0;\n  var attrBytes = 0;\n  var state = this._state;\n\n  if (typeof attrs === 'function') {\n    cb = attrs;\n    attrs = undefined;\n  }\n  if (typeof attrs === 'object') {\n    attrs = attrsToBytes(attrs);\n    flags = attrs.flags;\n    attrBytes = attrs.nbytes;\n    attrs = attrs.bytes;\n  }\n\n  /*\n    uint32     id\n    string     path\n    ATTRS      attrs\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen + 4 + attrBytes);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.MKDIR;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(pathlen, p, true);\n  buf.write(path, p += 4, pathlen, 'utf8');\n  buf.writeUInt32BE(flags, p += pathlen);\n  if (flags) {\n    p += 4;\n    for (var i = 0, len = attrs.length; i < len; ++i)\n      for (var j = 0, len2 = attrs[i].length; j < len2; ++j)\n        buf[p++] = attrs[i][j];\n  }\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing MKDIR');\n  return this.push(buf);\n};\nSFTPStream.prototype.rmdir = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.RMDIR;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(pathlen, p, true);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing RMDIR');\n  return this.push(buf);\n};\nSFTPStream.prototype.readdir = function(where, opts, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n  var doFilter;\n\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof opts !== 'object')\n    opts = {};\n\n  doFilter = (opts && opts.full ? false : true);\n\n  if (!Buffer.isBuffer(where) && typeof where !== 'string')\n    throw new Error('missing directory handle or path');\n\n  if (typeof where === 'string') {\n    var self = this;\n    var entries = [];\n    var e = 0;\n\n    return this.opendir(where, function reread(err, handle) {\n      if (err)\n        return cb(err);\n\n      self.readdir(handle, opts, function(err, list) {\n        var eof = (err && err.code === STATUS_CODE.EOF);\n\n        if (err && !eof) {\n          return self.close(handle, function() {\n            cb(err);\n          });\n        } else if (eof) {\n          return self.close(handle, function(err) {\n            if (err)\n              return cb(err);\n            cb(undefined, entries);\n          });\n        }\n\n        for (var i = 0, len = list.length; i < len; ++i, ++e)\n          entries[e] = list[i];\n\n        reread(undefined, handle);\n      });\n    });\n  }\n\n  /*\n    uint32     id\n    string     handle\n  */\n  var handlelen = where.length;\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + handlelen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.READDIR;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(handlelen, p, true);\n  where.copy(buf, p += 4);\n\n  state.requests[reqid] = {\n    cb: (doFilter\n         ? function(err, list) {\n             if (err)\n               return cb(err);\n\n             for (var i = list.length - 1; i >= 0; --i) {\n               if (list[i].filename === '.' || list[i].filename === '..')\n                 list.splice(i, 1);\n             }\n\n             cb(undefined, list);\n           }\n         : cb)\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing READDIR');\n  return this.push(buf);\n};\nSFTPStream.prototype.fstat = function(handle, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     handle\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + handlelen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.FSTAT;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(handlelen, p, true);\n  handle.copy(buf, p += 4);\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing FSTAT');\n  return this.push(buf);\n};\nSFTPStream.prototype.stat = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.STAT;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(pathlen, p, true);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing STAT');\n  return this.push(buf);\n};\nSFTPStream.prototype.lstat = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.LSTAT;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(pathlen, p, true);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing LSTAT');\n  return this.push(buf);\n};\nSFTPStream.prototype.opendir = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.OPENDIR;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(pathlen, p, true);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing OPENDIR');\n  return this.push(buf);\n};\nSFTPStream.prototype.setstat = function(path, attrs, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var flags = 0;\n  var attrBytes = 0;\n  var state = this._state;\n\n  if (typeof attrs === 'object') {\n    attrs = attrsToBytes(attrs);\n    flags = attrs.flags;\n    attrBytes = attrs.nbytes;\n    attrs = attrs.bytes;\n  } else if (typeof attrs === 'function')\n    cb = attrs;\n\n  /*\n    uint32     id\n    string     path\n    ATTRS      attrs\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen + 4 + attrBytes);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.SETSTAT;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(pathlen, p, true);\n  buf.write(path, p += 4, pathlen, 'utf8');\n  buf.writeUInt32BE(flags, p += pathlen);\n  if (flags) {\n    p += 4;\n    for (var i = 0, len = attrs.length; i < len; ++i)\n      for (var j = 0, len2 = attrs[i].length; j < len2; ++j)\n        buf[p++] = attrs[i][j];\n  }\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing SETSTAT');\n  return this.push(buf);\n};\nSFTPStream.prototype.fsetstat = function(handle, attrs, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n\n  var flags = 0;\n  var attrBytes = 0;\n  var state = this._state;\n\n  if (typeof attrs === 'object') {\n    attrs = attrsToBytes(attrs);\n    flags = attrs.flags;\n    attrBytes = attrs.nbytes;\n    attrs = attrs.bytes;\n  } else if (typeof attrs === 'function')\n    cb = attrs;\n\n  /*\n    uint32     id\n    string     handle\n    ATTRS      attrs\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + handlelen + 4 + attrBytes);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.FSETSTAT;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(handlelen, p, true);\n  handle.copy(buf, p += 4);\n  buf.writeUInt32BE(flags, p += handlelen);\n  if (flags) {\n    p += 4;\n    for (var i = 0, len = attrs.length; i < len; ++i)\n      for (var j = 0, len2 = attrs[i].length; j < len2; ++j)\n        buf[p++] = attrs[i][j];\n  }\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing FSETSTAT');\n  return this.push(buf);\n};\nSFTPStream.prototype.futimes = function(handle, atime, mtime, cb) {\n  return this.fsetstat(handle, {\n    atime: toUnixTimestamp(atime),\n    mtime: toUnixTimestamp(mtime)\n  }, cb);\n};\nSFTPStream.prototype.utimes = function(path, atime, mtime, cb) {\n  return this.setstat(path, {\n    atime: toUnixTimestamp(atime),\n    mtime: toUnixTimestamp(mtime)\n  }, cb);\n};\nSFTPStream.prototype.fchown = function(handle, uid, gid, cb) {\n  return this.fsetstat(handle, {\n    uid: uid,\n    gid: gid\n  }, cb);\n};\nSFTPStream.prototype.chown = function(path, uid, gid, cb) {\n  return this.setstat(path, {\n    uid: uid,\n    gid: gid\n  }, cb);\n};\nSFTPStream.prototype.fchmod = function(handle, mode, cb) {\n  return this.fsetstat(handle, {\n    mode: mode\n  }, cb);\n};\nSFTPStream.prototype.chmod = function(path, mode, cb) {\n  return this.setstat(path, {\n    mode: mode\n  }, cb);\n};\nSFTPStream.prototype.readlink = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.READLINK;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(pathlen, p, true);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = {\n    cb: function(err, names) {\n      if (err)\n        return cb(err);\n      else if (!names || !names.length)\n        return cb(new Error('Response missing link info'));\n      cb(undefined, names[0].filename);\n    }\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing READLINK');\n  return this.push(buf);\n};\nSFTPStream.prototype.symlink = function(targetPath, linkPath, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     linkpath\n    string     targetpath\n  */\n  var linklen = Buffer.byteLength(linkPath);\n  var targetlen = Buffer.byteLength(targetPath);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + linklen + 4 + targetlen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.SYMLINK;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  if (this._isOpenSSH) {\n    // OpenSSH has linkpath and targetpath positions switched\n    buf.writeUInt32BE(targetlen, p, true);\n    buf.write(targetPath, p += 4, targetlen, 'utf8');\n    buf.writeUInt32BE(linklen, p += targetlen, true);\n    buf.write(linkPath, p += 4, linklen, 'utf8');\n  } else {\n    buf.writeUInt32BE(linklen, p, true);\n    buf.write(linkPath, p += 4, linklen, 'utf8');\n    buf.writeUInt32BE(targetlen, p += linklen, true);\n    buf.write(targetPath, p += 4, targetlen, 'utf8');\n  }\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing SYMLINK');\n  return this.push(buf);\n};\nSFTPStream.prototype.realpath = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.REALPATH;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(pathlen, p, true);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = {\n    cb: function(err, names) {\n      if (err)\n        return cb(err);\n      else if (!names || !names.length)\n        return cb(new Error('Response missing path info'));\n      cb(undefined, names[0].filename);\n    }\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing REALPATH');\n  return this.push(buf);\n};\n// extended requests\nSFTPStream.prototype.ext_openssh_rename = function(oldPath, newPath, cb) {\n  var state = this._state;\n\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!state.extensions['posix-rename@openssh.com']\n           || state.extensions['posix-rename@openssh.com'].indexOf('1') === -1)\n    throw new Error('Server does not support this extended request');\n\n  /*\n    uint32    id\n    string    \"posix-rename@openssh.com\"\n    string    oldpath\n    string    newpath\n  */\n  var oldlen = Buffer.byteLength(oldPath);\n  var newlen = Buffer.byteLength(newPath);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + 24 + 4 + oldlen + 4 + newlen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.EXTENDED;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n  buf.writeUInt32BE(24, p, true);\n  buf.write('posix-rename@openssh.com', p += 4, 24, 'ascii');\n\n  buf.writeUInt32BE(oldlen, p += 24, true);\n  buf.write(oldPath, p += 4, oldlen, 'utf8');\n  buf.writeUInt32BE(newlen, p += oldlen, true);\n  buf.write(newPath, p += 4, newlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing posix-rename@openssh.com');\n  return this.push(buf);\n};\nSFTPStream.prototype.ext_openssh_statvfs = function(path, cb) {\n  var state = this._state;\n\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!state.extensions['statvfs@openssh.com']\n           || state.extensions['statvfs@openssh.com'].indexOf('2') === -1)\n    throw new Error('Server does not support this extended request');\n\n  /*\n    uint32    id\n    string    \"statvfs@openssh.com\"\n    string    path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + 19 + 4 + pathlen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.EXTENDED;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n  buf.writeUInt32BE(19, p, true);\n  buf.write('statvfs@openssh.com', p += 4, 19, 'ascii');\n\n  buf.writeUInt32BE(pathlen, p += 19, true);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = {\n    extended: 'statvfs@openssh.com',\n    cb: cb\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing statvfs@openssh.com');\n  return this.push(buf);\n};\nSFTPStream.prototype.ext_openssh_fstatvfs = function(handle, cb) {\n  var state = this._state;\n\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!state.extensions['fstatvfs@openssh.com']\n           || state.extensions['fstatvfs@openssh.com'].indexOf('2') === -1)\n    throw new Error('Server does not support this extended request');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n\n  /*\n    uint32    id\n    string    \"fstatvfs@openssh.com\"\n    string    handle\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + 20 + 4 + handlelen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.EXTENDED;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n  buf.writeUInt32BE(20, p, true);\n  buf.write('fstatvfs@openssh.com', p += 4, 20, 'ascii');\n\n  buf.writeUInt32BE(handlelen, p += 20, true);\n  buf.write(handle, p += 4, handlelen, 'utf8');\n\n  state.requests[reqid] = {\n    extended: 'fstatvfs@openssh.com',\n    cb: cb\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing fstatvfs@openssh.com');\n  return this.push(buf);\n};\nSFTPStream.prototype.ext_openssh_hardlink = function(oldPath, newPath, cb) {\n  var state = this._state;\n\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!state.extensions['hardlink@openssh.com']\n           || state.extensions['hardlink@openssh.com'].indexOf('1') === -1)\n    throw new Error('Server does not support this extended request');\n\n  /*\n    uint32    id\n    string    \"hardlink@openssh.com\"\n    string    oldpath\n    string    newpath\n  */\n  var oldlen = Buffer.byteLength(oldPath);\n  var newlen = Buffer.byteLength(newPath);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + 20 + 4 + oldlen + 4 + newlen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.EXTENDED;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n  buf.writeUInt32BE(20, p, true);\n  buf.write('hardlink@openssh.com', p += 4, 20, 'ascii');\n\n  buf.writeUInt32BE(oldlen, p += 20, true);\n  buf.write(oldPath, p += 4, oldlen, 'utf8');\n  buf.writeUInt32BE(newlen, p += oldlen, true);\n  buf.write(newPath, p += 4, newlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing hardlink@openssh.com');\n  return this.push(buf);\n};\nSFTPStream.prototype.ext_openssh_fsync = function(handle, cb) {\n  var state = this._state;\n\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!state.extensions['fsync@openssh.com']\n           || state.extensions['fsync@openssh.com'].indexOf('1') === -1)\n    throw new Error('Server does not support this extended request');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n\n  /*\n    uint32    id\n    string    \"fsync@openssh.com\"\n    string    handle\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + 17 + 4 + handlelen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.EXTENDED;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n  buf.writeUInt32BE(17, p, true);\n  buf.write('fsync@openssh.com', p += 4, 17, 'ascii');\n\n  buf.writeUInt32BE(handlelen, p += 17, true);\n  buf.write(handle, p += 4, handlelen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing fsync@openssh.com');\n  return this.push(buf);\n};\n\n// server\nSFTPStream.prototype.status = function(id, code, message, lang) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  if (!STATUS_CODE[code] || typeof code !== 'number')\n    throw new Error('Bad status code: ' + code);\n\n  message || (message = '');\n  lang || (lang = '');\n\n  var msgLen = Buffer.byteLength(message);\n  var langLen = Buffer.byteLength(lang);\n  var buf = new Buffer(4 + 1 + 4 + 4 + 4 + msgLen + 4 + langLen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = RESPONSE.STATUS;\n  buf.writeUInt32BE(id, 5, true);\n\n  buf.writeUInt32BE(code, 9, true);\n\n  buf.writeUInt32BE(msgLen, 13, true);\n  if (msgLen)\n    buf.write(message, 17, msgLen, 'utf8');\n\n  buf.writeUInt32BE(langLen, 17 + msgLen, true);\n  if (langLen)\n    buf.write(lang, 17 + msgLen + 4, langLen, 'ascii');\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing STATUS');\n  return this.push(buf);\n};\nSFTPStream.prototype.handle = function(id, handle) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n\n  var handleLen = handle.length;\n\n  if (handleLen > 256)\n    throw new Error('handle too large (> 256 bytes)');\n\n  var buf = new Buffer(4 + 1 + 4 + 4 + handleLen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = RESPONSE.HANDLE;\n  buf.writeUInt32BE(id, 5, true);\n\n  buf.writeUInt32BE(handleLen, 9, true);\n  if (handleLen)\n    handle.copy(buf, 13);\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing HANDLE');\n  return this.push(buf);\n};\nSFTPStream.prototype.data = function(id, data, encoding) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var isBuffer = Buffer.isBuffer(data);\n\n  if (!isBuffer && typeof data !== 'string')\n    throw new Error('data is not a Buffer or string');\n\n  if (!isBuffer)\n    encoding || (encoding = 'utf8');\n\n  var dataLen = (isBuffer ? data.length : Buffer.byteLength(data, encoding));\n  var buf = new Buffer(4 + 1 + 4 + 4 + dataLen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = RESPONSE.DATA;\n  buf.writeUInt32BE(id, 5, true);\n\n  buf.writeUInt32BE(dataLen, 9, true);\n  if (dataLen) {\n    if (isBuffer)\n      data.copy(buf, 13);\n    else\n      buf.write(data, 13, dataLen, encoding);\n  }\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing DATA');\n  return this.push(buf);\n};\nSFTPStream.prototype.name = function(id, names) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  if (!Array.isArray(names) && typeof names === 'object')\n    names = [ names ];\n  else if (!Array.isArray(names))\n    throw new Error('names is not an object or array');\n\n  var count = names.length;\n  var namesLen = 0;\n  var nameAttrs;\n  var attrs = [];\n  var name;\n  var filename;\n  var longname;\n  var attr;\n  var len;\n  var len2;\n  var buf;\n  var p;\n  var i;\n  var j;\n  var k;\n\n  for (i = 0; i < count; ++i) {\n    name = names[i];\n    filename = (!name || !name.filename || typeof name.filename !== 'string'\n                ? ''\n                : name.filename);\n    namesLen += 4 + Buffer.byteLength(filename);\n    longname = (!name || !name.longname || typeof name.longname !== 'string'\n                ? ''\n                : name.longname);\n    namesLen += 4 + Buffer.byteLength(longname);\n\n    if (typeof name.attrs === 'object') {\n      nameAttrs = attrsToBytes(name.attrs);\n      namesLen += 4 + nameAttrs.nbytes;\n      attrs.push(nameAttrs);\n    } else {\n      namesLen += 4;\n      attrs.push(null);\n    }\n  }\n\n  buf = new Buffer(4 + 1 + 4 + 4 + namesLen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = RESPONSE.NAME;\n  buf.writeUInt32BE(id, 5, true);\n\n  buf.writeUInt32BE(count, 9, true);\n\n  p = 13;\n\n  for (i = 0; i < count; ++i) {\n    name = names[i];\n\n    filename = (!name || !name.filename || typeof name.filename !== 'string'\n                ? ''\n                : name.filename);\n    len = Buffer.byteLength(filename);\n    buf.writeUInt32BE(len, p, true);\n    p += 4;\n    if (len) {\n      buf.write(filename, p, len, 'utf8');\n      p += len;\n    }\n\n    longname = (!name || !name.longname || typeof name.longname !== 'string'\n                ? ''\n                : name.longname);\n    len = Buffer.byteLength(longname);\n    buf.writeUInt32BE(len, p, true);\n    p += 4;\n    if (len) {\n      buf.write(longname, p, len, 'utf8');\n      p += len;\n    }\n\n    attr = attrs[i];\n    if (attr) {\n      buf.writeUInt32BE(attr.flags, p, true);\n      p += 4;\n      if (attr.flags && attr.bytes) {\n        var bytes = attr.bytes;\n        for (j = 0, len = bytes.length; j < len; ++j)\n          for (k = 0, len2 = bytes[j].length; k < len2; ++k)\n            buf[p++] = bytes[j][k];\n      }\n    } else {\n      buf.writeUInt32BE(0, p, true);\n      p += 4;\n    }\n  }\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing NAME');\n  return this.push(buf);\n};\nSFTPStream.prototype.attrs = function(id, attrs) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  if (typeof attrs !== 'object')\n    throw new Error('attrs is not an object');\n\n  var info = attrsToBytes(attrs);\n  var buf = new Buffer(4 + 1 + 4 + 4 + info.nbytes);\n  var p = 13;\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = RESPONSE.ATTRS;\n  buf.writeUInt32BE(id, 5, true);\n\n  buf.writeUInt32BE(info.flags, 9, true);\n\n  if (info.flags && info.bytes) {\n    var bytes = info.bytes;\n    for (var j = 0, len = bytes.length; j < len; ++j)\n      for (var k = 0, len2 = bytes[j].length; k < len2; ++k)\n        buf[p++] = bytes[j][k];\n  }\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing ATTRS');\n  return this.push(buf);\n};\n\nfunction readAttrs(buf, p, stream, callback) {\n  /*\n    uint32   flags\n    uint64   size           present only if flag SSH_FILEXFER_ATTR_SIZE\n    uint32   uid            present only if flag SSH_FILEXFER_ATTR_UIDGID\n    uint32   gid            present only if flag SSH_FILEXFER_ATTR_UIDGID\n    uint32   permissions    present only if flag SSH_FILEXFER_ATTR_PERMISSIONS\n    uint32   atime          present only if flag SSH_FILEXFER_ACMODTIME\n    uint32   mtime          present only if flag SSH_FILEXFER_ACMODTIME\n    uint32   extended_count present only if flag SSH_FILEXFER_ATTR_EXTENDED\n    string   extended_type\n    string   extended_data\n    ...      more extended data (extended_type - extended_data pairs),\n               so that number of pairs equals extended_count\n  */\n  var flags = buf.readUInt32BE(p, true);\n  var attrs = new Stats();\n\n  p += 4;\n\n  if (flags & ATTR.SIZE) {\n    var size = readUInt64BE(buf, p, stream, callback);\n    if (size === false)\n      return false;\n    attrs.size = size;\n    p += 8;\n  }\n  if (flags & ATTR.UIDGID) {\n    var uid;\n    var gid;\n    uid = readInt(buf, p, this, callback);\n    if (uid === false)\n      return false;\n    attrs.uid = uid;\n    p += 4;\n    gid = readInt(buf, p, this, callback);\n    if (gid === false)\n      return false;\n    attrs.gid = gid;\n    p += 4;\n  }\n  if (flags & ATTR.PERMISSIONS) {\n    var mode = readInt(buf, p, this, callback);\n    if (mode === false)\n      return false;\n    attrs.mode = mode;\n    // backwards compatibility\n    attrs.permissions = mode;\n    p += 4;\n  }\n  if (flags & ATTR.ACMODTIME) {\n    var atime;\n    var mtime;\n    atime = readInt(buf, p, this, callback);\n    if (atime === false)\n      return false;\n    attrs.atime = atime;\n    p += 4;\n    mtime = readInt(buf, p, this, callback);\n    if (mtime === false)\n      return false;\n    attrs.mtime = mtime;\n    p += 4;\n  }\n  if (flags & ATTR.EXTENDED) {\n    // TODO: read/parse extended data\n    var extcount = readInt(buf, p, this, callback);\n    if (extcount === false)\n      return false;\n    p += 4;\n    for (var i = 0, len; i < extcount; ++i) {\n      len = readInt(buf, p, this, callback);\n      if (len === false)\n        return false;\n      p += 4 + len;\n    }\n  }\n\n  buf._pos = p;\n\n  return attrs;\n}\n\nfunction readUInt64BE(buffer, p, stream, callback) {\n  if ((buffer.length - p) < 8) {\n    stream && stream._cleanup(callback);\n    return false;\n  }\n\n  var val = 0;\n\n  for (var len = p + 8; p < len; ++p) {\n    val *= 256;\n    val += buffer[p];\n  }\n\n  buffer._pos = p;\n\n  return val;\n}\n\nfunction attrsToBytes(attrs) {\n  var flags = 0;\n  var attrBytes = 0;\n  var ret = [];\n  var i = 0;\n\n  if (typeof attrs.size === 'number') {\n    flags |= ATTR.SIZE;\n    attrBytes += 8;\n    var sizeBytes = new Array(8);\n    var val = attrs.size;\n    for (i = 7; i >= 0; --i) {\n      sizeBytes[i] = val & 0xFF;\n      val /= 256;\n    }\n    ret.push(sizeBytes);\n  }\n  if (typeof attrs.uid === 'number' && typeof attrs.gid === 'number') {\n    flags |= ATTR.UIDGID;\n    attrBytes += 8;\n    ret.push([(attrs.uid >> 24) & 0xFF, (attrs.uid >> 16) & 0xFF,\n              (attrs.uid >> 8) & 0xFF, attrs.uid & 0xFF]);\n    ret.push([(attrs.gid >> 24) & 0xFF, (attrs.gid >> 16) & 0xFF,\n              (attrs.gid >> 8) & 0xFF, attrs.gid & 0xFF]);\n  }\n  if (typeof attrs.permissions === 'number'\n      || typeof attrs.permissions === 'string'\n      || typeof attrs.mode === 'number'\n      || typeof attrs.mode === 'string') {\n    var mode = modeNum(attrs.mode || attrs.permissions);\n    flags |= ATTR.PERMISSIONS;\n    attrBytes += 4;\n    ret.push([(mode >> 24) & 0xFF,\n              (mode >> 16) & 0xFF,\n              (mode >> 8) & 0xFF,\n              mode & 0xFF]);\n  }\n  if ((typeof attrs.atime === 'number' || isDate(attrs.atime))\n      && (typeof attrs.mtime === 'number' || isDate(attrs.mtime))) {\n    var atime = toUnixTimestamp(attrs.atime);\n    var mtime = toUnixTimestamp(attrs.mtime);\n\n    flags |= ATTR.ACMODTIME;\n    attrBytes += 8;\n    ret.push([(atime >> 24) & 0xFF, (atime >> 16) & 0xFF,\n              (atime >> 8) & 0xFF, atime & 0xFF]);\n    ret.push([(mtime >> 24) & 0xFF, (mtime >> 16) & 0xFF,\n              (mtime >> 8) & 0xFF, mtime & 0xFF]);\n  }\n  // TODO: extended attributes\n\n  return { flags: flags, nbytes: attrBytes, bytes: ret };\n}\n\nfunction toUnixTimestamp(time) {\n  if (typeof time === 'number' && !isNaN(time))\n    return time;\n  else if (isDate(time))\n    return parseInt(time.getTime() / 1000, 10);\n  throw new Error('Cannot parse time: ' + time);\n}\n\nfunction modeNum(mode) {\n  if (typeof mode === 'number' && !isNaN(mode))\n    return mode;\n  else if (typeof mode === 'string')\n    return modeNum(parseInt(mode, 8));\n  throw new Error('Cannot parse mode: ' + mode);\n}\n\nvar stringFlagMap = {\n  'r': OPEN_MODE.READ,\n  'r+': OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'w': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE,\n  'wx': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'xw': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'w+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'wx+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE\n         | OPEN_MODE.EXCL,\n  'xw+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE\n         | OPEN_MODE.EXCL,\n  'a': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE,\n  'ax': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'xa': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'a+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'ax+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE\n         | OPEN_MODE.EXCL,\n  'xa+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE\n         | OPEN_MODE.EXCL\n};\nvar stringFlagMapKeys = Object.keys(stringFlagMap);\n\nfunction stringToFlags(str) {\n  var flags = stringFlagMap[str];\n  if (flags !== undefined)\n    return flags;\n  return null;\n}\nSFTPStream.stringToFlags = stringToFlags;\n\nfunction flagsToString(flags) {\n  for (var i = 0; i < stringFlagMapKeys.length; ++i) {\n    var key = stringFlagMapKeys[i];\n    if (stringFlagMap[key] === flags)\n      return key;\n  }\n  return null;\n}\nSFTPStream.flagsToString = flagsToString;\n\nfunction Stats(initial) {\n  this.mode = (initial && initial.mode);\n  this.permissions = this.mode; // backwards compatiblity\n  this.uid = (initial && initial.uid);\n  this.gid = (initial && initial.gid);\n  this.size = (initial && initial.size);\n  this.atime = (initial && initial.atime);\n  this.mtime = (initial && initial.mtime);\n}\nStats.prototype._checkModeProperty = function(property) {\n  return ((this.mode & constants.S_IFMT) === property);\n};\nStats.prototype.isDirectory = function() {\n  return this._checkModeProperty(constants.S_IFDIR);\n};\nStats.prototype.isFile = function() {\n  return this._checkModeProperty(constants.S_IFREG);\n};\nStats.prototype.isBlockDevice = function() {\n  return this._checkModeProperty(constants.S_IFBLK);\n};\nStats.prototype.isCharacterDevice = function() {\n  return this._checkModeProperty(constants.S_IFCHR);\n};\nStats.prototype.isSymbolicLink = function() {\n  return this._checkModeProperty(constants.S_IFLNK);\n};\nStats.prototype.isFIFO = function() {\n  return this._checkModeProperty(constants.S_IFIFO);\n};\nStats.prototype.isSocket = function() {\n  return this._checkModeProperty(constants.S_IFSOCK);\n};\nSFTPStream.Stats = Stats;\n\n\n// ReadStream-related\nvar kMinPoolSpace = 128;\nvar pool;\nfunction allocNewPool(poolSize) {\n  pool = new Buffer(poolSize);\n  pool.used = 0;\n}\n\nfunction ReadStream(sftp, path, options) {\n  if (!(this instanceof ReadStream))\n    return new ReadStream(sftp, path, options);\n\n  var self = this;\n\n  if (options === undefined)\n    options = {};\n  else if (typeof options === 'string')\n    options = { encoding: options };\n  else if (options === null || typeof options !== 'object')\n    throw new TypeError('\"options\" argument must be a string or an object');\n  else\n    options = Object.create(options);\n\n  // a little bit bigger buffer and water marks by default\n  if (options.highWaterMark === undefined)\n    options.highWaterMark = 64 * 1024;\n\n  ReadableStream.call(this, options);\n\n  this.path = path;\n  this.handle = options.handle === undefined ? null : options.handle;\n  this.flags = options.flags === undefined ? 'r' : options.flags;\n  this.mode = options.mode === undefined ? 438/*0666*/ : options.mode;\n\n  this.start = options.start === undefined ? undefined : options.start;\n  this.end = options.end === undefined ? undefined : options.end;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n  this.pos = 0;\n  this.sftp = sftp;\n\n  if (this.start !== undefined) {\n    if (typeof this.start !== 'number')\n      throw new TypeError('start must be a Number');\n    if (this.end === undefined)\n      this.end = Infinity;\n    else if (typeof this.end !== 'number')\n      throw new TypeError('end must be a Number');\n\n    if (this.start > this.end)\n      throw new Error('start must be <= end');\n    else if (this.start < 0)\n      throw new Error('start must be >= zero');\n\n    this.pos = this.start;\n  }\n\n  this.on('end', function() {\n    if (self.autoClose) {\n      self.destroy();\n    }\n  });\n\n  if (!Buffer.isBuffer(this.handle))\n    this.open();\n}\ninherits(ReadStream, ReadableStream);\n\nReadStream.prototype.open = function() {\n  var self = this;\n  this.sftp.open(this.path, this.flags, this.mode, function(er, handle) {\n    if (er) {\n      self.emit('error', er);\n      this.destroyed = this.closed = true;\n      self.emit('close');\n      return;\n    }\n\n    self.handle = handle;\n    self.emit('open', handle);\n    // start the flow of data.\n    self.read();\n  });\n};\n\nReadStream.prototype._read = function(n) {\n  if (!Buffer.isBuffer(this.handle)) {\n    return this.once('open', function() {\n      this._read(n);\n    });\n  }\n\n  if (this.destroyed)\n    return;\n\n  if (!pool || pool.length - pool.used < kMinPoolSpace) {\n    // discard the old pool.\n    pool = null;\n    allocNewPool(this._readableState.highWaterMark);\n  }\n\n  // Grab another reference to the pool in the case that while we're\n  // in the thread pool another read() finishes up the pool, and\n  // allocates a new one.\n  var thisPool = pool;\n  var toRead = Math.min(pool.length - pool.used, n);\n  var start = pool.used;\n\n  if (this.end !== undefined)\n    toRead = Math.min(this.end - this.pos + 1, toRead);\n\n  // already read everything we were supposed to read!\n  // treat as EOF.\n  if (toRead <= 0)\n    return this.push(null);\n\n  // the actual read.\n  var self = this;\n  this.sftp.readData(this.handle, pool, pool.used, toRead, this.pos, onread);\n\n  // move the pool positions, and internal position for reading.\n  this.pos += toRead;\n  pool.used += toRead;\n\n  function onread(er, bytesRead) {\n    if (er) {\n      if (self.autoClose)\n        self.destroy();\n      self.emit('error', er);\n    } else {\n      var b = null;\n      if (bytesRead > 0)\n        b = thisPool.slice(start, start + bytesRead);\n\n      self.push(b);\n    }\n  }\n};\n\nReadStream.prototype.destroy = function() {\n  if (this.destroyed)\n    return;\n  this.destroyed = true;\n  if (Buffer.isBuffer(this.handle))\n    this.close();\n};\n\n\nReadStream.prototype.close = function(cb) {\n  var self = this;\n  if (cb)\n    this.once('close', cb);\n  if (this.closed || !Buffer.isBuffer(this.handle)) {\n    if (!Buffer.isBuffer(this.handle)) {\n      this.once('open', close);\n      return;\n    }\n    return process.nextTick(this.emit.bind(this, 'close'));\n  }\n  this.closed = true;\n  close();\n\n  function close(handle) {\n    self.sftp.close(handle || self.handle, function(er) {\n      if (er)\n        self.emit('error', er);\n      else\n        self.emit('close');\n    });\n    self.handle = null;\n  }\n};\n\n\nfunction WriteStream(sftp, path, options) {\n  if (!(this instanceof WriteStream))\n    return new WriteStream(sftp, path, options);\n\n  if (options === undefined)\n    options = {};\n  else if (typeof options === 'string')\n    options = { encoding: options };\n  else if (options === null || typeof options !== 'object')\n    throw new TypeError('\"options\" argument must be a string or an object');\n  else\n    options = Object.create(options);\n\n  WritableStream.call(this, options);\n\n  this.path = path;\n  this.handle = options.handle === undefined ? null : options.handle;\n  this.flags = options.flags === undefined ? 'w' : options.flags;\n  this.mode = options.mode === undefined ? 438/*0666*/ : options.mode;\n\n  this.start = options.start === undefined ? undefined : options.start;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n  this.pos = 0;\n  this.bytesWritten = 0;\n  this.sftp = sftp;\n\n  if (this.start !== undefined) {\n    if (typeof this.start !== 'number')\n      throw new TypeError('start must be a Number');\n    if (this.start < 0)\n      throw new Error('start must be >= zero');\n\n    this.pos = this.start;\n  }\n\n  if (options.encoding)\n    this.setDefaultEncoding(options.encoding);\n\n  if (!Buffer.isBuffer(this.handle))\n    this.open();\n\n  // dispose on finish.\n  this.once('finish', function onclose() {\n    if (this.autoClose)\n      this.close();\n  });\n}\ninherits(WriteStream, WritableStream);\n\nWriteStream.prototype.open = function() {\n  var self = this;\n  this.sftp.open(this.path, this.flags, this.mode, function(er, handle) {\n    if (er) {\n      self.emit('error', er);\n      if (self.autoClose) {\n        self.destroyed = self.closed = true;\n        self.emit('close');\n      }\n      return;\n    }\n\n    self.handle = handle;\n\n    self.sftp.fchmod(handle, self.mode, function tryAgain(err) {\n      if (err) {\n        // Try chmod() for sftp servers that may not support fchmod() for\n        // whatever reason\n        self.sftp.chmod(self.path, self.mode, function(err_) {\n          tryAgain();\n        });\n        return;\n      }\n\n      // SFTPv3 requires absolute offsets, no matter the open flag used\n      if (self.flags[0] === 'a') {\n        self.sftp.fstat(handle, function tryStat(err, st) {\n          if (err) {\n            // Try stat() for sftp servers that may not support fstat() for\n            // whatever reason\n            self.sftp.stat(self.path, function(err_, st_) {\n              if (err_) {\n                self.destroy();\n                self.emit('error', err);\n                return;\n              }\n              tryStat(null, st_);\n            });\n            return;\n          }\n\n          self.pos = st.size;\n          self.emit('open', handle);\n        });\n        return;\n      }\n      self.emit('open', handle);\n    });\n  });\n};\n\nWriteStream.prototype._write = function(data, encoding, cb) {\n  if (!Buffer.isBuffer(data))\n    return this.emit('error', new Error('Invalid data'));\n\n  if (!Buffer.isBuffer(this.handle)) {\n    return this.once('open', function() {\n      this._write(data, encoding, cb);\n    });\n  }\n\n  var self = this;\n  this.sftp.writeData(this.handle,\n                      data,\n                      0,\n                      data.length,\n                      this.pos,\n                      function(er, bytes) {\n    if (er) {\n      if (self.autoClose)\n        self.destroy();\n      return cb(er);\n    }\n    self.bytesWritten += bytes;\n    cb();\n  });\n\n  this.pos += data.length;\n};\n\nWriteStream.prototype._writev = function(data, cb) {\n  if (!Buffer.isBuffer(this.handle)) {\n    return this.once('open', function() {\n      this._writev(data, cb);\n    });\n  }\n\n  var sftp = this.sftp;\n  var handle = this.handle;\n  var writesLeft = data.length;\n  var self = this;\n\n  for (var i = 0; i < data.length; ++i) {\n    var chunk = data[i].chunk;\n\n    sftp.writeData(handle, chunk, 0, chunk.length, this.pos, onwrite);\n    this.pos += chunk.length;\n  }\n\n  function onwrite(er, bytes) {\n    if (er) {\n      self.destroy();\n      return cb(er);\n    }\n    self.bytesWritten += bytes;\n    if (--writesLeft === 0)\n      cb();\n  }\n};\n\nWriteStream.prototype.destroy = ReadStream.prototype.destroy;\nWriteStream.prototype.close = ReadStream.prototype.close;\n\n// There is no shutdown() for files.\nWriteStream.prototype.destroySoon = WriteStream.prototype.end;\n\n\nmodule.exports = SFTPStream;\n\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nvar errors = require('./errors');\nvar types = require('./types');\n\nvar Reader = require('./reader');\nvar Writer = require('./writer');\n\n\n///--- Exports\n\nmodule.exports = {\n\n  Reader: Reader,\n\n  Writer: Writer\n\n};\n\nfor (var t in types) {\n  if (types.hasOwnProperty(t))\n    module.exports[t] = types[t];\n}\nfor (var e in errors) {\n  if (errors.hasOwnProperty(e))\n    module.exports[e] = errors[e];\n}\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nvar assert = require('assert');\n\nvar ASN1 = require('./types');\nvar errors = require('./errors');\n\n\n///--- Globals\n\nvar newInvalidAsn1Error = errors.newInvalidAsn1Error;\n\n\n\n///--- API\n\nfunction Reader(data) {\n  if (!data || !Buffer.isBuffer(data))\n    throw new TypeError('data must be a node Buffer');\n\n  this._buf = data;\n  this._size = data.length;\n\n  // These hold the \"current\" state\n  this._len = 0;\n  this._offset = 0;\n}\n\nObject.defineProperty(Reader.prototype, 'length', {\n  enumerable: true,\n  get: function () { return (this._len); }\n});\n\nObject.defineProperty(Reader.prototype, 'offset', {\n  enumerable: true,\n  get: function () { return (this._offset); }\n});\n\nObject.defineProperty(Reader.prototype, 'remain', {\n  get: function () { return (this._size - this._offset); }\n});\n\nObject.defineProperty(Reader.prototype, 'buffer', {\n  get: function () { return (this._buf.slice(this._offset)); }\n});\n\n\n/**\n * Reads a single byte and advances offset; you can pass in `true` to make this\n * a \"peek\" operation (i.e., get the byte, but don't advance the offset).\n *\n * @param {Boolean} peek true means don't move offset.\n * @return {Number} the next byte, null if not enough data.\n */\nReader.prototype.readByte = function(peek) {\n  if (this._size - this._offset < 1)\n    return null;\n\n  var b = this._buf[this._offset] & 0xff;\n\n  if (!peek)\n    this._offset += 1;\n\n  return b;\n};\n\n\nReader.prototype.peek = function() {\n  return this.readByte(true);\n};\n\n\n/**\n * Reads a (potentially) variable length off the BER buffer.  This call is\n * not really meant to be called directly, as callers have to manipulate\n * the internal buffer afterwards.\n *\n * As a result of this call, you can call `Reader.length`, until the\n * next thing called that does a readLength.\n *\n * @return {Number} the amount of offset to advance the buffer.\n * @throws {InvalidAsn1Error} on bad ASN.1\n */\nReader.prototype.readLength = function(offset) {\n  if (offset === undefined)\n    offset = this._offset;\n\n  if (offset >= this._size)\n    return null;\n\n  var lenB = this._buf[offset++] & 0xff;\n  if (lenB === null)\n    return null;\n\n  if ((lenB & 0x80) == 0x80) {\n    lenB &= 0x7f;\n\n    if (lenB == 0)\n      throw newInvalidAsn1Error('Indefinite length not supported');\n\n    if (lenB > 4)\n      throw newInvalidAsn1Error('encoding too long');\n\n    if (this._size - offset < lenB)\n      return null;\n\n    this._len = 0;\n    for (var i = 0; i < lenB; i++)\n      this._len = (this._len << 8) + (this._buf[offset++] & 0xff);\n\n  } else {\n    // Wasn't a variable length\n    this._len = lenB;\n  }\n\n  return offset;\n};\n\n\n/**\n * Parses the next sequence in this BER buffer.\n *\n * To get the length of the sequence, call `Reader.length`.\n *\n * @return {Number} the sequence's tag.\n */\nReader.prototype.readSequence = function(tag) {\n  var seq = this.peek();\n  if (seq === null)\n    return null;\n  if (tag !== undefined && tag !== seq)\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\n                              ': got 0x' + seq.toString(16));\n\n  var o = this.readLength(this._offset + 1); // stored in `length`\n  if (o === null)\n    return null;\n\n  this._offset = o;\n  return seq;\n};\n\n\nReader.prototype.readInt = function() {\n  return this._readTag(ASN1.Integer);\n};\n\n\nReader.prototype.readBoolean = function() {\n  return (this._readTag(ASN1.Boolean) === 0 ? false : true);\n};\n\n\nReader.prototype.readEnumeration = function() {\n  return this._readTag(ASN1.Enumeration);\n};\n\n\nReader.prototype.readString = function(tag, retbuf) {\n  if (!tag)\n    tag = ASN1.OctetString;\n\n  var b = this.peek();\n  if (b === null)\n    return null;\n\n  if (b !== tag)\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\n                              ': got 0x' + b.toString(16));\n\n  var o = this.readLength(this._offset + 1); // stored in `length`\n\n  if (o === null)\n    return null;\n\n  if (this.length > this._size - o)\n    return null;\n\n  this._offset = o;\n\n  if (this.length === 0)\n    return retbuf ? new Buffer(0) : '';\n\n  var str = this._buf.slice(this._offset, this._offset + this.length);\n  this._offset += this.length;\n\n  return retbuf ? str : str.toString('utf8');\n};\n\nReader.prototype.readOID = function(tag) {\n  if (!tag)\n    tag = ASN1.OID;\n\n  var b = this.readString(tag, true);\n  if (b === null)\n    return null;\n\n  var values = [];\n  var value = 0;\n\n  for (var i = 0; i < b.length; i++) {\n    var byte = b[i] & 0xff;\n\n    value <<= 7;\n    value += byte & 0x7f;\n    if ((byte & 0x80) == 0) {\n      values.push(value);\n      value = 0;\n    }\n  }\n\n  value = values.shift();\n  values.unshift(value % 40);\n  values.unshift((value / 40) >> 0);\n\n  return values.join('.');\n};\n\n\nReader.prototype._readTag = function(tag) {\n  assert.ok(tag !== undefined);\n\n  var b = this.peek();\n\n  if (b === null)\n    return null;\n\n  if (b !== tag)\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\n                              ': got 0x' + b.toString(16));\n\n  var o = this.readLength(this._offset + 1); // stored in `length`\n  if (o === null)\n    return null;\n\n  if (this.length > 4)\n    throw newInvalidAsn1Error('Integer too long: ' + this.length);\n\n  if (this.length > this._size - o)\n    return null;\n  this._offset = o;\n\n  var fb = this._buf[this._offset];\n  var value = 0;\n\n  for (var i = 0; i < this.length; i++) {\n    value <<= 8;\n    value |= (this._buf[this._offset++] & 0xff);\n  }\n\n  if ((fb & 0x80) == 0x80 && i !== 4)\n    value -= (1 << (i * 8));\n\n  return value >> 0;\n};\n\n\n\n///--- Exported API\n\nmodule.exports = Reader;\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nvar assert = require('assert');\nvar ASN1 = require('./types');\nvar errors = require('./errors');\n\n\n///--- Globals\n\nvar newInvalidAsn1Error = errors.newInvalidAsn1Error;\n\nvar DEFAULT_OPTS = {\n  size: 1024,\n  growthFactor: 8\n};\n\n\n///--- Helpers\n\nfunction merge(from, to) {\n  assert.ok(from);\n  assert.equal(typeof(from), 'object');\n  assert.ok(to);\n  assert.equal(typeof(to), 'object');\n\n  var keys = Object.getOwnPropertyNames(from);\n  keys.forEach(function(key) {\n    if (to[key])\n      return;\n\n    var value = Object.getOwnPropertyDescriptor(from, key);\n    Object.defineProperty(to, key, value);\n  });\n\n  return to;\n}\n\n\n\n///--- API\n\nfunction Writer(options) {\n  options = merge(DEFAULT_OPTS, options || {});\n\n  this._buf = new Buffer(options.size || 1024);\n  this._size = this._buf.length;\n  this._offset = 0;\n  this._options = options;\n\n  // A list of offsets in the buffer where we need to insert\n  // sequence tag/len pairs.\n  this._seq = [];\n}\n\nObject.defineProperty(Writer.prototype, 'buffer', {\n  get: function () {\n    if (this._seq.length)\n      throw new InvalidAsn1Error(this._seq.length + ' unended sequence(s)');\n\n    return (this._buf.slice(0, this._offset));\n  }\n});\n\nWriter.prototype.writeByte = function(b) {\n  if (typeof(b) !== 'number')\n    throw new TypeError('argument must be a Number');\n\n  this._ensure(1);\n  this._buf[this._offset++] = b;\n};\n\n\nWriter.prototype.writeInt = function(i, tag) {\n  if (typeof(i) !== 'number')\n    throw new TypeError('argument must be a Number');\n  if (typeof(tag) !== 'number')\n    tag = ASN1.Integer;\n\n  var sz = 4;\n\n  while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000 >> 0)) &&\n         (sz > 1)) {\n    sz--;\n    i <<= 8;\n  }\n\n  if (sz > 4)\n    throw new InvalidAsn1Error('BER ints cannot be > 0xffffffff');\n\n  this._ensure(2 + sz);\n  this._buf[this._offset++] = tag;\n  this._buf[this._offset++] = sz;\n\n  while (sz-- > 0) {\n    this._buf[this._offset++] = ((i & 0xff000000) >>> 24);\n    i <<= 8;\n  }\n\n};\n\n\nWriter.prototype.writeNull = function() {\n  this.writeByte(ASN1.Null);\n  this.writeByte(0x00);\n};\n\n\nWriter.prototype.writeEnumeration = function(i, tag) {\n  if (typeof(i) !== 'number')\n    throw new TypeError('argument must be a Number');\n  if (typeof(tag) !== 'number')\n    tag = ASN1.Enumeration;\n\n  return this.writeInt(i, tag);\n};\n\n\nWriter.prototype.writeBoolean = function(b, tag) {\n  if (typeof(b) !== 'boolean')\n    throw new TypeError('argument must be a Boolean');\n  if (typeof(tag) !== 'number')\n    tag = ASN1.Boolean;\n\n  this._ensure(3);\n  this._buf[this._offset++] = tag;\n  this._buf[this._offset++] = 0x01;\n  this._buf[this._offset++] = b ? 0xff : 0x00;\n};\n\n\nWriter.prototype.writeString = function(s, tag) {\n  if (typeof(s) !== 'string')\n    throw new TypeError('argument must be a string (was: ' + typeof(s) + ')');\n  if (typeof(tag) !== 'number')\n    tag = ASN1.OctetString;\n\n  var len = Buffer.byteLength(s);\n  this.writeByte(tag);\n  this.writeLength(len);\n  if (len) {\n    this._ensure(len);\n    this._buf.write(s, this._offset);\n    this._offset += len;\n  }\n};\n\n\nWriter.prototype.writeBuffer = function(buf, tag) {\n  if (typeof(tag) !== 'number')\n    throw new TypeError('tag must be a number');\n  if (!Buffer.isBuffer(buf))\n    throw new TypeError('argument must be a buffer');\n\n  this.writeByte(tag);\n  this.writeLength(buf.length);\n  this._ensure(buf.length);\n  buf.copy(this._buf, this._offset, 0, buf.length);\n  this._offset += buf.length;\n};\n\n\nWriter.prototype.writeStringArray = function(strings) {\n  if ((!strings instanceof Array))\n    throw new TypeError('argument must be an Array[String]');\n\n  var self = this;\n  strings.forEach(function(s) {\n    self.writeString(s);\n  });\n};\n\n// This is really to solve DER cases, but whatever for now\nWriter.prototype.writeOID = function(s, tag) {\n  if (typeof(s) !== 'string')\n    throw new TypeError('argument must be a string');\n  if (typeof(tag) !== 'number')\n    tag = ASN1.OID;\n\n  if (!/^([0-9]+\\.){3,}[0-9]+$/.test(s))\n    throw new Error('argument is not a valid OID string');\n\n  function encodeOctet(bytes, octet) {\n    if (octet < 128) {\n        bytes.push(octet);\n    } else if (octet < 16384) {\n        bytes.push((octet >>> 7) | 0x80);\n        bytes.push(octet & 0x7F);\n    } else if (octet < 2097152) {\n      bytes.push((octet >>> 14) | 0x80);\n      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    } else if (octet < 268435456) {\n      bytes.push((octet >>> 21) | 0x80);\n      bytes.push(((octet >>> 14) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    } else {\n      bytes.push(((octet >>> 28) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 21) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 14) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    }\n  }\n\n  var tmp = s.split('.');\n  var bytes = [];\n  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));\n  tmp.slice(2).forEach(function(b) {\n    encodeOctet(bytes, parseInt(b, 10));\n  });\n\n  var self = this;\n  this._ensure(2 + bytes.length);\n  this.writeByte(tag);\n  this.writeLength(bytes.length);\n  bytes.forEach(function(b) {\n    self.writeByte(b);\n  });\n};\n\n\nWriter.prototype.writeLength = function(len) {\n  if (typeof(len) !== 'number')\n    throw new TypeError('argument must be a Number');\n\n  this._ensure(4);\n\n  if (len <= 0x7f) {\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xff) {\n    this._buf[this._offset++] = 0x81;\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xffff) {\n    this._buf[this._offset++] = 0x82;\n    this._buf[this._offset++] = len >> 8;\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xffffff) {\n    this._buf[this._offset++] = 0x83;\n    this._buf[this._offset++] = len >> 16;\n    this._buf[this._offset++] = len >> 8;\n    this._buf[this._offset++] = len;\n  } else {\n    throw new InvalidAsn1ERror('Length too long (> 4 bytes)');\n  }\n};\n\nWriter.prototype.startSequence = function(tag) {\n  if (typeof(tag) !== 'number')\n    tag = ASN1.Sequence | ASN1.Constructor;\n\n  this.writeByte(tag);\n  this._seq.push(this._offset);\n  this._ensure(3);\n  this._offset += 3;\n};\n\n\nWriter.prototype.endSequence = function() {\n  var seq = this._seq.pop();\n  var start = seq + 3;\n  var len = this._offset - start;\n\n  if (len <= 0x7f) {\n    this._shift(start, len, -2);\n    this._buf[seq] = len;\n  } else if (len <= 0xff) {\n    this._shift(start, len, -1);\n    this._buf[seq] = 0x81;\n    this._buf[seq + 1] = len;\n  } else if (len <= 0xffff) {\n    this._buf[seq] = 0x82;\n    this._buf[seq + 1] = len >> 8;\n    this._buf[seq + 2] = len;\n  } else if (len <= 0xffffff) {\n    this._shift(start, len, 1);\n    this._buf[seq] = 0x83;\n    this._buf[seq + 1] = len >> 16;\n    this._buf[seq + 2] = len >> 8;\n    this._buf[seq + 3] = len;\n  } else {\n    throw new InvalidAsn1Error('Sequence too long');\n  }\n};\n\n\nWriter.prototype._shift = function(start, len, shift) {\n  assert.ok(start !== undefined);\n  assert.ok(len !== undefined);\n  assert.ok(shift);\n\n  this._buf.copy(this._buf, start + shift, start, start + len);\n  this._offset += shift;\n};\n\nWriter.prototype._ensure = function(len) {\n  assert.ok(len);\n\n  if (this._size - this._offset < len) {\n    var sz = this._size * this._options.growthFactor;\n    if (sz - this._offset < len)\n      sz += len;\n\n    var buf = new Buffer(sz);\n\n    this._buf.copy(buf, 0, 0, this._offset);\n    this._buf = buf;\n    this._size = sz;\n  }\n};\n\n\n\n///--- Exported API\n\nmodule.exports = Writer;\n","// Copyright (c) 2005  Tom Wu\n// All Rights Reserved.\n// See \"LICENSE\" for details.\n\n// Basic JavaScript BN library - subset useful for RSA encryption.\n\n// Bits per digit\nvar dbits;\n\n// JavaScript engine analysis\nvar canary = 0xdeadbeefcafe;\nvar j_lm = ((canary&0xffffff)==0xefcafe);\n\n// (public) Constructor\nfunction BigInteger(a,b,c) {\n  if(a != null)\n    if(\"number\" == typeof a) this.fromNumber(a,b,c);\n    else if(b == null && \"string\" != typeof a) this.fromString(a,256);\n    else this.fromString(a,b);\n}\n\n// return new, unset BigInteger\nfunction nbi() { return new BigInteger(null); }\n\n// am: Compute w_j += (x*this_i), propagate carries,\n// c is initial carry, returns final carry.\n// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n// We need to select the fastest one that works in this environment.\n\n// Set max digit bits to 28 since some\n// browsers slow down when dealing with 32-bit numbers.\nfunction am3(i,x,w,j,c,n) {\n  var xl = x&0x3fff, xh = x>>14;\n  while(--n >= 0) {\n    var l = this[i]&0x3fff;\n    var h = this[i++]>>14;\n    var m = xh*l+h*xl;\n    l = xl*l+((m&0x3fff)<<14)+w[j]+c;\n    c = (l>>28)+(m>>14)+xh*h;\n    w[j++] = l&0xfffffff;\n  }\n  return c;\n}\nBigInteger.prototype.am = am3;\ndbits = 28;\n\nBigInteger.prototype.DB = dbits;\nBigInteger.prototype.DM = ((1<<dbits)-1);\nBigInteger.prototype.DV = (1<<dbits);\n\nvar BI_FP = 52;\nBigInteger.prototype.FV = Math.pow(2,BI_FP);\nBigInteger.prototype.F1 = BI_FP-dbits;\nBigInteger.prototype.F2 = 2*dbits-BI_FP;\n\n// Digit conversions\nvar BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\nvar BI_RC = new Array();\nvar rr,vv;\nrr = \"0\".charCodeAt(0);\nfor(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\nrr = \"a\".charCodeAt(0);\nfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\nrr = \"A\".charCodeAt(0);\nfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\nfunction int2char(n) { return BI_RM.charAt(n); }\nfunction intAt(s,i) {\n  var c = BI_RC[s.charCodeAt(i)];\n  return (c==null)?-1:c;\n}\n\n// (protected) copy this to r\nfunction bnpCopyTo(r) {\n  for(var i = this.t-1; i >= 0; --i) r[i] = this[i];\n  r.t = this.t;\n  r.s = this.s;\n}\n\n// (protected) set from integer value x, -DV <= x < DV\nfunction bnpFromInt(x) {\n  this.t = 1;\n  this.s = (x<0)?-1:0;\n  if(x > 0) this[0] = x;\n  else if(x < -1) this[0] = x+this.DV;\n  else this.t = 0;\n}\n\n// return bigint initialized to value\nfunction nbv(i) { var r = nbi(); r.fromInt(i); return r; }\n\n// (protected) set from string and radix\nfunction bnpFromString(s,b) {\n  var k;\n  if(b == 16) k = 4;\n  else if(b == 8) k = 3;\n  else if(b == 256) k = 8; // byte array\n  else if(b == 2) k = 1;\n  else if(b == 32) k = 5;\n  else if(b == 4) k = 2;\n  else { this.fromRadix(s,b); return; }\n  this.t = 0;\n  this.s = 0;\n  var i = s.length, mi = false, sh = 0;\n  while(--i >= 0) {\n    var x = (k==8)?s[i]&0xff:intAt(s,i);\n    if(x < 0) {\n      if(s.charAt(i) == \"-\") mi = true;\n      continue;\n    }\n    mi = false;\n    if(sh == 0)\n      this[this.t++] = x;\n    else if(sh+k > this.DB) {\n      this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\n      this[this.t++] = (x>>(this.DB-sh));\n    }\n    else\n      this[this.t-1] |= x<<sh;\n    sh += k;\n    if(sh >= this.DB) sh -= this.DB;\n  }\n  if(k == 8 && (s[0]&0x80) != 0) {\n    this.s = -1;\n    if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\n  }\n  this.clamp();\n  if(mi) BigInteger.ZERO.subTo(this,this);\n}\n\n// (protected) clamp off excess high words\nfunction bnpClamp() {\n  var c = this.s&this.DM;\n  while(this.t > 0 && this[this.t-1] == c) --this.t;\n}\n\n// (public) return string representation in given radix\nfunction bnToString(b) {\n  if(this.s < 0) return \"-\"+this.negate().toString(b);\n  var k;\n  if(b == 16) k = 4;\n  else if(b == 8) k = 3;\n  else if(b == 2) k = 1;\n  else if(b == 32) k = 5;\n  else if(b == 4) k = 2;\n  else return this.toRadix(b);\n  var km = (1<<k)-1, d, m = false, r = \"\", i = this.t;\n  var p = this.DB-(i*this.DB)%k;\n  if(i-- > 0) {\n    if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }\n    while(i >= 0) {\n      if(p < k) {\n        d = (this[i]&((1<<p)-1))<<(k-p);\n        d |= this[--i]>>(p+=this.DB-k);\n      }\n      else {\n        d = (this[i]>>(p-=k))&km;\n        if(p <= 0) { p += this.DB; --i; }\n      }\n      if(d > 0) m = true;\n      if(m) r += int2char(d);\n    }\n  }\n  return m?r:\"0\";\n}\n\n// (public) -this\nfunction bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\n\n// (public) |this|\nfunction bnAbs() { return (this.s<0)?this.negate():this; }\n\n// (public) return + if this > a, - if this < a, 0 if equal\nfunction bnCompareTo(a) {\n  var r = this.s-a.s;\n  if(r != 0) return r;\n  var i = this.t;\n  r = i-a.t;\n  if(r != 0) return (this.s<0)?-r:r;\n  while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;\n  return 0;\n}\n\n// returns bit length of the integer x\nfunction nbits(x) {\n  var r = 1, t;\n  if((t=x>>>16) != 0) { x = t; r += 16; }\n  if((t=x>>8) != 0) { x = t; r += 8; }\n  if((t=x>>4) != 0) { x = t; r += 4; }\n  if((t=x>>2) != 0) { x = t; r += 2; }\n  if((t=x>>1) != 0) { x = t; r += 1; }\n  return r;\n}\n\n// (public) return the number of bits in \"this\"\nfunction bnBitLength() {\n  if(this.t <= 0) return 0;\n  return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));\n}\n\n// (protected) r = this << n*DB\nfunction bnpDLShiftTo(n,r) {\n  var i;\n  for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];\n  for(i = n-1; i >= 0; --i) r[i] = 0;\n  r.t = this.t+n;\n  r.s = this.s;\n}\n\n// (protected) r = this >> n*DB\nfunction bnpDRShiftTo(n,r) {\n  for(var i = n; i < this.t; ++i) r[i-n] = this[i];\n  r.t = Math.max(this.t-n,0);\n  r.s = this.s;\n}\n\n// (protected) r = this << n\nfunction bnpLShiftTo(n,r) {\n  var bs = n%this.DB;\n  var cbs = this.DB-bs;\n  var bm = (1<<cbs)-1;\n  var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\n  for(i = this.t-1; i >= 0; --i) {\n    r[i+ds+1] = (this[i]>>cbs)|c;\n    c = (this[i]&bm)<<bs;\n  }\n  for(i = ds-1; i >= 0; --i) r[i] = 0;\n  r[ds] = c;\n  r.t = this.t+ds+1;\n  r.s = this.s;\n  r.clamp();\n}\n\n// (protected) r = this >> n\nfunction bnpRShiftTo(n,r) {\n  r.s = this.s;\n  var ds = Math.floor(n/this.DB);\n  if(ds >= this.t) { r.t = 0; return; }\n  var bs = n%this.DB;\n  var cbs = this.DB-bs;\n  var bm = (1<<bs)-1;\n  r[0] = this[ds]>>bs;\n  for(var i = ds+1; i < this.t; ++i) {\n    r[i-ds-1] |= (this[i]&bm)<<cbs;\n    r[i-ds] = this[i]>>bs;\n  }\n  if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;\n  r.t = this.t-ds;\n  r.clamp();\n}\n\n// (protected) r = this - a\nfunction bnpSubTo(a,r) {\n  var i = 0, c = 0, m = Math.min(a.t,this.t);\n  while(i < m) {\n    c += this[i]-a[i];\n    r[i++] = c&this.DM;\n    c >>= this.DB;\n  }\n  if(a.t < this.t) {\n    c -= a.s;\n    while(i < this.t) {\n      c += this[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  }\n  else {\n    c += this.s;\n    while(i < a.t) {\n      c -= a[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c -= a.s;\n  }\n  r.s = (c<0)?-1:0;\n  if(c < -1) r[i++] = this.DV+c;\n  else if(c > 0) r[i++] = c;\n  r.t = i;\n  r.clamp();\n}\n\n// (protected) r = this * a, r != this,a (HAC 14.12)\n// \"this\" should be the larger one if appropriate.\nfunction bnpMultiplyTo(a,r) {\n  var x = this.abs(), y = a.abs();\n  var i = x.t;\n  r.t = i+y.t;\n  while(--i >= 0) r[i] = 0;\n  for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);\n  r.s = 0;\n  r.clamp();\n  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\n}\n\n// (protected) r = this^2, r != this (HAC 14.16)\nfunction bnpSquareTo(r) {\n  var x = this.abs();\n  var i = r.t = 2*x.t;\n  while(--i >= 0) r[i] = 0;\n  for(i = 0; i < x.t-1; ++i) {\n    var c = x.am(i,x[i],r,2*i,0,1);\n    if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\n      r[i+x.t] -= x.DV;\n      r[i+x.t+1] = 1;\n    }\n  }\n  if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);\n  r.s = 0;\n  r.clamp();\n}\n\n// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n// r != q, this != m.  q or r may be null.\nfunction bnpDivRemTo(m,q,r) {\n  var pm = m.abs();\n  if(pm.t <= 0) return;\n  var pt = this.abs();\n  if(pt.t < pm.t) {\n    if(q != null) q.fromInt(0);\n    if(r != null) this.copyTo(r);\n    return;\n  }\n  if(r == null) r = nbi();\n  var y = nbi(), ts = this.s, ms = m.s;\n  var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus\n  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }\n  else { pm.copyTo(y); pt.copyTo(r); }\n  var ys = y.t;\n  var y0 = y[ys-1];\n  if(y0 == 0) return;\n  var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);\n  var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\n  var i = r.t, j = i-ys, t = (q==null)?nbi():q;\n  y.dlShiftTo(j,t);\n  if(r.compareTo(t) >= 0) {\n    r[r.t++] = 1;\n    r.subTo(t,r);\n  }\n  BigInteger.ONE.dlShiftTo(ys,t);\n  t.subTo(y,y);  // \"negative\" y so we can replace sub with am later\n  while(y.t < ys) y[y.t++] = 0;\n  while(--j >= 0) {\n    // Estimate quotient digit\n    var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);\n    if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {   // Try it out\n      y.dlShiftTo(j,t);\n      r.subTo(t,r);\n      while(r[i] < --qd) r.subTo(t,r);\n    }\n  }\n  if(q != null) {\n    r.drShiftTo(ys,q);\n    if(ts != ms) BigInteger.ZERO.subTo(q,q);\n  }\n  r.t = ys;\n  r.clamp();\n  if(nsh > 0) r.rShiftTo(nsh,r); // Denormalize remainder\n  if(ts < 0) BigInteger.ZERO.subTo(r,r);\n}\n\n// (public) this mod a\nfunction bnMod(a) {\n  var r = nbi();\n  this.abs().divRemTo(a,null,r);\n  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\n  return r;\n}\n\n// Modular reduction using \"classic\" algorithm\nfunction Classic(m) { this.m = m; }\nfunction cConvert(x) {\n  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n  else return x;\n}\nfunction cRevert(x) { return x; }\nfunction cReduce(x) { x.divRemTo(this.m,null,x); }\nfunction cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\nfunction cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\nClassic.prototype.convert = cConvert;\nClassic.prototype.revert = cRevert;\nClassic.prototype.reduce = cReduce;\nClassic.prototype.mulTo = cMulTo;\nClassic.prototype.sqrTo = cSqrTo;\n\n// (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n// justification:\n//         xy == 1 (mod m)\n//         xy =  1+km\n//   xy(2-xy) = (1+km)(1-km)\n// x[y(2-xy)] = 1-k^2m^2\n// x[y(2-xy)] == 1 (mod m^2)\n// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n// JS multiply \"overflows\" differently from C/C++, so care is needed here.\nfunction bnpInvDigit() {\n  if(this.t < 1) return 0;\n  var x = this[0];\n  if((x&1) == 0) return 0;\n  var y = x&3;       // y == 1/x mod 2^2\n  y = (y*(2-(x&0xf)*y))&0xf; // y == 1/x mod 2^4\n  y = (y*(2-(x&0xff)*y))&0xff;   // y == 1/x mod 2^8\n  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;    // y == 1/x mod 2^16\n  // last step - calculate inverse mod DV directly;\n  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n  y = (y*(2-x*y%this.DV))%this.DV;       // y == 1/x mod 2^dbits\n  // we really want the negative inverse, and -DV < y < DV\n  return (y>0)?this.DV-y:-y;\n}\n\n// Montgomery reduction\nfunction Montgomery(m) {\n  this.m = m;\n  this.mp = m.invDigit();\n  this.mpl = this.mp&0x7fff;\n  this.mph = this.mp>>15;\n  this.um = (1<<(m.DB-15))-1;\n  this.mt2 = 2*m.t;\n}\n\n// xR mod m\nfunction montConvert(x) {\n  var r = nbi();\n  x.abs().dlShiftTo(this.m.t,r);\n  r.divRemTo(this.m,null,r);\n  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\n  return r;\n}\n\n// x/R mod m\nfunction montRevert(x) {\n  var r = nbi();\n  x.copyTo(r);\n  this.reduce(r);\n  return r;\n}\n\n// x = x/R mod m (HAC 14.32)\nfunction montReduce(x) {\n  while(x.t <= this.mt2) // pad x so am has enough room later\n    x[x.t++] = 0;\n  for(var i = 0; i < this.m.t; ++i) {\n    // faster way of calculating u0 = x[i]*mp mod DV\n    var j = x[i]&0x7fff;\n    var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\n    // use am to combine the multiply-shift-add into one call\n    j = i+this.m.t;\n    x[j] += this.m.am(0,u0,x,i,0,this.m.t);\n    // propagate carry\n    while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }\n  }\n  x.clamp();\n  x.drShiftTo(this.m.t,x);\n  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n}\n\n// r = \"x^2/R mod m\"; x != r\nfunction montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n// r = \"xy/R mod m\"; x,y != r\nfunction montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\nMontgomery.prototype.convert = montConvert;\nMontgomery.prototype.revert = montRevert;\nMontgomery.prototype.reduce = montReduce;\nMontgomery.prototype.mulTo = montMulTo;\nMontgomery.prototype.sqrTo = montSqrTo;\n\n// (protected) true iff this is even\nfunction bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }\n\n// (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\nfunction bnpExp(e,z) {\n  if(e > 0xffffffff || e < 1) return BigInteger.ONE;\n  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\n  g.copyTo(r);\n  while(--i >= 0) {\n    z.sqrTo(r,r2);\n    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\n    else { var t = r; r = r2; r2 = t; }\n  }\n  return z.revert(r);\n}\n\n// (public) this^e % m, 0 <= e < 2^32\nfunction bnModPowInt(e,m) {\n  var z;\n  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\n  return this.exp(e,z);\n}\n\n// protected\nBigInteger.prototype.copyTo = bnpCopyTo;\nBigInteger.prototype.fromInt = bnpFromInt;\nBigInteger.prototype.fromString = bnpFromString;\nBigInteger.prototype.clamp = bnpClamp;\nBigInteger.prototype.dlShiftTo = bnpDLShiftTo;\nBigInteger.prototype.drShiftTo = bnpDRShiftTo;\nBigInteger.prototype.lShiftTo = bnpLShiftTo;\nBigInteger.prototype.rShiftTo = bnpRShiftTo;\nBigInteger.prototype.subTo = bnpSubTo;\nBigInteger.prototype.multiplyTo = bnpMultiplyTo;\nBigInteger.prototype.squareTo = bnpSquareTo;\nBigInteger.prototype.divRemTo = bnpDivRemTo;\nBigInteger.prototype.invDigit = bnpInvDigit;\nBigInteger.prototype.isEven = bnpIsEven;\nBigInteger.prototype.exp = bnpExp;\n\n// public\nBigInteger.prototype.toString = bnToString;\nBigInteger.prototype.negate = bnNegate;\nBigInteger.prototype.abs = bnAbs;\nBigInteger.prototype.compareTo = bnCompareTo;\nBigInteger.prototype.bitLength = bnBitLength;\nBigInteger.prototype.mod = bnMod;\nBigInteger.prototype.modPowInt = bnModPowInt;\n\n// \"constants\"\nBigInteger.ZERO = nbv(0);\nBigInteger.ONE = nbv(1);\n\n// Copyright (c) 2005-2009  Tom Wu\n// All Rights Reserved.\n// See \"LICENSE\" for details.\n\n// Extended JavaScript BN functions, required for RSA private ops.\n\n// Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n// Version 1.2: square() API, isProbablePrime fix\n\n// (public)\nfunction bnClone() { var r = nbi(); this.copyTo(r); return r; }\n\n// (public) return value as integer\nfunction bnIntValue() {\n  if(this.s < 0) {\n    if(this.t == 1) return this[0]-this.DV;\n    else if(this.t == 0) return -1;\n  }\n  else if(this.t == 1) return this[0];\n  else if(this.t == 0) return 0;\n  // assumes 16 < DB < 32\n  return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];\n}\n\n// (public) return value as byte\nfunction bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }\n\n// (public) return value as short (assumes DB>=16)\nfunction bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }\n\n// (protected) return x s.t. r^x < DV\nfunction bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }\n\n// (public) 0 if this == 0, 1 if this > 0\nfunction bnSigNum() {\n  if(this.s < 0) return -1;\n  else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n  else return 1;\n}\n\n// (protected) convert to radix string\nfunction bnpToRadix(b) {\n  if(b == null) b = 10;\n  if(this.signum() == 0 || b < 2 || b > 36) return \"0\";\n  var cs = this.chunkSize(b);\n  var a = Math.pow(b,cs);\n  var d = nbv(a), y = nbi(), z = nbi(), r = \"\";\n  this.divRemTo(d,y,z);\n  while(y.signum() > 0) {\n    r = (a+z.intValue()).toString(b).substr(1) + r;\n    y.divRemTo(d,y,z);\n  }\n  return z.intValue().toString(b) + r;\n}\n\n// (protected) convert from radix string\nfunction bnpFromRadix(s,b) {\n  this.fromInt(0);\n  if(b == null) b = 10;\n  var cs = this.chunkSize(b);\n  var d = Math.pow(b,cs), mi = false, j = 0, w = 0;\n  for(var i = 0; i < s.length; ++i) {\n    var x = intAt(s,i);\n    if(x < 0) {\n      if(s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n      continue;\n    }\n    w = b*w+x;\n    if(++j >= cs) {\n      this.dMultiply(d);\n      this.dAddOffset(w,0);\n      j = 0;\n      w = 0;\n    }\n  }\n  if(j > 0) {\n    this.dMultiply(Math.pow(b,j));\n    this.dAddOffset(w,0);\n  }\n  if(mi) BigInteger.ZERO.subTo(this,this);\n}\n\n// (protected) alternate constructor\nfunction bnpFromNumber(a,b,c) {\n  if(\"number\" == typeof b) {\n    // new BigInteger(int,int,RNG)\n    if(a < 2) this.fromInt(1);\n    else {\n      this.fromNumber(a,c);\n      if(!this.testBit(a-1))  // force MSB set\n        this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);\n      if(this.isEven()) this.dAddOffset(1,0); // force odd\n      while(!this.isProbablePrime(b)) {\n        this.dAddOffset(2,0);\n        if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);\n      }\n    }\n  }\n  else {\n    // new BigInteger(int,RNG)\n    var x = new Array(), t = a&7;\n    x.length = (a>>3)+1;\n    b.nextBytes(x);\n    if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;\n    this.fromString(x,256);\n  }\n}\n\n// (public) convert to bigendian byte array\nfunction bnToByteArray() {\n  var i = this.t, r = new Array();\n  r[0] = this.s;\n  var p = this.DB-(i*this.DB)%8, d, k = 0;\n  if(i-- > 0) {\n    if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)\n      r[k++] = d|(this.s<<(this.DB-p));\n    while(i >= 0) {\n      if(p < 8) {\n        d = (this[i]&((1<<p)-1))<<(8-p);\n        d |= this[--i]>>(p+=this.DB-8);\n      }\n      else {\n        d = (this[i]>>(p-=8))&0xff;\n        if(p <= 0) { p += this.DB; --i; }\n      }\n      if((d&0x80) != 0) d |= -256;\n      if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;\n      if(k > 0 || d != this.s) r[k++] = d;\n    }\n  }\n  return r;\n}\n\nfunction bnEquals(a) { return(this.compareTo(a)==0); }\nfunction bnMin(a) { return(this.compareTo(a)<0)?this:a; }\nfunction bnMax(a) { return(this.compareTo(a)>0)?this:a; }\n\n// (protected) r = this op a (bitwise)\nfunction bnpBitwiseTo(a,op,r) {\n  var i, f, m = Math.min(a.t,this.t);\n  for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);\n  if(a.t < this.t) {\n    f = a.s&this.DM;\n    for(i = m; i < this.t; ++i) r[i] = op(this[i],f);\n    r.t = this.t;\n  }\n  else {\n    f = this.s&this.DM;\n    for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);\n    r.t = a.t;\n  }\n  r.s = op(this.s,a.s);\n  r.clamp();\n}\n\n// (public) this & a\nfunction op_and(x,y) { return x&y; }\nfunction bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }\n\n// (public) this | a\nfunction op_or(x,y) { return x|y; }\nfunction bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }\n\n// (public) this ^ a\nfunction op_xor(x,y) { return x^y; }\nfunction bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }\n\n// (public) this & ~a\nfunction op_andnot(x,y) { return x&~y; }\nfunction bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }\n\n// (public) ~this\nfunction bnNot() {\n  var r = nbi();\n  for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];\n  r.t = this.t;\n  r.s = ~this.s;\n  return r;\n}\n\n// (public) this << n\nfunction bnShiftLeft(n) {\n  var r = nbi();\n  if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);\n  return r;\n}\n\n// (public) this >> n\nfunction bnShiftRight(n) {\n  var r = nbi();\n  if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);\n  return r;\n}\n\n// return index of lowest 1-bit in x, x < 2^31\nfunction lbit(x) {\n  if(x == 0) return -1;\n  var r = 0;\n  if((x&0xffff) == 0) { x >>= 16; r += 16; }\n  if((x&0xff) == 0) { x >>= 8; r += 8; }\n  if((x&0xf) == 0) { x >>= 4; r += 4; }\n  if((x&3) == 0) { x >>= 2; r += 2; }\n  if((x&1) == 0) ++r;\n  return r;\n}\n\n// (public) returns index of lowest 1-bit (or -1 if none)\nfunction bnGetLowestSetBit() {\n  for(var i = 0; i < this.t; ++i)\n    if(this[i] != 0) return i*this.DB+lbit(this[i]);\n  if(this.s < 0) return this.t*this.DB;\n  return -1;\n}\n\n// return number of 1 bits in x\nfunction cbit(x) {\n  var r = 0;\n  while(x != 0) { x &= x-1; ++r; }\n  return r;\n}\n\n// (public) return number of set bits\nfunction bnBitCount() {\n  var r = 0, x = this.s&this.DM;\n  for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);\n  return r;\n}\n\n// (public) true iff nth bit is set\nfunction bnTestBit(n) {\n  var j = Math.floor(n/this.DB);\n  if(j >= this.t) return(this.s!=0);\n  return((this[j]&(1<<(n%this.DB)))!=0);\n}\n\n// (protected) this op (1<<n)\nfunction bnpChangeBit(n,op) {\n  var r = BigInteger.ONE.shiftLeft(n);\n  this.bitwiseTo(r,op,r);\n  return r;\n}\n\n// (public) this | (1<<n)\nfunction bnSetBit(n) { return this.changeBit(n,op_or); }\n\n// (public) this & ~(1<<n)\nfunction bnClearBit(n) { return this.changeBit(n,op_andnot); }\n\n// (public) this ^ (1<<n)\nfunction bnFlipBit(n) { return this.changeBit(n,op_xor); }\n\n// (protected) r = this + a\nfunction bnpAddTo(a,r) {\n  var i = 0, c = 0, m = Math.min(a.t,this.t);\n  while(i < m) {\n    c += this[i]+a[i];\n    r[i++] = c&this.DM;\n    c >>= this.DB;\n  }\n  if(a.t < this.t) {\n    c += a.s;\n    while(i < this.t) {\n      c += this[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  }\n  else {\n    c += this.s;\n    while(i < a.t) {\n      c += a[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c += a.s;\n  }\n  r.s = (c<0)?-1:0;\n  if(c > 0) r[i++] = c;\n  else if(c < -1) r[i++] = this.DV+c;\n  r.t = i;\n  r.clamp();\n}\n\n// (public) this + a\nfunction bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }\n\n// (public) this - a\nfunction bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }\n\n// (public) this * a\nfunction bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }\n\n// (public) this^2\nfunction bnSquare() { var r = nbi(); this.squareTo(r); return r; }\n\n// (public) this / a\nfunction bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }\n\n// (public) this % a\nfunction bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }\n\n// (public) [this/a,this%a]\nfunction bnDivideAndRemainder(a) {\n  var q = nbi(), r = nbi();\n  this.divRemTo(a,q,r);\n  return new Array(q,r);\n}\n\n// (protected) this *= n, this >= 0, 1 < n < DV\nfunction bnpDMultiply(n) {\n  this[this.t] = this.am(0,n-1,this,0,0,this.t);\n  ++this.t;\n  this.clamp();\n}\n\n// (protected) this += n << w words, this >= 0\nfunction bnpDAddOffset(n,w) {\n  if(n == 0) return;\n  while(this.t <= w) this[this.t++] = 0;\n  this[w] += n;\n  while(this[w] >= this.DV) {\n    this[w] -= this.DV;\n    if(++w >= this.t) this[this.t++] = 0;\n    ++this[w];\n  }\n}\n\n// A \"null\" reducer\nfunction NullExp() {}\nfunction nNop(x) { return x; }\nfunction nMulTo(x,y,r) { x.multiplyTo(y,r); }\nfunction nSqrTo(x,r) { x.squareTo(r); }\n\nNullExp.prototype.convert = nNop;\nNullExp.prototype.revert = nNop;\nNullExp.prototype.mulTo = nMulTo;\nNullExp.prototype.sqrTo = nSqrTo;\n\n// (public) this^e\nfunction bnPow(e) { return this.exp(e,new NullExp()); }\n\n// (protected) r = lower n words of \"this * a\", a.t <= n\n// \"this\" should be the larger one if appropriate.\nfunction bnpMultiplyLowerTo(a,n,r) {\n  var i = Math.min(this.t+a.t,n);\n  r.s = 0; // assumes a,this >= 0\n  r.t = i;\n  while(i > 0) r[--i] = 0;\n  var j;\n  for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);\n  for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);\n  r.clamp();\n}\n\n// (protected) r = \"this * a\" without lower n words, n > 0\n// \"this\" should be the larger one if appropriate.\nfunction bnpMultiplyUpperTo(a,n,r) {\n  --n;\n  var i = r.t = this.t+a.t-n;\n  r.s = 0; // assumes a,this >= 0\n  while(--i >= 0) r[i] = 0;\n  for(i = Math.max(n-this.t,0); i < a.t; ++i)\n    r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);\n  r.clamp();\n  r.drShiftTo(1,r);\n}\n\n// Barrett modular reduction\nfunction Barrett(m) {\n  // setup Barrett\n  this.r2 = nbi();\n  this.q3 = nbi();\n  BigInteger.ONE.dlShiftTo(2*m.t,this.r2);\n  this.mu = this.r2.divide(m);\n  this.m = m;\n}\n\nfunction barrettConvert(x) {\n  if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\n  else if(x.compareTo(this.m) < 0) return x;\n  else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\n}\n\nfunction barrettRevert(x) { return x; }\n\n// x = x mod m (HAC 14.42)\nfunction barrettReduce(x) {\n  x.drShiftTo(this.m.t-1,this.r2);\n  if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\n  this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\n  this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\n  while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\n  x.subTo(this.r2,x);\n  while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n}\n\n// r = x^2 mod m; x != r\nfunction barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n// r = x*y mod m; x,y != r\nfunction barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\nBarrett.prototype.convert = barrettConvert;\nBarrett.prototype.revert = barrettRevert;\nBarrett.prototype.reduce = barrettReduce;\nBarrett.prototype.mulTo = barrettMulTo;\nBarrett.prototype.sqrTo = barrettSqrTo;\n\n// (public) this^e % m (HAC 14.85)\nfunction bnModPow(e,m) {\n  var i = e.bitLength(), k, r = nbv(1), z;\n  if(i <= 0) return r;\n  else if(i < 18) k = 1;\n  else if(i < 48) k = 3;\n  else if(i < 144) k = 4;\n  else if(i < 768) k = 5;\n  else k = 6;\n  if(i < 8)\n    z = new Classic(m);\n  else if(m.isEven())\n    z = new Barrett(m);\n  else\n    z = new Montgomery(m);\n\n  // precomputation\n  var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;\n  g[1] = z.convert(this);\n  if(k > 1) {\n    var g2 = nbi();\n    z.sqrTo(g[1],g2);\n    while(n <= km) {\n      g[n] = nbi();\n      z.mulTo(g2,g[n-2],g[n]);\n      n += 2;\n    }\n  }\n\n  var j = e.t-1, w, is1 = true, r2 = nbi(), t;\n  i = nbits(e[j])-1;\n  while(j >= 0) {\n    if(i >= k1) w = (e[j]>>(i-k1))&km;\n    else {\n      w = (e[j]&((1<<(i+1))-1))<<(k1-i);\n      if(j > 0) w |= e[j-1]>>(this.DB+i-k1);\n    }\n\n    n = k;\n    while((w&1) == 0) { w >>= 1; --n; }\n    if((i -= n) < 0) { i += this.DB; --j; }\n    if(is1) {  // ret == 1, don't bother squaring or multiplying it\n      g[w].copyTo(r);\n      is1 = false;\n    }\n    else {\n      while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }\n      if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }\n      z.mulTo(r2,g[w],r);\n    }\n\n    while(j >= 0 && (e[j]&(1<<i)) == 0) {\n      z.sqrTo(r,r2); t = r; r = r2; r2 = t;\n      if(--i < 0) { i = this.DB-1; --j; }\n    }\n  }\n  return z.revert(r);\n}\n\n// (public) gcd(this,a) (HAC 14.54)\nfunction bnGCD(a) {\n  var x = (this.s<0)?this.negate():this.clone();\n  var y = (a.s<0)?a.negate():a.clone();\n  if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }\n  var i = x.getLowestSetBit(), g = y.getLowestSetBit();\n  if(g < 0) return x;\n  if(i < g) g = i;\n  if(g > 0) {\n    x.rShiftTo(g,x);\n    y.rShiftTo(g,y);\n  }\n  while(x.signum() > 0) {\n    if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);\n    if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);\n    if(x.compareTo(y) >= 0) {\n      x.subTo(y,x);\n      x.rShiftTo(1,x);\n    }\n    else {\n      y.subTo(x,y);\n      y.rShiftTo(1,y);\n    }\n  }\n  if(g > 0) y.lShiftTo(g,y);\n  return y;\n}\n\n// (protected) this % n, n < 2^26\nfunction bnpModInt(n) {\n  if(n <= 0) return 0;\n  var d = this.DV%n, r = (this.s<0)?n-1:0;\n  if(this.t > 0)\n    if(d == 0) r = this[0]%n;\n    else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;\n  return r;\n}\n\n// (public) 1/this % m (HAC 14.61)\nfunction bnModInverse(m) {\n  var ac = m.isEven();\n  if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n  var u = m.clone(), v = this.clone();\n  var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\n  while(u.signum() != 0) {\n    while(u.isEven()) {\n      u.rShiftTo(1,u);\n      if(ac) {\n        if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }\n        a.rShiftTo(1,a);\n      }\n      else if(!b.isEven()) b.subTo(m,b);\n      b.rShiftTo(1,b);\n    }\n    while(v.isEven()) {\n      v.rShiftTo(1,v);\n      if(ac) {\n        if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }\n        c.rShiftTo(1,c);\n      }\n      else if(!d.isEven()) d.subTo(m,d);\n      d.rShiftTo(1,d);\n    }\n    if(u.compareTo(v) >= 0) {\n      u.subTo(v,u);\n      if(ac) a.subTo(c,a);\n      b.subTo(d,b);\n    }\n    else {\n      v.subTo(u,v);\n      if(ac) c.subTo(a,c);\n      d.subTo(b,d);\n    }\n  }\n  if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n  if(d.compareTo(m) >= 0) return d.subtract(m);\n  if(d.signum() < 0) d.addTo(m,d); else return d;\n  if(d.signum() < 0) return d.add(m); else return d;\n}\n\nvar lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];\nvar lplim = (1<<26)/lowprimes[lowprimes.length-1];\n\n// (public) test primality with certainty >= 1-.5^t\nfunction bnIsProbablePrime(t) {\n  var i, x = this.abs();\n  if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {\n    for(i = 0; i < lowprimes.length; ++i)\n      if(x[0] == lowprimes[i]) return true;\n    return false;\n  }\n  if(x.isEven()) return false;\n  i = 1;\n  while(i < lowprimes.length) {\n    var m = lowprimes[i], j = i+1;\n    while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n    m = x.modInt(m);\n    while(i < j) if(m%lowprimes[i++] == 0) return false;\n  }\n  return x.millerRabin(t);\n}\n\n// (protected) true if probably prime (HAC 4.24, Miller-Rabin)\nfunction bnpMillerRabin(t) {\n  var n1 = this.subtract(BigInteger.ONE);\n  var k = n1.getLowestSetBit();\n  if(k <= 0) return false;\n  var r = n1.shiftRight(k);\n  t = (t+1)>>1;\n  if(t > lowprimes.length) t = lowprimes.length;\n  var a = nbi();\n  for(var i = 0; i < t; ++i) {\n    //Pick bases at random, instead of starting at 2\n    a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);\n    var y = a.modPow(r,this);\n    if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n      var j = 1;\n      while(j++ < k && y.compareTo(n1) != 0) {\n        y = y.modPowInt(2,this);\n        if(y.compareTo(BigInteger.ONE) == 0) return false;\n      }\n      if(y.compareTo(n1) != 0) return false;\n    }\n  }\n  return true;\n}\n\n// protected\nBigInteger.prototype.chunkSize = bnpChunkSize;\nBigInteger.prototype.toRadix = bnpToRadix;\nBigInteger.prototype.fromRadix = bnpFromRadix;\nBigInteger.prototype.fromNumber = bnpFromNumber;\nBigInteger.prototype.bitwiseTo = bnpBitwiseTo;\nBigInteger.prototype.changeBit = bnpChangeBit;\nBigInteger.prototype.addTo = bnpAddTo;\nBigInteger.prototype.dMultiply = bnpDMultiply;\nBigInteger.prototype.dAddOffset = bnpDAddOffset;\nBigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\nBigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\nBigInteger.prototype.modInt = bnpModInt;\nBigInteger.prototype.millerRabin = bnpMillerRabin;\n\n// public\nBigInteger.prototype.clone = bnClone;\nBigInteger.prototype.intValue = bnIntValue;\nBigInteger.prototype.byteValue = bnByteValue;\nBigInteger.prototype.shortValue = bnShortValue;\nBigInteger.prototype.signum = bnSigNum;\nBigInteger.prototype.toByteArray = bnToByteArray;\nBigInteger.prototype.equals = bnEquals;\nBigInteger.prototype.min = bnMin;\nBigInteger.prototype.max = bnMax;\nBigInteger.prototype.and = bnAnd;\nBigInteger.prototype.or = bnOr;\nBigInteger.prototype.xor = bnXor;\nBigInteger.prototype.andNot = bnAndNot;\nBigInteger.prototype.not = bnNot;\nBigInteger.prototype.shiftLeft = bnShiftLeft;\nBigInteger.prototype.shiftRight = bnShiftRight;\nBigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\nBigInteger.prototype.bitCount = bnBitCount;\nBigInteger.prototype.testBit = bnTestBit;\nBigInteger.prototype.setBit = bnSetBit;\nBigInteger.prototype.clearBit = bnClearBit;\nBigInteger.prototype.flipBit = bnFlipBit;\nBigInteger.prototype.add = bnAdd;\nBigInteger.prototype.subtract = bnSubtract;\nBigInteger.prototype.multiply = bnMultiply;\nBigInteger.prototype.divide = bnDivide;\nBigInteger.prototype.remainder = bnRemainder;\nBigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\nBigInteger.prototype.modPow = bnModPow;\nBigInteger.prototype.modInverse = bnModInverse;\nBigInteger.prototype.pow = bnPow;\nBigInteger.prototype.gcd = bnGCD;\nBigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\n// JSBN-specific extension\nBigInteger.prototype.square = bnSquare;\n\n// Expose the Barrett function\nBigInteger.prototype.Barrett = Barrett\n\n// BigInteger interfaces not implemented in jsbn:\n\n// BigInteger(int signum, byte[] magnitude)\n// double doubleValue()\n// float floatValue()\n// int hashCode()\n// long longValue()\n// static BigInteger valueOf(long val)\n\nmodule.exports = BigInteger;\n\n","// TODO:\n//    * handle multi-line header values (OpenSSH)?\n//    * more thorough validation?\n\nvar utils;\nvar Ber = require('asn1').Ber;\nvar semver = require('semver');\n\nvar RE_PPK = /^PuTTY-User-Key-File-2: ssh-(rsa|dss)\\r?\\nEncryption: (aes256-cbc|none)\\r?\\nComment: ([^\\r\\n]*)\\r?\\nPublic-Lines: \\d+\\r?\\n([\\s\\S]+?)\\r?\\nPrivate-Lines: \\d+\\r?\\n([\\s\\S]+?)\\r?\\nPrivate-MAC: ([^\\r\\n]+)/;\nvar RE_HEADER_OPENSSH_PRIV = /^-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----$/i;\nvar RE_FOOTER_OPENSSH_PRIV = /^-----END (?:RSA|DSA|EC) PRIVATE KEY-----$/i;\nvar RE_HEADER_OPENSSH_PUB = /^((?:(?:ssh-(rsa|dss))|ecdsa-sha2-nistp(256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z\\/+=]+)(?:$|\\s+([\\S].*)?)$/i;\nvar RE_HEADER_RFC4716_PUB = /^---- BEGIN SSH2 PUBLIC KEY ----$/i;\nvar RE_FOOTER_RFC4716_PUB = /^---- END SSH2 PUBLIC KEY ----$/i;\nvar RE_HEADER_OPENSSH = /^([^:]+):\\s*([\\S].*)?$/i;\nvar RE_HEADER_RFC4716 = /^([^:]+): (.*)?$/i;\n\nmodule.exports = function(data) {\n  if (Buffer.isBuffer(data))\n    data = data.toString('utf8');\n  else if (typeof data !== 'string')\n    return new Error('Key data must be a Buffer or string');\n\n  var ret = {\n    fulltype: undefined,\n    type: undefined,\n    curve: undefined,\n    extra: undefined,\n    comment: undefined,\n    encryption: undefined,\n    private: undefined,\n    privateOrig: undefined,\n    public: undefined,\n    publicOrig: undefined\n  };\n  var m;\n  var i;\n  var len;\n\n  data = data.trim().split(/\\r\\n|\\n/);\n\n  while (!data[0].length)\n    data.shift();\n  while (!data.slice(-1)[0].length)\n    data.pop();\n\n  var orig = data.join('\\n');\n\n  if ((m = RE_HEADER_OPENSSH_PRIV.exec(data[0]))\n      && RE_FOOTER_OPENSSH_PRIV.test(data.slice(-1))) {\n    // OpenSSH private key\n    var keyType = m[1].toLowerCase();\n    if (keyType === 'dsa')\n      keyType = 'dss';\n\n    if (keyType === 'ec' && semver.lt(process.version, '5.2.0')) {\n      return new Error(\n        'EC private keys are not supported in this version of node'\n      );\n    }\n\n    if (!RE_HEADER_OPENSSH.test(data[1])) {\n      // unencrypted, no headers\n      var privData = new Buffer(data.slice(1, -1).join(''), 'base64');\n      if (keyType !== 'ec') {\n        ret.fulltype = 'ssh-' + keyType;\n      } else {\n        // ECDSA\n        var asnReader = new Ber.Reader(privData);\n        asnReader.readSequence();\n        asnReader.readInt();\n        asnReader.readString(Ber.OctetString, true);\n        asnReader.readByte(); // Skip \"complex\" context type byte\n        var offset = asnReader.readLength(); // Skip context length\n        if (offset !== null) {\n          asnReader._offset = offset;\n          switch (asnReader.readOID()) {\n            case '1.2.840.10045.3.1.7':\n              // prime256v1/secp256r1\n              ret.fulltype = 'ecdsa-sha2-nistp256';\n              break;\n            case '1.3.132.0.34':\n              // secp384r1\n              ret.fulltype = 'ecdsa-sha2-nistp384';\n              break;\n            case '1.3.132.0.35':\n              // secp521r1\n              ret.fulltype = 'ecdsa-sha2-nistp521';\n              break;\n          }\n        }\n        if (ret.fulltype === undefined)\n          return new Error('Unsupported EC private key type');\n      }\n      ret.private = privData;\n    } else {\n      // possibly encrypted, headers\n      for (i = 1, len = data.length; i < len; ++i) {\n        m = RE_HEADER_OPENSSH.exec(data[i]);\n        if (m) {\n          m[1] = m[1].toLowerCase();\n          if (m[1] === 'dek-info') {\n            m[2] = m[2].split(',');\n            ret.encryption = m[2][0].toLowerCase();\n            if (m[2].length > 1)\n              ret.extra = m[2].slice(1);\n          }\n        } else if (data[i].length)\n          break;\n      }\n      ret.private = new Buffer(data.slice(i, -1).join(''), 'base64');\n    }\n    ret.type = keyType;\n    ret.privateOrig = new Buffer(orig);\n  } else if (m = RE_HEADER_OPENSSH_PUB.exec(data[0])) {\n    // OpenSSH public key\n    ret.fulltype = m[1];\n    ret.type = (m[2] || 'ec').toLowerCase();\n    ret.public = new Buffer(m[4], 'base64');\n    ret.publicOrig = new Buffer(orig);\n    ret.comment = m[5];\n    if (m[3]) // ECDSA only\n      ret.curve = 'nistp' + m[3];\n  } else if (RE_HEADER_RFC4716_PUB.test(data[0])\n             && RE_FOOTER_RFC4716_PUB.test(data.slice(-1))) {\n    if (data[1].indexOf(': ') === -1) {\n      // no headers\n      ret.public = new Buffer(data.slice(1, -1).join(''), 'base64');\n    } else {\n      // headers\n      for (i = 1, len = data.length; i < len; ++i) {\n        if (data[i].indexOf(': ') === -1) {\n          if (data[i].length)\n            break; // start of key data\n          else\n            continue; // empty line\n        }\n        while (data[i].substr(-1) === '\\\\') {\n          if (i + 1 < len) {\n            data[i] = data[i].slice(0, -1) + data[i + 1];\n            data.splice(i + 1, 1);\n            --len;\n          } else\n            return new Error('RFC4716 public key missing header continuation line');\n        }\n        m = RE_HEADER_RFC4716.exec(data[i]);\n        if (m) {\n          m[1] = m[1].toLowerCase();\n          if (m[1] === 'comment') {\n            ret.comment = m[2] || '';\n            if (ret.comment[0] === '\"' && ret.comment.substr(-1) === '\"')\n              ret.comment = ret.comment.slice(1, -1);\n          }\n        } else\n          return new Error('RFC4716 public key invalid header line');\n      }\n      ret.public = new Buffer(data.slice(i, -1).join(''), 'base64');\n    }\n    len = ret.public.readUInt32BE(0, true);\n    var fulltype = ret.public.toString('ascii', 4, 4 + len);\n    ret.fulltype = fulltype;\n    if (fulltype === 'ssh-dss')\n      ret.type = 'dss';\n    else if (fulltype === 'ssh-rsa')\n      ret.type = 'rsa';\n    else\n      return new Error('Unsupported RFC4716 public key type: ' + fulltype);\n    ret.public = ret.public.slice(11);\n    ret.publicOrig = new Buffer(orig);\n  } else if (m = RE_PPK.exec(orig)) {\n    // m[1] = short type\n    // m[2] = encryption type\n    // m[3] = comment\n    // m[4] = base64-encoded public key data:\n    //         for \"ssh-rsa\":\n    //          string \"ssh-rsa\"\n    //          mpint  e    (public exponent)\n    //          mpint  n    (modulus)\n    //         for \"ssh-dss\":\n    //          string \"ssh-dss\"\n    //          mpint p     (modulus)\n    //          mpint q     (prime)\n    //          mpint g     (base number)\n    //          mpint y     (public key parameter: g^x mod p)\n    // m[5] = base64-encoded private key data:\n    //         for \"ssh-rsa\":\n    //          mpint  d    (private exponent)\n    //          mpint  p    (prime 1)\n    //          mpint  q    (prime 2)\n    //          mpint  iqmp ([inverse of q] mod p)\n    //         for \"ssh-dss\":\n    //          mpint x     (private key parameter)\n    // m[6] = SHA1 HMAC over:\n    //          string  name of algorithm (\"ssh-dss\", \"ssh-rsa\")\n    //          string  encryption type\n    //          string  comment\n    //          string  public key data\n    //          string  private-plaintext (including the final padding)\n\n    // avoid cyclic require by requiring on first use\n    if (!utils)\n      utils = require('./utils');\n\n    ret.ppk = true;\n    ret.type = m[1];\n    ret.fulltype = 'ssh-' + m[1];\n    if (m[2] !== 'none')\n      ret.encryption = m[2];\n    ret.comment = m[3];\n\n    ret.public = new Buffer(m[4].replace(/\\r?\\n/g, ''), 'base64');\n    var privateKey = new Buffer(m[5].replace(/\\r?\\n/g, ''), 'base64');\n\n    ret.privateMAC = m[6].replace(/\\r?\\n/g, '');\n\n    // automatically verify private key MAC if we don't need to wait for\n    // decryption\n    if (!ret.encryption) {\n      var valid = utils.verifyPPKMAC(ret, undefined, privateKey);\n      if (!valid)\n        throw new Error('PPK MAC mismatch');\n    }\n\n    // generate a PEM encoded version of the public key\n    var pubkey = utils.genPublicKey(ret);\n    ret.public = pubkey.public;\n    ret.publicOrig = pubkey.publicOrig;\n\n    ret.private = privateKey;\n\n    // automatically convert private key data to OpenSSL format (including PEM)\n    // if we don't need to wait for decryption\n    if (!ret.encryption)\n      utils.convertPPKPrivate(ret);\n  } else\n    return new Error('Unsupported key format');\n\n  return ret;\n};\n","// TODO: * Automatic re-key every (configurable) n bytes or length of time\n//         - RFC suggests every 1GB of transmitted data or 1 hour, whichever\n//           comes sooner\n//       * Filter control codes from strings\n//         (as per http://tools.ietf.org/html/rfc4251#section-9.2)\n\nvar crypto = require('crypto');\nvar zlib = require('zlib');\nvar TransformStream = require('stream').Transform;\nvar inherits = require('util').inherits;\nvar inspect = require('util').inspect;\nvar BUFFER_MAX_LEN = require('buffer').kMaxLength;\n\nvar StreamSearch = require('streamsearch');\n\nvar consts = require('./constants');\nvar utils = require('./utils');\nvar isStreamCipher = utils.isStreamCipher;\nvar iv_inc = utils.iv_inc;\nvar readString = utils.readString;\nvar readInt = utils.readInt;\nvar DSASigBERToBare = utils.DSASigBERToBare;\nvar DSASigBareToBER = utils.DSASigBareToBER;\nvar ECDSASigSSHToASN1 = utils.ECDSASigSSHToASN1;\nvar ECDSASigASN1ToSSH = utils.ECDSASigASN1ToSSH;\nvar RSAKeySSHToASN1 = utils.RSAKeySSHToASN1;\nvar DSAKeySSHToASN1 = utils.DSAKeySSHToASN1;\nvar ECDSAKeySSHToASN1 = utils.ECDSAKeySSHToASN1;\n\nvar MESSAGE = consts.MESSAGE;\nvar DYNAMIC_KEXDH_MESSAGE = consts.DYNAMIC_KEXDH_MESSAGE;\nvar KEXDH_MESSAGE = consts.KEXDH_MESSAGE;\nvar ALGORITHMS = consts.ALGORITHMS;\nvar DISCONNECT_REASON = consts.DISCONNECT_REASON;\nvar CHANNEL_OPEN_FAILURE = consts.CHANNEL_OPEN_FAILURE;\nvar SSH_TO_OPENSSL = consts.SSH_TO_OPENSSL;\nvar TERMINAL_MODE = consts.TERMINAL_MODE;\nvar SIGNALS = consts.SIGNALS;\nvar BUGS = consts.BUGS;\nvar BUGGY_IMPLS = consts.BUGGY_IMPLS;\nvar BUGGY_IMPLS_LEN = BUGGY_IMPLS.length;\nvar MODULE_VER = require('../package.json').version;\nvar I = 0;\nvar IN_INIT = I++;\nvar IN_GREETING = I++;\nvar IN_HEADER = I++;\nvar IN_PACKETBEFORE = I++;\nvar IN_PACKET = I++;\nvar IN_PACKETDATA = I++;\nvar IN_PACKETDATAVERIFY = I++;\nvar IN_PACKETDATAAFTER = I++;\nvar OUT_INIT = I++;\nvar OUT_READY = I++;\nvar OUT_REKEYING = I++;\nvar MAX_SEQNO = 4294967295;\nvar MAX_PACKET_SIZE = 35000;\nvar MAX_PACKETS_REKEYING = 50;\nvar EXP_TYPE_HEADER = 0;\nvar EXP_TYPE_LF = 1;\nvar EXP_TYPE_BYTES = 2; // Waits until n bytes have been seen\nvar Z_PARTIAL_FLUSH = zlib.Z_PARTIAL_FLUSH;\nvar ZLIB_OPTS = { flush: Z_PARTIAL_FLUSH };\n\nvar RE_KEX_HASH = /-(.+)$/;\nvar RE_GEX = /^gex-/;\nvar RE_NULL = /\\x00/g;\nvar RE_GCM = /^aes\\d+-gcm/i;\n\nvar IDENT_PREFIX_BUFFER = new Buffer('SSH-');\nvar EMPTY_BUFFER = new Buffer(0);\nvar PING_PACKET = new Buffer([\n  MESSAGE.GLOBAL_REQUEST,\n  // \"keepalive@openssh.com\"\n  0, 0, 0, 21,\n    107, 101, 101, 112, 97, 108, 105, 118, 101, 64, 111, 112, 101, 110, 115,\n    115, 104, 46, 99, 111, 109,\n  // Request a reply\n  1\n]);\nvar NEWKEYS_PACKET = new Buffer([MESSAGE.NEWKEYS]);\nvar USERAUTH_SUCCESS_PACKET = new Buffer([MESSAGE.USERAUTH_SUCCESS]);\nvar REQUEST_SUCCESS_PACKET = new Buffer([MESSAGE.REQUEST_SUCCESS]);\nvar REQUEST_FAILURE_PACKET = new Buffer([MESSAGE.REQUEST_FAILURE]);\nvar NO_TERMINAL_MODES_BUFFER = new Buffer([TERMINAL_MODE.TTY_OP_END]);\nvar KEXDH_GEX_REQ_PACKET = new Buffer([\n  MESSAGE.KEXDH_GEX_REQUEST,\n  // Minimal size in bits of an acceptable group\n  0, 0, 4, 0, // 1024, modp2\n  // Preferred size in bits of the group the server will send\n  0, 0, 16, 0, // 4096, modp16\n  // Maximal size in bits of an acceptable group\n  0, 0, 32, 0 // 8192, modp18\n]);\n\nfunction DEBUG_NOOP(msg) {}\n\nfunction SSH2Stream(cfg) {\n  if (typeof cfg !== 'object' || cfg === null)\n    cfg = {};\n\n  TransformStream.call(this, {\n    highWaterMark: (typeof cfg.highWaterMark === 'number'\n                    ? cfg.highWaterMark\n                    : 32 * 1024)\n  });\n\n  this._needContinue = false;\n  this.bytesSent = this.bytesReceived = 0;\n  this.debug = (typeof cfg.debug === 'function' ? cfg.debug : DEBUG_NOOP);\n  this.server = (cfg.server === true);\n  this.maxPacketSize = (typeof cfg.maxPacketSize === 'number'\n                        ? cfg.maxPacketSize\n                        : MAX_PACKET_SIZE);\n  // Bitmap that indicates any bugs the remote side has. This is determined\n  // by the reported software version.\n  this.remoteBugs = 0;\n\n  if (this.server) {\n    // TODO: Remove when we support group exchange for server implementation\n    this.remoteBugs = BUGS.BAD_DHGEX;\n  }\n\n  var self = this;\n\n  var hostKeys = cfg.hostKeys;\n  if (this.server && (typeof hostKeys !== 'object' || hostKeys === null))\n    throw new Error('hostKeys must be an object keyed on host key type');\n\n  this.config = {\n    // Server\n    hostKeys: hostKeys, // All keys supported by server\n\n    // Client/Server\n    ident: 'SSH-2.0-'\n           + (cfg.ident\n              || ('ssh2js' + MODULE_VER + (this.server ? 'srv' : ''))),\n    algorithms: {\n      kex: ALGORITHMS.KEX,\n      kexBuf: ALGORITHMS.KEX_BUF,\n      serverHostKey: ALGORITHMS.SERVER_HOST_KEY,\n      serverHostKeyBuf: ALGORITHMS.SERVER_HOST_KEY_BUF,\n      cipher: ALGORITHMS.CIPHER,\n      cipherBuf: ALGORITHMS.CIPHER_BUF,\n      hmac: ALGORITHMS.HMAC,\n      hmacBuf: ALGORITHMS.HMAC_BUF,\n      compress: ALGORITHMS.COMPRESS,\n      compressBuf: ALGORITHMS.COMPRESS_BUF\n    }\n  };\n  // RFC 4253 states the identification string must not contain NULL\n  this.config.ident.replace(RE_NULL, '');\n\n  if (this.config.ident.length + 2 /* Account for \"\\r\\n\" */ > 255)\n    throw new Error('ident too long');\n\n  if (typeof cfg.algorithms === 'object' && cfg.algorithms !== null) {\n    var algos = cfg.algorithms;\n    if (Array.isArray(algos.kex) && algos.kex.length > 0) {\n      this.config.algorithms.kex = algos.kex;\n      if (!Buffer.isBuffer(algos.kexBuf))\n        algos.kexBuf = new Buffer(algos.kex.join(','), 'ascii');\n      this.config.algorithms.kexBuf = algos.kexBuf;\n    }\n    if (Array.isArray(algos.serverHostKey) && algos.serverHostKey.length > 0) {\n      this.config.algorithms.serverHostKey = algos.serverHostKey;\n      if (!Buffer.isBuffer(algos.serverHostKeyBuf)) {\n        algos.serverHostKeyBuf = new Buffer(algos.serverHostKey.join(','),\n                                            'ascii');\n      }\n      this.config.algorithms.serverHostKeyBuf = algos.serverHostKeyBuf;\n    }\n    if (Array.isArray(algos.cipher) && algos.cipher.length > 0) {\n      this.config.algorithms.cipher = algos.cipher;\n      if (!Buffer.isBuffer(algos.cipherBuf))\n        algos.cipherBuf = new Buffer(algos.cipher.join(','), 'ascii');\n      this.config.algorithms.cipherBuf = algos.cipherBuf;\n    }\n    if (Array.isArray(algos.hmac) && algos.hmac.length > 0) {\n      this.config.algorithms.hmac = algos.hmac;\n      if (!Buffer.isBuffer(algos.hmacBuf))\n        algos.hmacBuf = new Buffer(algos.hmac.join(','), 'ascii');\n      this.config.algorithms.hmacBuf = algos.hmacBuf;\n    }\n    if (Array.isArray(algos.compress) && algos.compress.length > 0) {\n      this.config.algorithms.compress = algos.compress;\n      if (!Buffer.isBuffer(algos.compressBuf))\n        algos.compressBuf = new Buffer(algos.compress.join(','), 'ascii');\n      this.config.algorithms.compressBuf = algos.compressBuf;\n    }\n  }\n\n  this.reset(true);\n\n  // Common events\n  this.on('end', function() {\n    // Let GC collect any Buffers we were previously storing\n    self._state = undefined;\n    self.reset();\n    self._state.incoming.hmac.bufCompute = undefined;\n    self._state.outgoing.bufSeqno = undefined;\n  });\n  this.on('DISCONNECT', function(reason, code, desc, lang) {\n    onDISCONNECT(self, reason, code, desc, lang);\n  });\n  this.on('KEXINIT', function(init, firstFollows) {\n    onKEXINIT(self, init, firstFollows);\n  });\n  this.on('NEWKEYS', function() { onNEWKEYS(self); });\n\n  if (this.server) {\n    // Server-specific events\n    this.on('KEXDH_INIT', function(e) { onKEXDH_INIT(self, e); });\n  } else {\n    // Client-specific events\n    this.on('KEXDH_REPLY', function(info) { onKEXDH_REPLY(self, info); })\n        .on('KEXDH_GEX_GROUP',\n            function(prime, gen) { onKEXDH_GEX_GROUP(self, prime, gen); });\n  }\n\n  if (this.server) {\n    // Greeting displayed before the ssh identification string is sent, this is\n    // usually ignored by most clients\n    if (typeof cfg.greeting === 'string' && cfg.greeting.length) {\n      if (cfg.greeting.slice(-2) === '\\r\\n')\n        this.push(cfg.greeting);\n      else\n        this.push(cfg.greeting + '\\r\\n');\n    }\n    // Banner shown after the handshake completes, but before user\n    // authentication begins\n    if (typeof cfg.banner === 'string' && cfg.banner.length) {\n      if (cfg.banner.slice(-2) === '\\r\\n')\n        this.banner = cfg.banner;\n      else\n        this.banner = cfg.banner + '\\r\\n';\n    }\n  }\n  this.debug('DEBUG: Local ident: ' + inspect(this.config.ident));\n  this.push(this.config.ident + '\\r\\n');\n\n  this._state.incoming.expectedPacket = 'KEXINIT';\n}\ninherits(SSH2Stream, TransformStream);\n\nSSH2Stream.prototype.__read = TransformStream.prototype._read;\nSSH2Stream.prototype._read = function(n) {\n  if (this._needContinue) {\n    this._needContinue = false;\n    this.emit('continue');\n  }\n  return this.__read(n);\n};\nSSH2Stream.prototype.__push = TransformStream.prototype.push;\nSSH2Stream.prototype.push = function(chunk, encoding) {\n  var ret = this.__push(chunk, encoding);\n  this._needContinue = (ret === false);\n  return ret;\n};\n\nSSH2Stream.prototype._cleanup = function(callback) {\n  this.reset();\n  this.debug('DEBUG: Parser: Malformed packet');\n  callback && callback(new Error('Malformed packet'));\n};\n\nSSH2Stream.prototype._transform = function(chunk, encoding, callback, decomp) {\n  var skipDecrypt = false;\n  var doDecryptGCM = false;\n  var state = this._state;\n  var instate = state.incoming;\n  var outstate = state.outgoing;\n  var expect = instate.expect;\n  var decrypt = instate.decrypt;\n  var decompress = instate.decompress;\n  var chlen = chunk.length;\n  var chleft = 0;\n  var debug = this.debug;\n  var self = this;\n  var i = 0;\n  var p = i;\n  var buffer;\n  var buf;\n  var r;\n\n  this.bytesReceived += chlen;\n\n  while (true) {\n    if (expect.type !== undefined) {\n      if (i >= chlen)\n        break;\n      if (expect.type === EXP_TYPE_BYTES) {\n        chleft = (chlen - i);\n        var pktLeft = (expect.buf.length - expect.ptr);\n        if (pktLeft <= chleft) {\n          chunk.copy(expect.buf, expect.ptr, i, i + pktLeft);\n          i += pktLeft;\n          buffer = expect.buf;\n          expect.buf = undefined;\n          expect.ptr = 0;\n          expect.type = undefined;\n        } else {\n          chunk.copy(expect.buf, expect.ptr, i);\n          expect.ptr += chleft;\n          i += chleft;\n        }\n        continue;\n      } else if (expect.type === EXP_TYPE_HEADER) {\n        i += instate.search.push(chunk);\n        if (expect.type !== undefined)\n          continue;\n      } else if (expect.type === EXP_TYPE_LF) {\n        if (++expect.ptr + 4 /* Account for \"SSH-\" */ > 255) {\n          this.reset();\n          debug('DEBUG: Parser: Identification string exceeded 255 characters');\n          return callback(new Error('Max identification string size exceeded'));\n        }\n        if (chunk[i] === 0x0A) {\n          expect.type = undefined;\n          if (p < i) {\n            if (expect.buf === undefined)\n              expect.buf = chunk.toString('ascii', p, i);\n            else\n              expect.buf += chunk.toString('ascii', p, i);\n          }\n          buffer = expect.buf;\n          expect.buf = undefined;\n          ++i;\n        } else {\n          if (++i === chlen && p < i) {\n            if (expect.buf === undefined)\n              expect.buf = chunk.toString('ascii', p, i);\n            else\n              expect.buf += chunk.toString('ascii', p, i);\n          }\n          continue;\n        }\n      }\n    }\n\n    if (instate.status === IN_INIT) {\n      if (this.server) {\n        // Retrieve what should be the start of the protocol version exchange\n        if (!buffer) {\n          debug('DEBUG: Parser: IN_INIT (waiting for identification begin)');\n          expectData(this, EXP_TYPE_BYTES, 4);\n        } else {\n          if (buffer[0] === 0x53       // S\n              && buffer[1] === 0x53    // S\n              && buffer[2] === 0x48    // H\n              && buffer[3] === 0x2D) { // -\n            instate.status = IN_GREETING;\n            debug('DEBUG: Parser: IN_INIT (waiting for rest of identification)');\n          } else {\n            this.reset();\n            debug('DEBUG: Parser: Bad identification start');\n            return callback(new Error('Bad identification start'));\n          }\n        }\n      } else {\n        debug('DEBUG: Parser: IN_INIT');\n        // Retrieve any bytes that may come before the protocol version exchange\n        var ss = instate.search = new StreamSearch(IDENT_PREFIX_BUFFER);\n        ss.on('info', function onInfo(matched, data, start, end) {\n          if (data) {\n            if (instate.greeting === undefined)\n              instate.greeting = data.toString('binary', start, end);\n            else\n              instate.greeting += data.toString('binary', start, end);\n          }\n          if (matched) {\n            expect.type = undefined;\n            instate.search.removeListener('info', onInfo);\n          }\n        });\n        ss.maxMatches = 1;\n        expectData(this, EXP_TYPE_HEADER);\n        instate.status = IN_GREETING;\n      }\n    } else if (instate.status === IN_GREETING) {\n      debug('DEBUG: Parser: IN_GREETING');\n      instate.search = undefined;\n      // Retrieve the identification bytes after the \"SSH-\" header\n      p = i;\n      expectData(this, EXP_TYPE_LF);\n      instate.status = IN_HEADER;\n    } else if (instate.status === IN_HEADER) {\n      debug('DEBUG: Parser: IN_HEADER');\n      if (buffer.charCodeAt(buffer.length - 1) === 13)\n        buffer = buffer.slice(0, -1);\n      var idxDash = buffer.indexOf('-');\n      var idxSpace = buffer.indexOf(' ');\n      var header = {\n        // RFC says greeting SHOULD be utf8\n        greeting: instate.greeting,\n        identRaw: 'SSH-' + buffer,\n        versions: {\n          protocol: buffer.substr(0, idxDash),\n          software: (idxSpace === -1\n                     ? buffer.substring(idxDash + 1)\n                     : buffer.substring(idxDash + 1, idxSpace))\n        },\n        comments: (idxSpace > -1 ? buffer.substring(idxSpace + 1) : undefined)\n      };\n      instate.greeting = undefined;\n\n      if (header.versions.protocol !== '1.99'\n          && header.versions.protocol !== '2.0') {\n        this.reset();\n        debug('DEBUG: Parser: protocol version not supported: '\n              + header.versions.protocol);\n        return callback(new Error('Protocol version not supported'));\n      } else\n        this.emit('header', header);\n\n      if (instate.status === IN_INIT) {\n        // We reset from an event handler, possibly due to an unsupported SSH\n        // protocol version?\n        return;\n      }\n\n      var identRaw = header.identRaw;\n      var software = header.versions.software;\n      this.debug('DEBUG: Remote ident: ' + inspect(identRaw));\n      for (var j = 0, rule; j < BUGGY_IMPLS_LEN; ++j) {\n        rule = BUGGY_IMPLS[j];\n        if (typeof rule[0] === 'string') {\n          if (software === rule[0])\n            this.remoteBugs |= rule[1];\n        } else if (rule[0].test(software))\n          this.remoteBugs |= rule[1];\n      }\n      instate.identRaw = identRaw;\n      // Adjust bytesReceived first otherwise it will have an incorrectly larger\n      // total when we call back into this function after completing KEXINIT\n      this.bytesReceived -= (chlen - i);\n      KEXINIT(this, function() {\n        if (i === chlen)\n          callback();\n        else\n          self._transform(chunk.slice(i), encoding, callback);\n      });\n      instate.status = IN_PACKETBEFORE;\n      return;\n    } else if (instate.status === IN_PACKETBEFORE) {\n      debug('DEBUG: Parser: IN_PACKETBEFORE (expecting ' + decrypt.size + ')');\n      // Wait for the right number of bytes so we can determine the incoming\n      // packet length\n      expectData(this, EXP_TYPE_BYTES, decrypt.size, decrypt.buf);\n      instate.status = IN_PACKET;\n    } else if (instate.status === IN_PACKET) {\n      debug('DEBUG: Parser: IN_PACKET');\n      doDecryptGCM = (decrypt.instance && decrypt.isGCM);\n      if (decrypt.instance && !decrypt.isGCM)\n        buffer = decryptData(this, buffer);\n\n      r = readInt(buffer, 0, this, callback);\n      if (r === false)\n        return;\n      var macSize = (instate.hmac.size || 0);\n      var fullPacketLen = r + 4 + macSize;\n      var maxPayloadLen = this.maxPacketSize;\n      if (decompress.instance) {\n        // Account for compressed payloads\n        // This formula is taken from dropbear which derives it from zlib's\n        // documentation. Explanation from dropbear:\n        /* For exact details see http://www.zlib.net/zlib_tech.html\n         * 5 bytes per 16kB block, plus 6 bytes for the stream.\n         * We might allocate 5 unnecessary bytes here if it's an\n         * exact multiple. */\n        maxPayloadLen += (((this.maxPacketSize / 16384) + 1) * 5 + 6);\n      }\n      if (r > maxPayloadLen\n          // TODO: Change 16 to \"MAX(16, decrypt.size)\" when/if SSH2 adopts\n          // 512-bit ciphers\n          || fullPacketLen < (16 + macSize)\n          || ((r + (doDecryptGCM ? 0 : 4)) % decrypt.size) !== 0) {\n        this.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n        debug('DEBUG: Parser: Bad packet length (' + fullPacketLen + ')');\n        return callback(new Error('Bad packet length'));\n      }\n\n      instate.pktLen = r;\n      var remainLen = instate.pktLen + 4 - decrypt.size;\n      if (doDecryptGCM) {\n        decrypt.instance.setAAD(buffer.slice(0, 4));\n        debug('DEBUG: Parser: pktLen:'\n              + instate.pktLen\n              + ',remainLen:'\n              + remainLen);\n      } else {\n        instate.padLen = buffer[4];\n        debug('DEBUG: Parser: pktLen:'\n              + instate.pktLen\n              + ',padLen:'\n              + instate.padLen\n              + ',remainLen:'\n              + remainLen);\n      }\n      if (remainLen > 0) {\n        if (doDecryptGCM)\n          instate.pktExtra = buffer.slice(4);\n        else\n          instate.pktExtra = buffer.slice(5);\n        // Grab the rest of the packet\n        expectData(this, EXP_TYPE_BYTES, remainLen);\n        instate.status = IN_PACKETDATA;\n      } else if (remainLen < 0)\n        instate.status = IN_PACKETBEFORE;\n      else {\n        // Entire message fit into one block\n        skipDecrypt = true;\n        instate.status = IN_PACKETDATA;\n        continue;\n      }\n    } else if (instate.status === IN_PACKETDATA) {\n      debug('DEBUG: Parser: IN_PACKETDATA');\n      doDecryptGCM = (decrypt.instance && decrypt.isGCM);\n      if (decrypt.instance && !skipDecrypt && !doDecryptGCM)\n        buffer = decryptData(this, buffer);\n      else if (skipDecrypt)\n        skipDecrypt = false;\n      var padStart = instate.pktLen - instate.padLen - 1;\n      // TODO: Allocate a Buffer once that is slightly larger than maxPacketSize\n      // (to accommodate for packet length field and MAC) and re-use that\n      // instead\n      if (instate.pktExtra) {\n        buf = new Buffer(instate.pktExtra.length + buffer.length);\n        instate.pktExtra.copy(buf);\n        buffer.copy(buf, instate.pktExtra.length);\n        instate.payload = buf.slice(0, padStart);\n      } else {\n        // Entire message fit into one block\n        if (doDecryptGCM)\n          buf = buffer.slice(4);\n        else\n          buf = buffer.slice(5);\n        instate.payload = buffer.slice(5, 5 + padStart);\n      }\n      if (instate.hmac.size !== undefined) {\n        // Wait for hmac hash\n        debug('DEBUG: Parser: HMAC size:' + instate.hmac.size);\n        expectData(this, EXP_TYPE_BYTES, instate.hmac.size, instate.hmac.buf);\n        instate.status = IN_PACKETDATAVERIFY;\n        instate.packet = buf;\n      } else\n        instate.status = IN_PACKETDATAAFTER;\n      instate.pktExtra = undefined;\n      buf = undefined;\n    } else if (instate.status === IN_PACKETDATAVERIFY) {\n      debug('DEBUG: Parser: IN_PACKETDATAVERIFY');\n      // Verify packet data integrity\n      if (hmacVerify(this, buffer)) {\n        debug('DEBUG: Parser: IN_PACKETDATAVERIFY (Valid HMAC)');\n        instate.status = IN_PACKETDATAAFTER;\n        instate.packet = undefined;\n      } else {\n        this.reset();\n        debug('DEBUG: Parser: IN_PACKETDATAVERIFY (Invalid HMAC)');\n        return callback(new Error('Invalid HMAC'));\n      }\n    } else if (instate.status === IN_PACKETDATAAFTER) {\n      if (decompress.instance) {\n        if (!decomp) {\n          debug('DEBUG: Parser: Decompressing');\n          decompress.instance.write(instate.payload);\n          var decompBuf = [];\n          var decompBufLen = 0;\n          decompress.instance.on('readable', function() {\n            var buf;\n            while (buf = this.read()) {\n              decompBuf.push(buf);\n              decompBufLen += buf.length;\n            }\n          }).flush(Z_PARTIAL_FLUSH, function() {\n            decompress.instance.removeAllListeners('readable');\n            if (decompBuf.length === 1)\n              instate.payload = decompBuf[0];\n            else\n              instate.payload = Buffer.concat(decompBuf, decompBufLen);\n            decompBuf = null;\n            var nextSlice;\n            if (i === chlen)\n              nextSlice = EMPTY_BUFFER; // Avoid slicing a zero-length buffer\n            else\n              nextSlice = chunk.slice(i);\n            self._transform(nextSlice, encoding, callback, true);\n          });\n          return;\n        } else {\n          // Make sure we reset this after this first time in the loop,\n          // otherwise we could end up trying to interpret as-is another\n          // compressed packet that is within the same chunk\n          decomp = false;\n        }\n      }\n\n      this.emit('packet');\n\n      var ptype = instate.payload[0];\n\n      if (debug !== DEBUG_NOOP) {\n        var msgPacket = 'DEBUG: Parser: IN_PACKETDATAAFTER, packet: ';\n        var kexdh = state.kexdh;\n        var authMethod = state.authsQueue[0];\n        var msgPktType = null;\n\n        if (outstate.status === OUT_REKEYING\n            && !(ptype <= 4 || (ptype >= 20 && ptype <= 49)))\n          msgPacket += '(enqueued) ';\n\n        if (ptype === MESSAGE.KEXDH_INIT) {\n          if (kexdh === 'group')\n            msgPktType = 'KEXDH_INIT';\n          else if (kexdh[0] === 'e')\n            msgPktType = 'KEXECDH_INIT';\n          else\n            msgPktType = 'KEXDH_GEX_REQUEST';\n        } else if (ptype === MESSAGE.KEXDH_REPLY) {\n          if (kexdh === 'group')\n            msgPktType = 'KEXDH_REPLY';\n          else if (kexdh[0] === 'e')\n            msgPktType = 'KEXECDH_REPLY';\n          else\n            msgPktType = 'KEXDH_GEX_GROUP';\n        } else if (ptype === MESSAGE.KEXDH_GEX_GROUP)\n          msgPktType = 'KEXDH_GEX_GROUP';\n        else if (ptype === MESSAGE.KEXDH_GEX_REPLY)\n          msgPktType = 'KEXDH_GEX_REPLY';\n        else if (ptype === 60) {\n          if (authMethod === 'password')\n            msgPktType = 'USERAUTH_PASSWD_CHANGEREQ';\n          else if (authMethod === 'keyboard-interactive')\n            msgPktType = 'USERAUTH_INFO_REQUEST';\n          else if (authMethod === 'publickey')\n            msgPktType = 'USERAUTH_PK_OK';\n          else\n            msgPktType = 'UNKNOWN PACKET 60';\n        } else if (ptype === 61) {\n          if (authMethod === 'keyboard-interactive')\n            msgPktType = 'USERAUTH_INFO_RESPONSE';\n          else\n            msgPktType = 'UNKNOWN PACKET 61';\n        }\n\n        if (msgPktType === null)\n          msgPktType = MESSAGE[ptype];\n\n        // Don't write debug output for messages we custom make in parsePacket()\n        if (ptype !== MESSAGE.CHANNEL_OPEN\n            && ptype !== MESSAGE.CHANNEL_REQUEST\n            && ptype !== MESSAGE.CHANNEL_SUCCESS\n            && ptype !== MESSAGE.CHANNEL_FAILURE\n            && ptype !== MESSAGE.CHANNEL_EOF\n            && ptype !== MESSAGE.CHANNEL_CLOSE\n            && ptype !== MESSAGE.CHANNEL_DATA\n            && ptype !== MESSAGE.CHANNEL_EXTENDED_DATA\n            && ptype !== MESSAGE.CHANNEL_WINDOW_ADJUST\n            && ptype !== MESSAGE.DISCONNECT\n            && ptype !== MESSAGE.USERAUTH_REQUEST\n            && ptype !== MESSAGE.GLOBAL_REQUEST)\n          debug(msgPacket + msgPktType);\n      }\n\n      // Only parse packet if we are not re-keying or the packet is not a\n      // transport layer packet needed for re-keying\n      if (outstate.status === OUT_READY\n          || ptype <= 4\n          || (ptype >= 20 && ptype <= 49)) {\n        if (parsePacket(this, callback) === false)\n          return;\n\n        if (instate.status === IN_INIT) {\n          // We were reset due to some error/disagreement ?\n          return;\n        }\n      } else if (outstate.status === OUT_REKEYING) {\n        if (instate.rekeyQueue.length === MAX_PACKETS_REKEYING) {\n          debug('DEBUG: Parser: Max incoming re-key queue length reached');\n          this.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n          return callback(\n            new Error('Incoming re-key queue length limit reached')\n          );\n        }\n\n        // Make sure to record the sequence number in case we need it later on\n        // when we drain the queue (e.g. unknown packet)\n        var seqno = instate.seqno;\n        if (++instate.seqno > MAX_SEQNO)\n          instate.seqno = 0;\n\n        instate.rekeyQueue.push(seqno, instate.payload);\n      }\n\n      instate.status = IN_PACKETBEFORE;\n      instate.payload = undefined;\n    }\n    if (buffer !== undefined)\n      buffer = undefined;\n  }\n\n  callback();\n};\n\nSSH2Stream.prototype.reset = function(noend) {\n  if (this._state) {\n    var state = this._state;\n    state.incoming.status = IN_INIT;\n    state.outgoing.status = OUT_INIT;\n  } else {\n    this._state = {\n      authsQueue: [],\n      hostkeyFormat: undefined,\n      kex: undefined,\n      kexdh: undefined,\n\n      incoming: {\n        status: IN_INIT,\n        expectedPacket: undefined,\n        search: undefined,\n        greeting: undefined,\n        seqno: 0,\n        pktLen: undefined,\n        padLen: undefined,\n        pktExtra: undefined,\n        payload: undefined,\n        packet: undefined,\n        kexinit: undefined,\n        identRaw: undefined,\n        rekeyQueue: [],\n        ignoreNext: false,\n\n        expect: {\n          amount: undefined,\n          type: undefined,\n          ptr: 0,\n          buf: undefined\n        },\n\n        decrypt: {\n          instance: false,\n          size: 8,\n          isGCM: false,\n          iv: undefined, // GCM\n          key: undefined, // GCM\n          buf: undefined,\n          type: undefined\n        },\n\n        hmac: {\n          size: undefined,\n          key: undefined,\n          buf: undefined,\n          bufCompute: new Buffer(9),\n          type: false\n        },\n\n        decompress: {\n          instance: false,\n          type: false\n        }\n      },\n\n      outgoing: {\n        status: OUT_INIT,\n        seqno: 0,\n        bufSeqno: new Buffer(4),\n        rekeyQueue: [],\n        kexinit: undefined,\n        kexsecret: undefined,\n        pubkey: undefined,\n        exchangeHash: undefined,\n        sessionId: undefined,\n        sentNEWKEYS: false,\n\n        encrypt: {\n          instance: false,\n          size: 8,\n          isGCM: false,\n          iv: undefined, // GCM\n          key: undefined, // GCM\n          type: undefined\n        },\n\n        hmac: {\n          size: undefined,\n          key: undefined,\n          buf: undefined,\n          type: false\n        },\n\n        compress: {\n          instance: false,\n          type: false\n        }\n      }\n    };\n  }\n  if (!noend) {\n    if (this.readable)\n      this.push(null);\n  }\n};\n\n// Common methods\n// Global\nSSH2Stream.prototype.disconnect = function(reason) {\n  /*\n    byte      SSH_MSG_DISCONNECT\n    uint32    reason code\n    string    description in ISO-10646 UTF-8 encoding\n    string    language tag\n  */\n  var buf = new Buffer(1 + 4 + 4 + 4);\n\n  buf.fill(0);\n  buf[0] = MESSAGE.DISCONNECT;\n\n  if (DISCONNECT_REASON[reason] === undefined)\n    reason = DISCONNECT_REASON.BY_APPLICATION;\n  buf.writeUInt32BE(reason, 1, true);\n\n  this.debug('DEBUG: Outgoing: Writing DISCONNECT ('\n             + DISCONNECT_REASON[reason]\n             + ')');\n  send(this, buf);\n  this.reset();\n\n  return false;\n};\nSSH2Stream.prototype.ping = function() {\n  this.debug('DEBUG: Outgoing: Writing ping (GLOBAL_REQUEST: keepalive@openssh.com)');\n  return send(this, PING_PACKET);\n};\nSSH2Stream.prototype.rekey = function() {\n  var status = this._state.outgoing.status;\n  if (status === OUT_REKEYING)\n    throw new Error('A re-key is already in progress');\n  else if (status !== OUT_READY)\n    throw new Error('Cannot re-key yet');\n\n  this.debug('DEBUG: Outgoing: Starting re-key');\n  return KEXINIT(this);\n};\n\n// 'ssh-connection' service-specific\nSSH2Stream.prototype.requestSuccess = function(data) {\n  var buf;\n  if (Buffer.isBuffer(data)) {\n    buf = new Buffer(1 + data.length);\n\n    buf[0] = MESSAGE.REQUEST_SUCCESS;\n\n    data.copy(buf, 1);\n  } else\n    buf = REQUEST_SUCCESS_PACKET;\n\n  this.debug('DEBUG: Outgoing: Writing REQUEST_SUCCESS');\n  return send(this, buf);\n};\nSSH2Stream.prototype.requestFailure = function() {\n  this.debug('DEBUG: Outgoing: Writing REQUEST_FAILURE');\n  return send(this, REQUEST_FAILURE_PACKET);\n};\nSSH2Stream.prototype.channelSuccess = function(chan) {\n  // Does not consume window space\n  var buf = new Buffer(1 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_SUCCESS;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_SUCCESS (' + chan + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelFailure = function(chan) {\n  // Does not consume window space\n  var buf = new Buffer(1 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_FAILURE;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_FAILURE (' + chan + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelEOF = function(chan) {\n  // Does not consume window space\n  var buf = new Buffer(1 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_EOF;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_EOF (' + chan + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelClose = function(chan) {\n  // Does not consume window space\n  var buf = new Buffer(1 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_CLOSE;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_CLOSE (' + chan + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelWindowAdjust = function(chan, amount) {\n  // Does not consume window space\n  var buf = new Buffer(1 + 4 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_WINDOW_ADJUST;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(amount, 5, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_WINDOW_ADJUST ('\n             + chan\n             + ', '\n             + amount\n             + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelData = function(chan, data) {\n  var dataIsBuffer = Buffer.isBuffer(data);\n  var dataLen = (dataIsBuffer ? data.length : Buffer.byteLength(data));\n  var buf = new Buffer(1 + 4 + 4 + dataLen);\n\n  buf[0] = MESSAGE.CHANNEL_DATA;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(dataLen, 5, true);\n  if (dataIsBuffer)\n    data.copy(buf, 9);\n  else\n    buf.write(data, 9, dataLen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_DATA (' + chan + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelExtData = function(chan, data, type) {\n  var dataIsBuffer = Buffer.isBuffer(data);\n  var dataLen = (dataIsBuffer ? data.length : Buffer.byteLength(data));\n  var buf = new Buffer(1 + 4 + 4 + 4 + dataLen);\n\n  buf[0] = MESSAGE.CHANNEL_EXTENDED_DATA;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(type, 5, true);\n\n  buf.writeUInt32BE(dataLen, 9, true);\n  if (dataIsBuffer)\n    data.copy(buf, 13);\n  else\n    buf.write(data, 13, dataLen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_EXTENDED_DATA (' + chan + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelOpenConfirm = function(remoteChan, localChan,\n                                                   initWindow, maxPacket) {\n  var buf = new Buffer(1 + 4 + 4 + 4 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN_CONFIRMATION;\n\n  buf.writeUInt32BE(remoteChan, 1, true);\n\n  buf.writeUInt32BE(localChan, 5, true);\n\n  buf.writeUInt32BE(initWindow, 9, true);\n\n  buf.writeUInt32BE(maxPacket, 13, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN_CONFIRMATION (r:'\n             + remoteChan\n             + ', l:'\n             + localChan\n             + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelOpenFail = function(remoteChan, reason, desc,\n                                                lang) {\n  if (typeof desc !== 'string')\n    desc = '';\n  if (typeof lang !== 'string')\n    lang = '';\n\n  var descLen = Buffer.byteLength(desc);\n  var langLen = Buffer.byteLength(lang);\n  var p = 9;\n  var buf = new Buffer(1 + 4 + 4 + 4 + descLen + 4 + langLen);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN_FAILURE;\n\n  buf.writeUInt32BE(remoteChan, 1, true);\n\n  buf.writeUInt32BE(reason, 5, true);\n\n  buf.writeUInt32BE(descLen, p, true);\n  p += 4;\n  if (descLen) {\n    buf.write(desc, p, descLen, 'utf8');\n    p += descLen;\n  }\n\n  buf.writeUInt32BE(langLen, p, true);\n  if (langLen)\n    buf.write(lang, p += 4, langLen, 'ascii');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN_FAILURE ('\n             + remoteChan\n             + ')');\n  return send(this, buf);\n};\n\n// Client-specific methods\n// Global\nSSH2Stream.prototype.service = function(svcName) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var svcNameLen = Buffer.byteLength(svcName);\n  var buf = new Buffer(1 + 4 + svcNameLen);\n\n  buf[0] = MESSAGE.SERVICE_REQUEST;\n\n  buf.writeUInt32BE(svcNameLen, 1, true);\n  buf.write(svcName, 5, svcNameLen, 'ascii');\n\n  this.debug('DEBUG: Outgoing: Writing SERVICE_REQUEST (' + svcName + ')');\n  return send(this, buf);\n};\n// 'ssh-connection' service-specific\nSSH2Stream.prototype.tcpipForward = function(bindAddr, bindPort, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var addrlen = Buffer.byteLength(bindAddr);\n  var buf = new Buffer(1 + 4 + 13 + 1 + 4 + addrlen + 4);\n\n  buf[0] = MESSAGE.GLOBAL_REQUEST;\n\n  buf.writeUInt32BE(13, 1, true);\n  buf.write('tcpip-forward', 5, 13, 'ascii');\n\n  buf[18] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  buf.writeUInt32BE(addrlen, 19, true);\n  buf.write(bindAddr, 23, addrlen, 'ascii');\n\n  buf.writeUInt32BE(bindPort, 23 + addrlen, true);\n\n  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (tcpip-forward)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.cancelTcpipForward = function(bindAddr, bindPort,\n                                                   wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var addrlen = Buffer.byteLength(bindAddr);\n  var buf = new Buffer(1 + 4 + 20 + 1 + 4 + addrlen + 4);\n\n  buf[0] = MESSAGE.GLOBAL_REQUEST;\n\n  buf.writeUInt32BE(20, 1, true);\n  buf.write('cancel-tcpip-forward', 5, 20, 'ascii');\n\n  buf[25] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  buf.writeUInt32BE(addrlen, 26, true);\n  buf.write(bindAddr, 30, addrlen, 'ascii');\n\n  buf.writeUInt32BE(bindPort, 30 + addrlen, true);\n\n  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (cancel-tcpip-forward)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_streamLocalForward = function(socketPath,\n                                                           wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var pathlen = Buffer.byteLength(socketPath);\n  var buf = new Buffer(1 + 4 + 31 + 1 + 4 + pathlen);\n\n  buf[0] = MESSAGE.GLOBAL_REQUEST;\n\n  buf.writeUInt32BE(31, 1, true);\n  buf.write('streamlocal-forward@openssh.com', 5, 31, 'ascii');\n\n  buf[36] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  buf.writeUInt32BE(pathlen, 37, true);\n  buf.write(socketPath, 41, pathlen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (streamlocal-forward@openssh.com)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_cancelStreamLocalForward = function(socketPath,\n                                                                 wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var pathlen = Buffer.byteLength(socketPath);\n  var buf = new Buffer(1 + 4 + 38 + 1 + 4 + pathlen);\n\n  buf[0] = MESSAGE.GLOBAL_REQUEST;\n\n  buf.writeUInt32BE(38, 1, true);\n  buf.write('cancel-streamlocal-forward@openssh.com', 5, 38, 'ascii');\n\n  buf[43] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  buf.writeUInt32BE(pathlen, 44, true);\n  buf.write(socketPath, 48, pathlen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (cancel-streamlocal-forward@openssh.com)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.directTcpip = function(chan, initWindow, maxPacket, cfg) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var srclen = Buffer.byteLength(cfg.srcIP);\n  var dstlen = Buffer.byteLength(cfg.dstIP);\n  var p = 29;\n  var buf = new Buffer(1 + 4 + 12 + 4 + 4 + 4 + 4 + srclen + 4 + 4 + dstlen\n                       + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  buf.writeUInt32BE(12, 1, true);\n  buf.write('direct-tcpip', 5, 12, 'ascii');\n\n  buf.writeUInt32BE(chan, 17, true);\n\n  buf.writeUInt32BE(initWindow, 21, true);\n\n  buf.writeUInt32BE(maxPacket, 25, true);\n\n  buf.writeUInt32BE(dstlen, p, true);\n  buf.write(cfg.dstIP, p += 4, dstlen, 'ascii');\n\n  buf.writeUInt32BE(cfg.dstPort, p += dstlen, true);\n\n  buf.writeUInt32BE(srclen, p += 4, true);\n  buf.write(cfg.srcIP, p += 4, srclen, 'ascii');\n\n  buf.writeUInt32BE(cfg.srcPort, p += srclen, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', direct-tcpip)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_directStreamLocal = function(chan, initWindow,\n                                                          maxPacket, cfg) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var pathlen = Buffer.byteLength(cfg.socketPath);\n  var p = 47;\n  var buf = new Buffer(1 + 4 + 30 + 4 + 4 + 4 + 4 + pathlen + 4 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  buf.writeUInt32BE(30, 1, true);\n  buf.write('direct-streamlocal@openssh.com', 5, 30, 'ascii');\n\n  buf.writeUInt32BE(chan, 35, true);\n\n  buf.writeUInt32BE(initWindow, 39, true);\n\n  buf.writeUInt32BE(maxPacket, 43, true);\n\n  buf.writeUInt32BE(pathlen, p, true);\n  buf.write(cfg.socketPath, p += 4, pathlen, 'utf8');\n\n  // reserved fields (string and uint32)\n  buf.fill(0, buf.length - 8);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', direct-streamlocal@openssh.com)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_noMoreSessions = function(wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var buf = new Buffer(1 + 4 + 28 + 1);\n\n  buf[0] = MESSAGE.GLOBAL_REQUEST;\n\n  buf.writeUInt32BE(28, 1, true);\n  buf.write('no-more-sessions@openssh.com', 5, 28, 'ascii');\n\n  buf[33] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (no-more-sessions@openssh.com)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.session = function(chan, initWindow, maxPacket) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var buf = new Buffer(1 + 4 + 7 + 4 + 4 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  buf.writeUInt32BE(7, 1, true);\n  buf.write('session', 5, 7, 'ascii');\n\n  buf.writeUInt32BE(chan, 12, true);\n\n  buf.writeUInt32BE(initWindow, 16, true);\n\n  buf.writeUInt32BE(maxPacket, 20, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', session)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.windowChange = function(chan, rows, cols, height, width) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var buf = new Buffer(1 + 4 + 4 + 13 + 1 + 4 + 4 + 4 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(13, 5, true);\n  buf.write('window-change', 9, 13, 'ascii');\n\n  buf[22] = 0;\n\n  buf.writeUInt32BE(cols, 23, true);\n\n  buf.writeUInt32BE(rows, 27, true);\n\n  buf.writeUInt32BE(width, 31, true);\n\n  buf.writeUInt32BE(height, 35, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', window-change)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.pty = function(chan, rows, cols, height,\n                                    width, term, modes, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  if (!term || !term.length)\n    term = 'vt100';\n  if (modes\n      && !Buffer.isBuffer(modes)\n      && !Array.isArray(modes)\n      && typeof modes === 'object')\n    modes = modesToBytes(modes);\n  if (!modes || !modes.length)\n    modes = NO_TERMINAL_MODES_BUFFER;\n\n  var termLen = term.length;\n  var modesLen = modes.length;\n  var p = 21;\n  var buf = new Buffer(1 + 4 + 4 + 7 + 1 + 4 + termLen + 4 + 4 + 4 + 4 + 4\n                       + modesLen);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(7, 5, true);\n  buf.write('pty-req', 9, 7, 'ascii');\n\n  buf[16] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  buf.writeUInt32BE(termLen, 17, true);\n  buf.write(term, 21, termLen, 'utf8');\n\n  buf.writeUInt32BE(cols, p += termLen, true);\n\n  buf.writeUInt32BE(rows, p += 4, true);\n\n  buf.writeUInt32BE(width, p += 4, true);\n\n  buf.writeUInt32BE(height, p += 4, true);\n\n  buf.writeUInt32BE(modesLen, p += 4, true);\n  p += 4;\n  if (Array.isArray(modes)) {\n    for (var i = 0; i < modesLen; ++i)\n      buf[p++] = modes[i];\n  } else if (Buffer.isBuffer(modes)) {\n    modes.copy(buf, p);\n  }\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', pty-req)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.shell = function(chan, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var buf = new Buffer(1 + 4 + 4 + 5 + 1);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(5, 5, true);\n  buf.write('shell', 9, 5, 'ascii');\n\n  buf[14] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', shell)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.exec = function(chan, cmd, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var cmdlen = (Buffer.isBuffer(cmd) ? cmd.length : Buffer.byteLength(cmd));\n  var buf = new Buffer(1 + 4 + 4 + 4 + 1 + 4 + cmdlen);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(4, 5, true);\n  buf.write('exec', 9, 4, 'ascii');\n\n  buf[13] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  buf.writeUInt32BE(cmdlen, 14, true);\n  if (Buffer.isBuffer(cmd))\n    cmd.copy(buf, 18);\n  else\n    buf.write(cmd, 18, cmdlen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', exec)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.signal = function(chan, signal) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  signal = signal.toUpperCase();\n  if (signal.slice(0, 3) === 'SIG')\n    signal = signal.substring(3);\n\n  if (SIGNALS.indexOf(signal) === -1)\n    throw new Error('Invalid signal: ' + signal);\n\n  var signalLen = signal.length;\n  var buf = new Buffer(1 + 4 + 4 + 6 + 1 + 4 + signalLen);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(6, 5, true);\n  buf.write('signal', 9, 6, 'ascii');\n\n  buf[15] = 0;\n\n  buf.writeUInt32BE(signalLen, 16, true);\n  buf.write(signal, 20, signalLen, 'ascii');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', signal)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.env = function(chan, key, val, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var keyLen = Buffer.byteLength(key);\n  var valLen = (Buffer.isBuffer(val) ? val.length : Buffer.byteLength(val));\n  var buf = new Buffer(1 + 4 + 4 + 3 + 1 + 4 + keyLen + 4 + valLen);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(3, 5, true);\n  buf.write('env', 9, 3, 'ascii');\n\n  buf[12] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  buf.writeUInt32BE(keyLen, 13, true);\n  buf.write(key, 17, keyLen, 'ascii');\n\n  buf.writeUInt32BE(valLen, 17 + keyLen, true);\n  if (Buffer.isBuffer(val))\n    val.copy(buf, 17 + keyLen + 4);\n  else\n    buf.write(val, 17 + keyLen + 4, valLen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', env)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.x11Forward = function(chan, cfg, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var protolen = Buffer.byteLength(cfg.protocol);\n  var cookielen = Buffer.byteLength(cfg.cookie);\n  var buf = new Buffer(1 + 4 + 4 + 7 + 1 + 1 + 4 + protolen + 4 + cookielen\n                       + 4);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(7, 5, true);\n  buf.write('x11-req', 9, 7, 'ascii');\n\n  buf[16] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  buf[17] = (cfg.single ? 1 : 0);\n\n  buf.writeUInt32BE(protolen, 18, true);\n  var bp = 22;\n  if (Buffer.isBuffer(cfg.protocol))\n    cfg.protocol.copy(buf, bp);\n  else\n    buf.write(cfg.protocol, bp, protolen, 'utf8');\n  bp += protolen;\n\n  buf.writeUInt32BE(cookielen, bp, true);\n  bp += 4;\n  if (Buffer.isBuffer(cfg.cookie))\n    cfg.cookie.copy(buf, bp);\n  else\n    buf.write(cfg.cookie, bp, cookielen, 'utf8');\n  bp += cookielen;\n\n  buf.writeUInt32BE((cfg.screen || 0), bp, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', x11-req)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.subsystem = function(chan, name, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var nameLen = Buffer.byteLength(name);\n  var buf = new Buffer(1 + 4 + 4 + 9 + 1 + 4 + nameLen);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(9, 5, true);\n  buf.write('subsystem', 9, 9, 'ascii');\n\n  buf[18] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  buf.writeUInt32BE(nameLen, 19, true);\n  buf.write(name, 23, nameLen, 'ascii');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', subsystem: '\n             + name\n             + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_agentForward = function(chan, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var buf = new Buffer(1 + 4 + 4 + 26 + 1);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(26, 5, true);\n  buf.write('auth-agent-req@openssh.com', 9, 26, 'ascii');\n\n  buf[35] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', auth-agent-req@openssh.com)');\n  return send(this, buf);\n};\n// 'ssh-userauth' service-specific\nSSH2Stream.prototype.authPassword = function(username, password) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var userLen = Buffer.byteLength(username);\n  var passLen = Buffer.byteLength(password);\n  var p = 0;\n  var buf = new Buffer(1\n                       + 4 + userLen\n                       + 4 + 14 // \"ssh-connection\"\n                       + 4 + 8 // \"password\"\n                       + 1\n                       + 4 + passLen);\n\n  buf[p] = MESSAGE.USERAUTH_REQUEST;\n\n  buf.writeUInt32BE(userLen, ++p, true);\n  buf.write(username, p += 4, userLen, 'utf8');\n\n  buf.writeUInt32BE(14, p += userLen, true);\n  buf.write('ssh-connection', p += 4, 14, 'ascii');\n\n  buf.writeUInt32BE(8, p += 14, true);\n  buf.write('password', p += 4, 8, 'ascii');\n\n  buf[p += 8] = 0;\n\n  buf.writeUInt32BE(passLen, ++p, true);\n  buf.write(password, p += 4, passLen, 'utf8');\n\n  this._state.authsQueue.push('password');\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (password)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.authPK = function(username, pubKey, cbSign) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var self = this;\n  var outstate = this._state.outgoing;\n  var pubKeyFullType;\n\n  if (pubKey.public) {\n    pubKeyFullType = pubKey.fulltype;\n    pubKey = pubKey.public;\n  } else {\n    pubKeyFullType = pubKey.toString('ascii',\n                                     4,\n                                     4 + pubKey.readUInt32BE(0, true));\n  }\n\n  var userLen = Buffer.byteLength(username);\n  var algoLen = Buffer.byteLength(pubKeyFullType);\n  var pubKeyLen = pubKey.length;\n  var sesLen = outstate.sessionId.length;\n  var p = 0;\n  var buf = new Buffer((cbSign ? 4 + sesLen : 0)\n                       + 1\n                       + 4 + userLen\n                       + 4 + 14 // \"ssh-connection\"\n                       + 4 + 9 // \"publickey\"\n                       + 1\n                       + 4 + algoLen\n                       + 4 + pubKeyLen\n                      );\n\n  if (cbSign) {\n    buf.writeUInt32BE(sesLen, p, true);\n    outstate.sessionId.copy(buf, p += 4);\n    buf[p += sesLen] = MESSAGE.USERAUTH_REQUEST;\n  } else\n    buf[p] = MESSAGE.USERAUTH_REQUEST;\n\n  buf.writeUInt32BE(userLen, ++p, true);\n  buf.write(username, p += 4, userLen, 'utf8');\n\n  buf.writeUInt32BE(14, p += userLen, true);\n  buf.write('ssh-connection', p += 4, 14, 'ascii');\n\n  buf.writeUInt32BE(9, p += 14, true);\n  buf.write('publickey', p += 4, 9, 'ascii');\n\n  buf[p += 9] = (cbSign ? 1 : 0);\n\n  buf.writeUInt32BE(algoLen, ++p, true);\n  buf.write(pubKeyFullType, p += 4, algoLen, 'ascii');\n\n  buf.writeUInt32BE(pubKeyLen, p += algoLen, true);\n  pubKey.copy(buf, p += 4);\n\n  if (!cbSign) {\n    this._state.authsQueue.push('publickey');\n    this.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (publickey -- check)');\n    return send(this, buf);\n  }\n\n  cbSign(buf, function(signature) {\n    if (pubKeyFullType === 'ssh-dss') {\n      signature = DSASigBERToBare(signature);\n    } else if (pubKeyFullType !== 'ssh-rsa') {\n      // ECDSA\n      signature = ECDSASigASN1ToSSH(signature);\n    }\n\n    var sigLen = signature.length;\n    var sigbuf = new Buffer(1\n                            + 4 + userLen\n                            + 4 + 14 // \"ssh-connection\"\n                            + 4 + 9 // \"publickey\"\n                            + 1\n                            + 4 + algoLen\n                            + 4 + pubKeyLen\n                            + 4 // 4 + algoLen + 4 + sigLen\n                            + 4 + algoLen\n                            + 4 + sigLen);\n\n    p = 0;\n\n    sigbuf[p] = MESSAGE.USERAUTH_REQUEST;\n\n    sigbuf.writeUInt32BE(userLen, ++p, true);\n    sigbuf.write(username, p += 4, userLen, 'utf8');\n\n    sigbuf.writeUInt32BE(14, p += userLen, true);\n    sigbuf.write('ssh-connection', p += 4, 14, 'ascii');\n\n    sigbuf.writeUInt32BE(9, p += 14, true);\n    sigbuf.write('publickey', p += 4, 9, 'ascii');\n\n    sigbuf[p += 9] = 1;\n\n    sigbuf.writeUInt32BE(algoLen, ++p, true);\n    sigbuf.write(pubKeyFullType, p += 4, algoLen, 'ascii');\n\n    sigbuf.writeUInt32BE(pubKeyLen, p += algoLen, true);\n    pubKey.copy(sigbuf, p += 4);\n    sigbuf.writeUInt32BE(4 + algoLen + 4 + sigLen, p += pubKeyLen, true);\n    sigbuf.writeUInt32BE(algoLen, p += 4, true);\n    sigbuf.write(pubKeyFullType, p += 4, algoLen, 'ascii');\n    sigbuf.writeUInt32BE(sigLen, p += algoLen, true);\n    signature.copy(sigbuf, p += 4);\n\n    // Servers shouldn't send packet type 60 in response to signed publickey\n    // attempts, but if they do, interpret as type 60.\n    self._state.authsQueue.push('publickey');\n    self.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (publickey)');\n    return send(self, sigbuf);\n  });\n  return true;\n};\nSSH2Stream.prototype.authHostbased = function(username, pubKey, hostname,\n                                              userlocal, cbSign) {\n  // TODO: Make DRY by sharing similar code with authPK()\n\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var self = this;\n  var outstate = this._state.outgoing;\n  var pubKeyFullType;\n\n  if (pubKey.public) {\n    pubKeyFullType = pubKey.fulltype;\n    pubKey = pubKey.public;\n  } else {\n    pubKeyFullType = pubKey.toString('ascii',\n                                     4,\n                                     4 + pubKey.readUInt32BE(0, true));\n  }\n\n  var userLen = Buffer.byteLength(username);\n  var algoLen = Buffer.byteLength(pubKeyFullType);\n  var pubKeyLen = pubKey.length;\n  var sesLen = outstate.sessionId.length;\n  var hostnameLen = Buffer.byteLength(hostname);\n  var userlocalLen = Buffer.byteLength(userlocal);\n  var p = 0;\n  var buf = new Buffer(4 + sesLen\n                       + 1\n                       + 4 + userLen\n                       + 4 + 14 // \"ssh-connection\"\n                       + 4 + 9 // \"hostbased\"\n                       + 4 + algoLen\n                       + 4 + pubKeyLen\n                       + 4 + hostnameLen\n                       + 4 + userlocalLen\n                      );\n\n  buf.writeUInt32BE(sesLen, p, true);\n  outstate.sessionId.copy(buf, p += 4);\n\n  buf[p += sesLen] = MESSAGE.USERAUTH_REQUEST;\n\n  buf.writeUInt32BE(userLen, ++p, true);\n  buf.write(username, p += 4, userLen, 'utf8');\n\n  buf.writeUInt32BE(14, p += userLen, true);\n  buf.write('ssh-connection', p += 4, 14, 'ascii');\n\n  buf.writeUInt32BE(9, p += 14, true);\n  buf.write('hostbased', p += 4, 9, 'ascii');\n\n  buf.writeUInt32BE(algoLen, p += 9, true);\n  buf.write(pubKeyFullType, p += 4, algoLen, 'ascii');\n\n  buf.writeUInt32BE(pubKeyLen, p += algoLen, true);\n  pubKey.copy(buf, p += 4);\n\n  buf.writeUInt32BE(hostnameLen, p += pubKeyLen, true);\n  buf.write(hostname, p += 4, hostnameLen, 'ascii');\n\n  buf.writeUInt32BE(userlocalLen, p += hostnameLen, true);\n  buf.write(userlocal, p += 4, userlocalLen, 'utf8');\n\n  cbSign(buf, function(signature) {\n    if (pubKeyFullType === 'ssh-dss') {\n      signature = DSASigBERToBare(signature);\n    } else if (pubKeyFullType !== 'ssh-rsa') {\n      // ECDSA\n      signature = ECDSASigASN1ToSSH(signature);\n    }\n    var sigLen = signature.length;\n    var sigbuf = new Buffer((buf.length - sesLen) + sigLen);\n\n    buf.copy(sigbuf, 0, 4 + sesLen);\n    sigbuf.writeUInt32BE(sigLen, sigbuf.length - sigLen - 4, true);\n    signature.copy(sigbuf, sigbuf.length - sigLen);\n\n    self._state.authsQueue.push('hostbased');\n    self.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (hostbased)');\n    return send(self, sigbuf);\n  });\n  return true;\n};\nSSH2Stream.prototype.authKeyboard = function(username) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var userLen = Buffer.byteLength(username);\n  var p = 0;\n  var buf = new Buffer(1\n                       + 4 + userLen\n                       + 4 + 14 // \"ssh-connection\"\n                       + 4 + 20 // \"keyboard-interactive\"\n                       + 4 // no language set\n                       + 4 // no submethods\n                      );\n\n  buf[p] = MESSAGE.USERAUTH_REQUEST;\n\n  buf.writeUInt32BE(userLen, ++p, true);\n  buf.write(username, p += 4, userLen, 'utf8');\n\n  buf.writeUInt32BE(14, p += userLen, true);\n  buf.write('ssh-connection', p += 4, 14, 'ascii');\n\n  buf.writeUInt32BE(20, p += 14, true);\n  buf.write('keyboard-interactive', p += 4, 20, 'ascii');\n\n  buf.writeUInt32BE(0, p += 20, true);\n\n  buf.writeUInt32BE(0, p += 4, true);\n\n  this._state.authsQueue.push('keyboard-interactive');\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (keyboard-interactive)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.authNone = function(username) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var userLen = Buffer.byteLength(username);\n  var p = 0;\n  var buf = new Buffer(1\n                       + 4 + userLen\n                       + 4 + 14 // \"ssh-connection\"\n                       + 4 + 4 // \"none\"\n                      );\n\n  buf[p] = MESSAGE.USERAUTH_REQUEST;\n\n  buf.writeUInt32BE(userLen, ++p, true);\n  buf.write(username, p += 4, userLen, 'utf8');\n\n  buf.writeUInt32BE(14, p += userLen, true);\n  buf.write('ssh-connection', p += 4, 14, 'ascii');\n\n  buf.writeUInt32BE(4, p += 14, true);\n  buf.write('none', p += 4, 4, 'ascii');\n\n  this._state.authsQueue.push('none');\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (none)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.authInfoRes = function(responses) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var responsesLen = 0;\n  var p = 0;\n  var resLen;\n  var len;\n  var i;\n\n  if (responses) {\n    for (i = 0, len = responses.length; i < len; ++i)\n      responsesLen += 4 + Buffer.byteLength(responses[i]);\n  }\n  var buf = new Buffer(1 + 4 + responsesLen);\n\n  buf[p++] = MESSAGE.USERAUTH_INFO_RESPONSE;\n\n  buf.writeUInt32BE(responses ? responses.length : 0, p, true);\n  if (responses) {\n    p += 4;\n    for (i = 0, len = responses.length; i < len; ++i) {\n      resLen = Buffer.byteLength(responses[i]);\n      buf.writeUInt32BE(resLen, p, true);\n      p += 4;\n      if (resLen) {\n        buf.write(responses[i], p, resLen, 'utf8');\n        p += resLen;\n      }\n    }\n  }\n\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_INFO_RESPONSE');\n  return send(this, buf);\n};\n\n// Server-specific methods\n// Global\nSSH2Stream.prototype.serviceAccept = function(svcName) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var svcNameLen = svcName.length;\n  var buf = new Buffer(1 + 4 + svcNameLen);\n\n  buf[0] = MESSAGE.SERVICE_ACCEPT;\n\n  buf.writeUInt32BE(svcNameLen, 1, true);\n  buf.write(svcName, 5, svcNameLen, 'ascii');\n\n  this.debug('DEBUG: Outgoing: Writing SERVICE_ACCEPT (' + svcName + ')');\n  send(this, buf);\n\n  if (this.server && this.banner && svcName === 'ssh-userauth') {\n    /*\n      byte      SSH_MSG_USERAUTH_BANNER\n      string    message in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    var bannerLen = Buffer.byteLength(this.banner);\n    var packetLen = 1 + 4 + bannerLen + 4;\n    if (packetLen > BUFFER_MAX_LEN) {\n      bannerLen -= 1 + 4 + 4;\n      packetLen -= 1 + 4 + 4;\n    }\n    var packet = new Buffer(packetLen);\n    packet[0] = MESSAGE.USERAUTH_BANNER;\n    packet.writeUInt32BE(bannerLen, 1, true);\n    packet.write(this.banner, 5, bannerLen, 'utf8');\n    packet.fill(0, packetLen - 4); // Empty language tag\n    this.debug('DEBUG: Outgoing: Writing USERAUTH_BANNER');\n    send(this, packet);\n    this.banner = undefined; // Prevent banner from being displayed again\n  }\n};\n// 'ssh-connection' service-specific\nSSH2Stream.prototype.forwardedTcpip = function(chan, initWindow, maxPacket,\n                                               cfg) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var boundAddrLen = Buffer.byteLength(cfg.boundAddr);\n  var remoteAddrLen = Buffer.byteLength(cfg.remoteAddr);\n  var p = 36 + boundAddrLen;\n  var buf = new Buffer(1 + 4 + 15 + 4 + 4 + 4 + 4 + boundAddrLen + 4 + 4\n                       + remoteAddrLen + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  buf.writeUInt32BE(15, 1, true);\n  buf.write('forwarded-tcpip', 5, 15, 'ascii');\n\n  buf.writeUInt32BE(chan, 20, true);\n\n  buf.writeUInt32BE(initWindow, 24, true);\n\n  buf.writeUInt32BE(maxPacket, 28, true);\n\n  buf.writeUInt32BE(boundAddrLen, 32, true);\n  buf.write(cfg.boundAddr, 36, boundAddrLen, 'ascii');\n\n  buf.writeUInt32BE(cfg.boundPort, p, true);\n\n  buf.writeUInt32BE(remoteAddrLen, p += 4, true);\n  buf.write(cfg.remoteAddr, p += 4, remoteAddrLen, 'ascii');\n\n  buf.writeUInt32BE(cfg.remotePort, p += remoteAddrLen, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', forwarded-tcpip)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.x11 = function(chan, initWindow, maxPacket, cfg) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var addrLen = Buffer.byteLength(cfg.originAddr);\n  var p = 24 + addrLen;\n  var buf = new Buffer(1 + 4 + 3 + 4 + 4 + 4 + 4 + addrLen + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  buf.writeUInt32BE(3, 1, true);\n  buf.write('x11', 5, 3, 'ascii');\n\n  buf.writeUInt32BE(chan, 8, true);\n\n  buf.writeUInt32BE(initWindow, 12, true);\n\n  buf.writeUInt32BE(maxPacket, 16, true);\n\n  buf.writeUInt32BE(addrLen, 20, true);\n  buf.write(cfg.originAddr, 24, addrLen, 'ascii');\n\n  buf.writeUInt32BE(cfg.originPort, p, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', x11)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_forwardedStreamLocal = function(chan, initWindow,\n                                                             maxPacket, cfg) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var pathlen = Buffer.byteLength(cfg.socketPath);\n  var buf = new Buffer(1 + 4 + 33 + 4 + 4 + 4 + 4 + pathlen + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  buf.writeUInt32BE(33, 1, true);\n  buf.write('forwarded-streamlocal@openssh.com', 5, 33, 'ascii');\n\n  buf.writeUInt32BE(chan, 38, true);\n\n  buf.writeUInt32BE(initWindow, 42, true);\n\n  buf.writeUInt32BE(maxPacket, 46, true);\n\n  buf.writeUInt32BE(pathlen, 50, true);\n  buf.write(cfg.socketPath, 54, pathlen, 'utf8');\n\n  buf.writeUInt32BE(0, 54 + pathlen, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', forwarded-streamlocal@openssh.com)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.exitStatus = function(chan, status) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  // Does not consume window space\n  var buf = new Buffer(1 + 4 + 4 + 11 + 1 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(11, 5, true);\n  buf.write('exit-status', 9, 11, 'ascii');\n\n  buf[20] = 0;\n\n  buf.writeUInt32BE(status, 21, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', exit-status)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.exitSignal = function(chan, name, coreDumped, msg) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  // Does not consume window space\n  var nameLen = Buffer.byteLength(name);\n  var msgLen = (msg ? Buffer.byteLength(msg) : 0);\n  var p = 25 + nameLen;\n  var buf = new Buffer(1 + 4 + 4 + 11 + 1 + 4 + nameLen + 1 + 4 + msgLen + 4);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(11, 5, true);\n  buf.write('exit-signal', 9, 11, 'ascii');\n\n  buf[20] = 0;\n\n  buf.writeUInt32BE(nameLen, 21, true);\n  buf.write(name, 25, nameLen, 'utf8');\n\n  buf[p++] = (coreDumped ? 1 : 0);\n\n  buf.writeUInt32BE(msgLen, p, true);\n  p += 4;\n  if (msgLen) {\n    buf.write(msg, p, msgLen, 'utf8');\n    p += msgLen;\n  }\n\n  buf.writeUInt32BE(0, p, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', exit-signal)');\n  return send(this, buf);\n};\n// 'ssh-userauth' service-specific\nSSH2Stream.prototype.authFailure = function(authMethods, isPartial) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var authsQueue = this._state.authsQueue;\n  if (!authsQueue.length)\n    throw new Error('No auth in progress');\n\n  var methods;\n\n  if (typeof authMethods === 'boolean') {\n    isPartial = authMethods;\n    authMethods = undefined;\n  }\n\n  if (authMethods) {\n    methods = [];\n    for (var i = 0, len = authMethods.length; i < len; ++i) {\n      if (authMethods[i].toLowerCase() === 'none')\n        continue;\n      methods.push(authMethods[i]);\n    }\n    methods = methods.join(',');\n  } else\n    methods = '';\n\n  var methodsLen = methods.length;\n  var buf = new Buffer(1 + 4 + methodsLen + 1);\n\n  buf[0] = MESSAGE.USERAUTH_FAILURE;\n\n  buf.writeUInt32BE(methodsLen, 1, true);\n  buf.write(methods, 5, methodsLen, 'ascii');\n\n  buf[5 + methodsLen] = (isPartial === true ? 1 : 0);\n\n  this._state.authsQueue.shift();\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_FAILURE');\n  return send(this, buf);\n};\nSSH2Stream.prototype.authSuccess = function() {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var authsQueue = this._state.authsQueue;\n  if (!authsQueue.length)\n    throw new Error('No auth in progress');\n\n  this._state.authsQueue.shift();\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_SUCCESS');\n  return send(this, USERAUTH_SUCCESS_PACKET);\n};\nSSH2Stream.prototype.authPKOK = function(keyAlgo, key) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var authsQueue = this._state.authsQueue;\n  if (!authsQueue.length || authsQueue[0] !== 'publickey')\n    throw new Error('\"publickey\" auth not in progress');\n\n  var keyAlgoLen = keyAlgo.length;\n  var keyLen = key.length;\n  var buf = new Buffer(1 + 4 + keyAlgoLen + 4 + keyLen);\n\n  buf[0] = MESSAGE.USERAUTH_PK_OK;\n\n  buf.writeUInt32BE(keyAlgoLen, 1, true);\n  buf.write(keyAlgo, 5, keyAlgoLen, 'ascii');\n\n  buf.writeUInt32BE(keyLen, 5 + keyAlgoLen, true);\n  key.copy(buf, 5 + keyAlgoLen + 4);\n\n  this._state.authsQueue.shift();\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_PK_OK');\n  return send(this, buf);\n};\nSSH2Stream.prototype.authPasswdChg = function(prompt, lang) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var promptLen = Buffer.byteLength(prompt);\n  var langLen = lang ? lang.length : 0;\n  var p = 0;\n  var buf = new Buffer(1 + 4 + promptLen + 4 + langLen);\n\n  buf[p] = MESSAGE.USERAUTH_PASSWD_CHANGEREQ;\n\n  buf.writeUInt32BE(promptLen, ++p, true);\n  buf.write(prompt, p += 4, promptLen, 'utf8');\n\n  buf.writeUInt32BE(langLen, p += promptLen, true);\n  if (langLen)\n    buf.write(lang, p += 4, langLen, 'ascii');\n\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_PASSWD_CHANGEREQ');\n  return send(this, buf);\n};\nSSH2Stream.prototype.authInfoReq = function(name, instructions, prompts) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var promptsLen = 0;\n  var nameLen = name ? Buffer.byteLength(name) : 0;\n  var instrLen = instructions ? Buffer.byteLength(instructions) : 0;\n  var p = 0;\n  var promptLen;\n  var prompt;\n  var len;\n  var i;\n\n  for (i = 0, len = prompts.length; i < len; ++i)\n    promptsLen += 4 + Buffer.byteLength(prompts[i].prompt) + 1;\n  var buf = new Buffer(1 + 4 + nameLen + 4 + instrLen + 4 + 4 + promptsLen);\n\n  buf[p++] = MESSAGE.USERAUTH_INFO_REQUEST;\n\n  buf.writeUInt32BE(nameLen, p, true);\n  p += 4;\n  if (name) {\n    buf.write(name, p, nameLen, 'utf8');\n    p += nameLen;\n  }\n\n  buf.writeUInt32BE(instrLen, p, true);\n  p += 4;\n  if (instructions) {\n    buf.write(instructions, p, instrLen, 'utf8');\n    p += instrLen;\n  }\n\n  buf.writeUInt32BE(0, p, true);\n  p += 4;\n\n  buf.writeUInt32BE(prompts.length, p, true);\n  p += 4;\n  for (i = 0, len = prompts.length; i < len; ++i) {\n    prompt = prompts[i];\n    promptLen = Buffer.byteLength(prompt.prompt);\n    buf.writeUInt32BE(promptLen, p, true);\n    p += 4;\n    if (promptLen) {\n      buf.write(prompt.prompt, p, promptLen, 'utf8');\n      p += promptLen;\n    }\n    buf[p++] = (prompt.echo ? 1 : 0);\n  }\n\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_INFO_REQUEST');\n  return send(this, buf);\n};\n\n// Shared incoming/parser functions\nfunction onDISCONNECT(self, reason, code, desc, lang) { // Client/Server\n  if (code !== DISCONNECT_REASON.BY_APPLICATION) {\n    var err = new Error(desc || reason);\n    err.code = code;\n    self.emit('error', err);\n  }\n  self.reset();\n}\n\nfunction onKEXINIT(self, init, firstFollows) { // Client/Server\n  var state = self._state;\n  var outstate = state.outgoing;\n\n  if (outstate.status === OUT_READY) {\n    self.debug('DEBUG: Received re-key request');\n    outstate.status = OUT_REKEYING;\n    outstate.kexinit = undefined;\n    KEXINIT(self, check);\n  } else\n    check();\n\n  function check() {\n    if (check_KEXINIT(self, init, firstFollows) === true) {\n      var isGEX = RE_GEX.test(state.kexdh);\n      if (!self.server) {\n        if (isGEX)\n          KEXDH_GEX_REQ(self);\n        else\n          KEXDH_INIT(self);\n      } else {\n        if (isGEX)\n          state.incoming.expectedPacket = 'KEXDH_GEX_REQ';\n        else\n          state.incoming.expectedPacket = 'KEXDH_INIT';\n      }\n    }\n  }\n}\n\nfunction check_KEXINIT(self, init, firstFollows) {\n  var state = self._state;\n  var instate = state.incoming;\n  var outstate = state.outgoing;\n  var debug = self.debug;\n  var serverList;\n  var clientList;\n  var val;\n  var len;\n  var i;\n\n  debug('DEBUG: Comparing KEXINITs ...');\n\n  var algos = self.config.algorithms;\n\n  var kexList = algos.kex;\n  if (self.remoteBugs & BUGS.BAD_DHGEX) {\n    var copied = false;\n    for (var j = kexList.length - 1; j >= 0; --j) {\n      if (kexList[j].indexOf('group-exchange') !== -1) {\n        if (!copied) {\n          kexList = kexList.slice();\n          copied = true;\n        }\n        kexList.splice(j, 1);\n      }\n    }\n  }\n\n  debug('DEBUG: (local) KEX algorithms: ' + kexList);\n  debug('DEBUG: (remote) KEX algorithms: ' + init.algorithms.kex);\n  if (self.server) {\n    serverList = kexList;\n    clientList = init.algorithms.kex;\n  } else {\n    serverList = init.algorithms.kex;\n    clientList = kexList;\n  }\n  // Check for agreeable key exchange algorithm\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching key exchange algorithm');\n    var err = new Error('Handshake failed: no matching key exchange algorithm');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  var kex_algorithm = clientList[i];\n  debug('DEBUG: KEX algorithm: ' + kex_algorithm);\n  if (firstFollows\n      && (!init.algorithms.kex.length\n          || kex_algorithm !== init.algorithms.kex[0])) {\n    // Ignore next incoming packet, it was a wrong first guess at KEX algorithm\n    instate.ignoreNext = true;\n  }\n\n  debug('DEBUG: (local) Host key formats: ' + algos.serverHostKey);\n  debug('DEBUG: (remote) Host key formats: ' + init.algorithms.srvHostKey);\n  if (self.server) {\n    serverList = algos.serverHostKey;\n    clientList = init.algorithms.srvHostKey;\n  } else {\n    serverList = init.algorithms.srvHostKey;\n    clientList = algos.serverHostKey;\n  }\n  // Check for agreeable server host key format\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching host key format');\n    var err = new Error('Handshake failed: no matching host key format');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  state.hostkeyFormat = clientList[i];\n  debug('DEBUG: Host key format: ' + state.hostkeyFormat);\n\n  debug('DEBUG: (local) Client->Server ciphers: ' + algos.cipher);\n  debug('DEBUG: (remote) Client->Server ciphers: '\n        + init.algorithms.cs.encrypt);\n  if (self.server) {\n    serverList = algos.cipher;\n    clientList = init.algorithms.cs.encrypt;\n  } else {\n    serverList = init.algorithms.cs.encrypt;\n    clientList = algos.cipher;\n  }\n  // Check for agreeable client->server cipher\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching Client->Server cipher');\n    var err = new Error('Handshake failed: no matching client->server cipher');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (self.server) {\n    val = instate.decrypt.type = clientList[i];\n    instate.decrypt.isGCM = RE_GCM.test(val);\n  } else {\n    val = outstate.encrypt.type = clientList[i];\n    outstate.encrypt.isGCM = RE_GCM.test(val);\n  }\n  debug('DEBUG: Client->Server Cipher: ' + val);\n\n  debug('DEBUG: (local) Server->Client ciphers: ' + algos.cipher);\n  debug('DEBUG: (remote) Server->Client ciphers: '\n        + (init.algorithms.sc.encrypt));\n  if (self.server) {\n    serverList = algos.cipher;\n    clientList = init.algorithms.sc.encrypt;\n  } else {\n    serverList = init.algorithms.sc.encrypt;\n    clientList = algos.cipher;\n  }\n  // Check for agreeable server->client cipher\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching Server->Client cipher');\n    var err = new Error('Handshake failed: no matching server->client cipher');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (self.server) {\n    val = outstate.encrypt.type = clientList[i];\n    outstate.encrypt.isGCM = RE_GCM.test(val);\n  } else {\n    val = instate.decrypt.type = clientList[i];\n    instate.decrypt.isGCM = RE_GCM.test(val);\n  }\n  debug('DEBUG: Server->Client Cipher: ' + val);\n\n  debug('DEBUG: (local) Client->Server HMAC algorithms: ' + algos.hmac);\n  debug('DEBUG: (remote) Client->Server HMAC algorithms: '\n        + init.algorithms.cs.mac);\n  if (self.server) {\n    serverList = algos.hmac;\n    clientList = init.algorithms.cs.mac;\n  } else {\n    serverList = init.algorithms.cs.mac;\n    clientList = algos.hmac;\n  }\n  // Check for agreeable client->server hmac algorithm\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching Client->Server HMAC algorithm');\n    var err = new Error('Handshake failed: no matching client->server HMAC');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (self.server)\n    val = instate.hmac.type = clientList[i];\n  else\n    val = outstate.hmac.type = clientList[i];\n  debug('DEBUG: Client->Server HMAC algorithm: ' + val);\n\n  debug('DEBUG: (local) Server->Client HMAC algorithms: ' + algos.hmac);\n  debug('DEBUG: (remote) Server->Client HMAC algorithms: '\n        + init.algorithms.sc.mac);\n  if (self.server) {\n    serverList = algos.hmac;\n    clientList = init.algorithms.sc.mac;\n  } else {\n    serverList = init.algorithms.sc.mac;\n    clientList = algos.hmac;\n  }\n  // Check for agreeable server->client hmac algorithm\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching Server->Client HMAC algorithm');\n    var err = new Error('Handshake failed: no matching server->client HMAC');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (self.server)\n    val = outstate.hmac.type = clientList[i];\n  else\n    val = instate.hmac.type = clientList[i];\n  debug('DEBUG: Server->Client HMAC algorithm: ' + val);\n\n  debug('DEBUG: (local) Client->Server compression algorithms: '\n        + algos.compress);\n  debug('DEBUG: (remote) Client->Server compression algorithms: '\n        + init.algorithms.cs.compress);\n  if (self.server) {\n    serverList = algos.compress;\n    clientList = init.algorithms.cs.compress;\n  } else {\n    serverList = init.algorithms.cs.compress;\n    clientList = algos.compress;\n  }\n  // Check for agreeable client->server compression algorithm\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching Client->Server compression algorithm');\n    var err = new Error('Handshake failed: no matching client->server '\n                        + 'compression algorithm');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (self.server)\n    val = instate.decompress.type = clientList[i];\n  else\n    val = outstate.compress.type = clientList[i];\n  debug('DEBUG: Client->Server compression algorithm: ' + val);\n\n  debug('DEBUG: (local) Server->Client compression algorithms: '\n        + algos.compress);\n  debug('DEBUG: (remote) Server->Client compression algorithms: '\n        + init.algorithms.sc.compress);\n  if (self.server) {\n    serverList = algos.compress;\n    clientList = init.algorithms.sc.compress;\n  } else {\n    serverList = init.algorithms.sc.compress;\n    clientList = algos.compress;\n  }\n  // Check for agreeable server->client compression algorithm\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching Server->Client compression algorithm');\n    var err = new Error('Handshake failed: no matching server->client '\n                        + 'compression algorithm');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (self.server)\n    val = outstate.compress.type = clientList[i];\n  else\n    val = instate.decompress.type = clientList[i];\n  debug('DEBUG: Server->Client compression algorithm: ' + val);\n\n  switch (kex_algorithm) {\n    case 'diffie-hellman-group1-sha1':\n      state.kexdh = 'group';\n      state.kex = crypto.getDiffieHellman('modp2');\n      break;\n    case 'diffie-hellman-group14-sha1':\n      state.kexdh = 'group';\n      state.kex = crypto.getDiffieHellman('modp14');\n      break;\n    case 'ecdh-sha2-nistp256':\n      state.kexdh = 'ec-sha256';\n      state.kex = crypto.createECDH(SSH_TO_OPENSSL[kex_algorithm]);\n      break;\n    case 'ecdh-sha2-nistp384':\n      state.kexdh = 'ec-sha384';\n      state.kex = crypto.createECDH(SSH_TO_OPENSSL[kex_algorithm]);\n      break;\n    case 'ecdh-sha2-nistp521':\n      state.kexdh = 'ec-sha512';\n      state.kex = crypto.createECDH(SSH_TO_OPENSSL[kex_algorithm]);\n      break;\n    default:\n      if (kex_algorithm === 'diffie-hellman-group-exchange-sha1')\n        state.kexdh = 'gex-sha1';\n      else if (kex_algorithm === 'diffie-hellman-group-exchange-sha256')\n        state.kexdh = 'gex-sha256';\n      // Reset kex object if DH group exchange is selected on re-key and DH\n      // group exchange was used before the re-key. This ensures that we send\n      // the right DH packet after the KEXINIT exchange\n      state.kex = undefined;\n  }\n\n  if (state.kex) {\n    outstate.pubkey = state.kex.generateKeys();\n    var idx = 0;\n    len = outstate.pubkey.length;\n    while (outstate.pubkey[idx] === 0x00) {\n      ++idx;\n      --len;\n    }\n    if (outstate.pubkey[idx] & 0x80) {\n      var key = new Buffer(len + 1);\n      key[0] = 0;\n      outstate.pubkey.copy(key, 1, idx);\n      outstate.pubkey = key;\n    }\n  }\n\n  return true;\n}\n\nfunction onKEXDH_GEX_GROUP(self, prime, gen) {\n  var state = self._state;\n  var outstate = state.outgoing;\n\n  state.kex = crypto.createDiffieHellman(prime, gen);\n  outstate.pubkey = state.kex.generateKeys();\n  var idx = 0;\n  var len = outstate.pubkey.length;\n  while (outstate.pubkey[idx] === 0x00) {\n    ++idx;\n    --len;\n  }\n  if (outstate.pubkey[idx] & 0x80) {\n    var key = new Buffer(len + 1);\n    key[0] = 0;\n    outstate.pubkey.copy(key, 1, idx);\n    outstate.pubkey = key;\n  }\n  KEXDH_INIT(self);\n}\n\nfunction onKEXDH_INIT(self, e) { // Server\n  KEXDH_REPLY(self, e);\n}\n\nfunction onKEXDH_REPLY(self, info, verifiedHost) { // Client\n  var state = self._state;\n  var instate = state.incoming;\n  var outstate = state.outgoing;\n  var debug = self.debug;\n  var len;\n  var i;\n\n  if (verifiedHost === undefined) {\n    instate.expectedPacket = 'NEWKEYS';\n    outstate.sentNEWKEYS = false;\n\n    debug('DEBUG: Checking host key format');\n    // Ensure all host key formats agree\n    var hostkey_format = readString(info.hostkey, 0, 'ascii', self);\n    if (hostkey_format === false)\n      return false;\n    if (info.hostkey_format !== state.hostkeyFormat\n        || info.hostkey_format !== hostkey_format) {\n      // Expected and actual server host key format do not match!\n      debug('DEBUG: Host key format mismatch');\n      self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      self.reset();\n      var err = new Error('Handshake failed: host key format mismatch');\n      err.level = 'handshake';\n      self.emit('error', err);\n      return false;\n    }\n\n    debug('DEBUG: Checking signature format');\n    // Ensure signature formats agree\n    var sig_format = readString(info.sig, 0, 'ascii', self);\n    if (sig_format === false)\n      return false;\n    if (info.sig_format !== sig_format) {\n      debug('DEBUG: Signature format mismatch');\n      self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      self.reset();\n      var err = new Error('Handshake failed: signature format mismatch');\n      err.level = 'handshake';\n      self.emit('error', err);\n      return false;\n    }\n  }\n\n  // Verify the host fingerprint first if needed\n  if (outstate.status === OUT_INIT) {\n    if (verifiedHost === undefined) {\n      debug('DEBUG: Verifying host fingerprint');\n      var sync = true;\n      var emitted = self.emit('fingerprint', info.hostkey, function(permitted) {\n        // Prevent multiple calls to this callback\n        if (verifiedHost !== undefined)\n          return;\n        verifiedHost = !!permitted;\n        if (!sync) {\n          // Continue execution by re-entry\n          onKEXDH_REPLY(self, info, verifiedHost);\n        }\n      });\n      sync = false;\n      // Support async calling of verification callback\n      if (emitted && verifiedHost === undefined)\n        return;\n    }\n    if (verifiedHost === undefined)\n      debug('DEBUG: Host accepted by default (no verification)');\n    else if (verifiedHost === true)\n      debug('DEBUG: Host accepted (verified)');\n    else {\n      debug('DEBUG: Host denied via fingerprint verification');\n      self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      self.reset();\n      var err = new Error('Handshake failed: '\n                          + 'host fingerprint verification failed');\n      err.level = 'handshake';\n      self.emit('error', err);\n      return false;\n    }\n  }\n\n  var slicepos = -1;\n  for (i = 0, len = info.pubkey.length; i < len; ++i) {\n    if (info.pubkey[i] === 0)\n      ++slicepos;\n    else\n      break;\n  }\n  if (slicepos > -1)\n    info.pubkey = info.pubkey.slice(slicepos + 1);\n  info.secret = tryComputeSecret(state.kex, info.pubkey);\n  if (info.secret instanceof Error) {\n    info.secret.message = 'Error while computing DH secret ('\n                          + state.kexdh + '): '\n                          + info.secret.message;\n    info.secret.level = 'handshake';\n    self.emit('error', info.secret);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  var hashAlgo;\n  if (state.kexdh === 'group')\n    hashAlgo = 'sha1';\n  else\n    hashAlgo = RE_KEX_HASH.exec(state.kexdh)[1];\n  var hash = crypto.createHash(hashAlgo);\n\n  var len_ident = Buffer.byteLength(self.config.ident);\n  var len_sident = Buffer.byteLength(instate.identRaw);\n  var len_init = outstate.kexinit.length;\n  var len_sinit = instate.kexinit.length;\n  var len_hostkey = info.hostkey.length;\n  var len_pubkey = outstate.pubkey.length;\n  var len_spubkey = info.pubkey.length;\n  var len_secret = info.secret.length;\n\n  var idx_pubkey = 0;\n  var idx_spubkey = 0;\n  var idx_secret = 0;\n\n  while (outstate.pubkey[idx_pubkey] === 0x00) {\n    ++idx_pubkey;\n    --len_pubkey;\n  }\n  while (info.pubkey[idx_spubkey] === 0x00) {\n    ++idx_spubkey;\n    --len_spubkey;\n  }\n  while (info.secret[idx_secret] === 0x00) {\n    ++idx_secret;\n    --len_secret;\n  }\n  if (outstate.pubkey[idx_pubkey] & 0x80)\n    ++len_pubkey;\n  if (info.pubkey[idx_spubkey] & 0x80)\n    ++len_spubkey;\n  if (info.secret[idx_secret] & 0x80)\n    ++len_secret;\n\n  var exchangeBufLen = len_ident\n                       + len_sident\n                       + len_init\n                       + len_sinit\n                       + len_hostkey\n                       + len_pubkey\n                       + len_spubkey\n                       + len_secret\n                       + (4 * 8); // Length fields for above values\n\n  // Group exchange-related\n  var isGEX = RE_GEX.test(state.kexdh);\n  var len_gex_prime = 0;\n  var len_gex_gen = 0;\n  var idx_gex_prime = 0;\n  var idx_gex_gen = 0;\n  var gex_prime;\n  var gex_gen;\n  if (isGEX) {\n    gex_prime = state.kex.getPrime();\n    gex_gen = state.kex.getGenerator();\n    len_gex_prime = gex_prime.length;\n    len_gex_gen = gex_gen.length;\n    while (gex_prime[idx_gex_prime] === 0x00) {\n      ++idx_gex_prime;\n      --len_gex_prime;\n    }\n    while (gex_gen[idx_gex_gen] === 0x00) {\n      ++idx_gex_gen;\n      --len_gex_gen;\n    }\n    if (gex_prime[idx_gex_prime] & 0x80)\n      ++len_gex_prime;\n    if (gex_gen[idx_gex_gen] & 0x80)\n      ++len_gex_gen;\n    exchangeBufLen += (4 * 3); // min, n, max values\n    exchangeBufLen += (4 * 2); // prime, generator length fields\n    exchangeBufLen += len_gex_prime;\n    exchangeBufLen += len_gex_gen;\n  }\n\n\n  var bp = 0;\n  var exchangeBuf = new Buffer(exchangeBufLen);\n\n  exchangeBuf.writeUInt32BE(len_ident, bp, true);\n  bp += 4;\n  exchangeBuf.write(self.config.ident, bp, 'utf8'); // V_C\n  bp += len_ident;\n\n  exchangeBuf.writeUInt32BE(len_sident, bp, true);\n  bp += 4;\n  exchangeBuf.write(instate.identRaw, bp, 'utf8'); // V_S\n  bp += len_sident;\n\n  exchangeBuf.writeUInt32BE(len_init, bp, true);\n  bp += 4;\n  outstate.kexinit.copy(exchangeBuf, bp); // I_C\n  bp += len_init;\n  outstate.kexinit = undefined;\n\n  exchangeBuf.writeUInt32BE(len_sinit, bp, true);\n  bp += 4;\n  instate.kexinit.copy(exchangeBuf, bp); // I_S\n  bp += len_sinit;\n  instate.kexinit = undefined;\n\n  exchangeBuf.writeUInt32BE(len_hostkey, bp, true);\n  bp += 4;\n  info.hostkey.copy(exchangeBuf, bp); // K_S\n  bp += len_hostkey;\n\n  if (isGEX) {\n    KEXDH_GEX_REQ_PACKET.slice(1).copy(exchangeBuf, bp); // min, n, max\n    bp += (4 * 3); // Skip over bytes just copied\n\n    exchangeBuf.writeUInt32BE(len_gex_prime, bp, true);\n    bp += 4;\n    if (gex_prime[idx_gex_prime] & 0x80)\n      exchangeBuf[bp++] = 0;\n    gex_prime.copy(exchangeBuf, bp, idx_gex_prime); // p\n    bp += len_gex_prime - (gex_prime[idx_gex_prime] & 0x80 ? 1 : 0);\n\n    exchangeBuf.writeUInt32BE(len_gex_gen, bp, true);\n    bp += 4;\n    if (gex_gen[idx_gex_gen] & 0x80)\n      exchangeBuf[bp++] = 0;\n    gex_gen.copy(exchangeBuf, bp, idx_gex_gen); // g\n    bp += len_gex_gen - (gex_gen[idx_gex_gen] & 0x80 ? 1 : 0);\n  }\n\n  exchangeBuf.writeUInt32BE(len_pubkey, bp, true);\n  bp += 4;\n  if (outstate.pubkey[idx_pubkey] & 0x80)\n    exchangeBuf[bp++] = 0;\n  outstate.pubkey.copy(exchangeBuf, bp, idx_pubkey); // e\n  bp += len_pubkey - (outstate.pubkey[idx_pubkey] & 0x80 ? 1 : 0);\n\n  exchangeBuf.writeUInt32BE(len_spubkey, bp, true);\n  bp += 4;\n  if (info.pubkey[idx_spubkey] & 0x80)\n    exchangeBuf[bp++] = 0;\n  info.pubkey.copy(exchangeBuf, bp, idx_spubkey); // f\n  bp += len_spubkey - (info.pubkey[idx_spubkey] & 0x80 ? 1 : 0);\n\n  exchangeBuf.writeUInt32BE(len_secret, bp, true);\n  bp += 4;\n  if (info.secret[idx_secret] & 0x80)\n    exchangeBuf[bp++] = 0;\n  info.secret.copy(exchangeBuf, bp, idx_secret); // K\n\n  outstate.exchangeHash = hash.update(exchangeBuf).digest(); // H\n\n  var rawsig = readString(info.sig, info.sig._pos, self); // s\n  if (rawsig === false)\n    return false;\n\n  var keyAlgo;\n  switch (info.sig_format) {\n    case 'ssh-rsa':\n      keyAlgo = 'RSA-SHA1';\n      break;\n    case 'ssh-dss':\n      keyAlgo = 'DSA-SHA1';\n      break;\n    case 'ecdsa-sha2-nistp256':\n      keyAlgo = 'sha256';\n      break;\n    case 'ecdsa-sha2-nistp384':\n      keyAlgo = 'sha384';\n      break;\n    case 'ecdsa-sha2-nistp521':\n      keyAlgo = 'sha512';\n      break;\n    default:\n      debug('DEBUG: Signature format unsupported: ' + info.sig_format);\n      self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      self.reset();\n      var err = new Error('Handshake failed: signature format unsupported: '\n                          + info.sig_format);\n      err.level = 'handshake';\n      self.emit('error', err);\n      return false;\n  }\n  var verifier = crypto.createVerify(keyAlgo);\n  verifier.update(outstate.exchangeHash);\n\n  var asn1KeyBuf;\n  if (keyAlgo === 'RSA-SHA1') {\n    asn1KeyBuf = RSAKeySSHToASN1(info.hostkey, self);\n  } else if (keyAlgo === 'DSA-SHA1') {\n    asn1KeyBuf = DSAKeySSHToASN1(info.hostkey, self);\n    rawsig = DSASigBareToBER(rawsig);\n  } else {\n    // ECDSA\n    asn1KeyBuf = ECDSAKeySSHToASN1(info.hostkey, self);\n    rawsig = ECDSASigSSHToASN1(rawsig, self);\n  }\n\n  if (!asn1KeyBuf || !rawsig)\n    return false;\n\n  debug('DEBUG: Verifying signature');\n\n  var b64key = asn1KeyBuf.toString('base64').replace(/(.{64})/g, '$1\\n');\n  var fullkey = '-----BEGIN PUBLIC KEY-----\\n'\n                + b64key\n                + (b64key[b64key.length - 1] === '\\n' ? '' : '\\n')\n                + '-----END PUBLIC KEY-----';\n\n  var verified = verifier.verify(fullkey, rawsig);\n\n  if (!verified) {\n    debug('DEBUG: Signature verification failed');\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    self.reset();\n    var err = new Error('Handshake failed: signature verification failed');\n    err.level = 'handshake';\n    self.emit('error', err);\n    return false;\n  }\n\n  if (outstate.sessionId === undefined)\n    outstate.sessionId = outstate.exchangeHash;\n  outstate.kexsecret = info.secret;\n\n  debug('DEBUG: Outgoing: Writing NEWKEYS');\n  if (outstate.status === OUT_REKEYING)\n    send(self, NEWKEYS_PACKET, undefined, true);\n  else\n    send(self, NEWKEYS_PACKET);\n  outstate.sentNEWKEYS = true;\n\n  if (verifiedHost !== undefined && instate.expectedPacket === undefined) {\n    // We received NEWKEYS while we were waiting for the fingerprint\n    // verification callback to be called. In this case we have to re-execute\n    // onNEWKEYS to finish the handshake.\n    onNEWKEYS(self);\n  }\n}\n\nfunction onNEWKEYS(self) { // Client/Server\n  var state = self._state;\n  var outstate = state.outgoing;\n  var instate = state.incoming;\n\n  instate.expectedPacket = undefined;\n\n  if (!outstate.sentNEWKEYS)\n    return;\n\n  var idx_secret = 0;\n  var len = outstate.kexsecret.length;\n  while (outstate.kexsecret[idx_secret] === 0x00) {\n    ++idx_secret;\n    --len;\n  }\n\n  var blocklen = 8;\n  var keylen = 0;\n  var p = 0;\n\n  var dhHashAlgo;\n  if (state.kexdh === 'group')\n    dhHashAlgo = 'sha1';\n  else\n    dhHashAlgo = RE_KEX_HASH.exec(state.kexdh)[1];\n\n  var len_secret = (outstate.kexsecret[idx_secret] & 0x80 ? 1 : 0) + len;\n  var secret = new Buffer(4 + len_secret);\n  var iv;\n  var key;\n\n  // Whenever the client sends a new authentication request, it is enqueued\n  // here.  Once the request is resolved (success, fail, or PK_OK),\n  // dequeue.  Whatever is at the front of the queue determines how we\n  // interpret packet type 60.\n  state.authsQueue = [];\n\n  secret.writeUInt32BE(len_secret, p, true);\n  p += 4;\n  if (outstate.kexsecret[idx_secret] & 0x80)\n    secret[p++] = 0;\n  outstate.kexsecret.copy(secret, p, idx_secret);\n  outstate.kexsecret = undefined;\n  if (!isStreamCipher(outstate.encrypt.type)) {\n    iv = crypto.createHash(dhHashAlgo)\n               .update(secret)\n               .update(outstate.exchangeHash)\n               .update(!self.server ? 'A' : 'B', 'ascii')\n               .update(outstate.sessionId)\n               .digest();\n    switch (outstate.encrypt.type) {\n      case 'aes128-gcm':\n      case 'aes256-gcm':\n      case 'aes128-gcm@openssh.com':\n      case 'aes256-gcm@openssh.com':\n        blocklen = 12;\n      break;\n      case 'aes256-cbc':\n      case 'aes192-cbc':\n      case 'aes128-cbc':\n      case 'aes256-ctr':\n      case 'aes192-ctr':\n      case 'aes128-ctr':\n        blocklen = 16;\n    }\n    outstate.encrypt.size = blocklen;\n    while (blocklen > iv.length) {\n      iv = Buffer.concat([iv,\n                          crypto.createHash(dhHashAlgo)\n                                .update(secret)\n                                .update(outstate.exchangeHash)\n                                .update(iv)\n                                .digest()]);\n    }\n    iv = iv.slice(0, blocklen);\n  } else {\n    outstate.encrypt.size = blocklen;\n    iv = EMPTY_BUFFER; // Streaming ciphers don't use an IV upfront\n  }\n  switch (outstate.encrypt.type) {\n    case 'aes256-gcm':\n    case 'aes256-gcm@openssh.com':\n    case 'aes256-cbc':\n    case 'aes256-ctr':\n    case 'arcfour256':\n      keylen = 32;\n      break;\n    case '3des-cbc':\n    case '3des-ctr':\n    case 'aes192-cbc':\n    case 'aes192-ctr':\n      keylen = 24;\n      break;\n    case 'aes128-gcm':\n    case 'aes128-gcm@openssh.com':\n    case 'aes128-cbc':\n    case 'aes128-ctr':\n    case 'cast128-cbc':\n    case 'blowfish-cbc':\n    case 'arcfour':\n    case 'arcfour128':\n      keylen = 16;\n      break;\n  }\n\n  key = crypto.createHash(dhHashAlgo)\n              .update(secret)\n              .update(outstate.exchangeHash)\n              .update(!self.server ? 'C' : 'D', 'ascii')\n              .update(outstate.sessionId)\n              .digest();\n  while (keylen > key.length) {\n    key = Buffer.concat([key,\n                         crypto.createHash(dhHashAlgo)\n                               .update(secret)\n                               .update(outstate.exchangeHash)\n                               .update(key)\n                               .digest()]);\n  }\n  key = key.slice(0, keylen);\n\n  if (outstate.encrypt.isGCM) {\n    outstate.encrypt.size = 16;\n    outstate.encrypt.iv = iv;\n    outstate.encrypt.key = key;\n    outstate.encrypt.instance = true;\n  } else {\n    var cipherAlgo = SSH_TO_OPENSSL[outstate.encrypt.type];\n    outstate.encrypt.instance = crypto.createCipheriv(cipherAlgo, key, iv);\n    outstate.encrypt.instance.setAutoPadding(false);\n  }\n\n  // And now for decrypting ...\n\n  blocklen = 8;\n  keylen = 0;\n  if (!isStreamCipher(instate.decrypt.type)) {\n    iv = crypto.createHash(dhHashAlgo)\n               .update(secret)\n               .update(outstate.exchangeHash)\n               .update(!self.server ? 'B' : 'A', 'ascii')\n               .update(outstate.sessionId)\n               .digest();\n    switch (instate.decrypt.type) {\n      case 'aes128-gcm':\n      case 'aes256-gcm':\n      case 'aes128-gcm@openssh.com':\n      case 'aes256-gcm@openssh.com':\n        blocklen = 12;\n      break;\n      case 'aes256-cbc':\n      case 'aes192-cbc':\n      case 'aes128-cbc':\n      case 'aes256-ctr':\n      case 'aes192-ctr':\n      case 'aes128-ctr':\n        blocklen = 16;\n    }\n    if (instate.decrypt.isGCM)\n      instate.decrypt.size = 16;\n    else\n      instate.decrypt.size = blocklen;\n    while (blocklen > iv.length) {\n      iv = Buffer.concat([iv,\n                          crypto.createHash(dhHashAlgo)\n                                .update(secret)\n                                .update(outstate.exchangeHash)\n                                .update(iv)\n                                .digest()]);\n    }\n    iv = iv.slice(0, blocklen);\n  } else {\n    instate.decrypt.size = blocklen;\n    iv = EMPTY_BUFFER; // Streaming ciphers don't use an IV upfront\n  }\n\n  // Create a reusable buffer for decryption purposes\n  instate.decrypt.buf = new Buffer(instate.decrypt.size);\n\n  switch (instate.decrypt.type) {\n    case 'aes256-gcm':\n    case 'aes256-gcm@openssh.com':\n    case 'aes256-cbc':\n    case 'aes256-ctr':\n    case 'arcfour256':\n      keylen = 32;\n      break;\n    case '3des-cbc':\n    case '3des-ctr':\n    case 'aes192-cbc':\n    case 'aes192-ctr':\n      keylen = 24;\n      break;\n    case 'aes128-gcm':\n    case 'aes128-gcm@openssh.com':\n    case 'aes128-cbc':\n    case 'aes128-ctr':\n    case 'cast128-cbc':\n    case 'blowfish-cbc':\n    case 'arcfour':\n    case 'arcfour128':\n      keylen = 16;\n      break;\n  }\n  key = crypto.createHash(dhHashAlgo)\n              .update(secret)\n              .update(outstate.exchangeHash)\n              .update(!self.server ? 'D' : 'C', 'ascii')\n              .update(outstate.sessionId)\n              .digest();\n  while (keylen > key.length) {\n    key = Buffer.concat([key,\n                         crypto.createHash(dhHashAlgo)\n                               .update(secret)\n                               .update(outstate.exchangeHash)\n                               .update(key)\n                               .digest()]);\n  }\n  key = key.slice(0, keylen);\n\n  var decipherAlgo = SSH_TO_OPENSSL[instate.decrypt.type];\n  instate.decrypt.instance = crypto.createDecipheriv(decipherAlgo, key, iv);\n  instate.decrypt.instance.setAutoPadding(false);\n  instate.decrypt.iv = iv;\n  instate.decrypt.key = key;\n\n  /* The \"arcfour128\" algorithm is the RC4 cipher, as described in\n     [SCHNEIER], using a 128-bit key.  The first 1536 bytes of keystream\n     generated by the cipher MUST be discarded, and the first byte of the\n     first encrypted packet MUST be encrypted using the 1537th byte of\n     keystream.\n\n     -- http://tools.ietf.org/html/rfc4345#section-4 */\n  var emptyBuf;\n  if (outstate.encrypt.type.substr(0, 7) === 'arcfour') {\n    emptyBuf = new Buffer(1536);\n    emptyBuf.fill(0);\n    outstate.encrypt.instance.update(emptyBuf);\n  }\n  if (instate.decrypt.type.substr(0, 7) === 'arcfour') {\n    emptyBuf = new Buffer(1536);\n    emptyBuf.fill(0);\n    instate.decrypt.instance.update(emptyBuf);\n  }\n\n  var createKeyLen = 0;\n  var checkKeyLen = 0;\n  switch (outstate.hmac.type) {\n    case 'hmac-ripemd160':\n    case 'hmac-sha1':\n      createKeyLen = 20;\n      outstate.hmac.size = 20;\n      break;\n    case 'hmac-sha1-96':\n      createKeyLen = 20;\n      outstate.hmac.size = 12;\n      break;\n    case 'hmac-sha2-256':\n      createKeyLen = 32;\n      outstate.hmac.size = 32;\n      break;\n    case 'hmac-sha2-256-96':\n      createKeyLen = 32;\n      outstate.hmac.size = 12;\n      break;\n    case 'hmac-sha2-512':\n      createKeyLen = 64;\n      outstate.hmac.size = 64;\n      break;\n    case 'hmac-sha2-512-96':\n      createKeyLen = 64;\n      outstate.hmac.size = 12;\n      break;\n    case 'hmac-md5':\n      createKeyLen = 16;\n      outstate.hmac.size = 16;\n      break;\n    case 'hmac-md5-96':\n      createKeyLen = 16;\n      outstate.hmac.size = 12;\n      break;\n  }\n  switch (instate.hmac.type) {\n    case 'hmac-ripemd160':\n    case 'hmac-sha1':\n      checkKeyLen = 20;\n      instate.hmac.size = 20;\n      break;\n    case 'hmac-sha1-96':\n      checkKeyLen = 20;\n      instate.hmac.size = 12;\n      break;\n    case 'hmac-sha2-256':\n      checkKeyLen = 32;\n      instate.hmac.size = 32;\n      break;\n    case 'hmac-sha2-256-96':\n      checkKeyLen = 32;\n      instate.hmac.size = 12;\n      break;\n    case 'hmac-sha2-512':\n      checkKeyLen = 64;\n      instate.hmac.size = 64;\n      break;\n    case 'hmac-sha2-512-96':\n      checkKeyLen = 64;\n      instate.hmac.size = 12;\n      break;\n    case 'hmac-md5':\n      checkKeyLen = 16;\n      instate.hmac.size = 16;\n      break;\n    case 'hmac-md5-96':\n      checkKeyLen = 16;\n      instate.hmac.size = 12;\n      break;\n  }\n\n  if (!outstate.encrypt.isGCM) {\n    key = crypto.createHash(dhHashAlgo)\n                .update(secret)\n                .update(outstate.exchangeHash)\n                .update(!self.server ? 'E' : 'F', 'ascii')\n                .update(outstate.sessionId)\n                .digest();\n    while (createKeyLen > key.length) {\n      key = Buffer.concat([key,\n                           crypto.createHash(dhHashAlgo)\n                                 .update(secret)\n                                 .update(outstate.exchangeHash)\n                                 .update(key)\n                                 .digest()]);\n    }\n    outstate.hmac.key = key.slice(0, createKeyLen);\n  } else\n    outstate.hmac.key = undefined;\n  if (!instate.decrypt.isGCM) {\n    key = crypto.createHash(dhHashAlgo)\n                .update(secret)\n                .update(outstate.exchangeHash)\n                .update(!self.server ? 'F' : 'E', 'ascii')\n                .update(outstate.sessionId)\n                .digest();\n    while (checkKeyLen > key.length) {\n      key = Buffer.concat([key,\n                           crypto.createHash(dhHashAlgo)\n                                 .update(secret)\n                                 .update(outstate.exchangeHash)\n                                 .update(key)\n                                 .digest()]);\n    }\n    instate.hmac.key = key.slice(0, checkKeyLen);\n  } else {\n    instate.hmac.key = undefined;\n    instate.hmac.size = 16;\n  }\n\n  outstate.exchangeHash = undefined;\n\n  // Create a reusable buffer for message verification purposes\n  if (!instate.hmac.buf\n      || instate.hmac.buf.length !== instate.hmac.size)\n    instate.hmac.buf = new Buffer(instate.hmac.size);\n\n  if (outstate.compress.type === 'zlib')\n    outstate.compress.instance = zlib.createDeflate(ZLIB_OPTS);\n  else if (outstate.compress.type === 'none')\n    outstate.compress.instance = false;\n  if (instate.decompress.type === 'zlib')\n    instate.decompress.instance = zlib.createInflate(ZLIB_OPTS);\n  else if (instate.decompress.type === 'none')\n    instate.decompress.instance = false;\n\n  self.bytesSent = self.bytesReceived = 0;\n\n  if (outstate.status === OUT_REKEYING) {\n    outstate.status = OUT_READY;\n\n    // Empty our outbound buffer of any data we tried to send during the\n    // re-keying process\n    var queue = outstate.rekeyQueue;\n    var qlen = queue.length;\n    var q = 0;\n\n    outstate.rekeyQueue = [];\n\n    for (; q < qlen; ++q) {\n      if (Buffer.isBuffer(queue[q]))\n        send(self, queue[q]);\n      else\n        send(self, queue[q][0], queue[q][1]);\n    }\n\n    // Now empty our inbound buffer of any non-transport layer packets we\n    // received during the re-keying process\n    queue = instate.rekeyQueue;\n    qlen = queue.length;\n    q = 0;\n\n    instate.rekeyQueue = [];\n\n    var curSeqno = instate.seqno;\n    for (; q < qlen; ++q) {\n      instate.seqno = queue[q][0];\n      instate.payload = queue[q][1];\n      if (parsePacket(self) === false)\n        return;\n\n      if (instate.status === IN_INIT) {\n        // We were reset due to some error/disagreement ?\n        return;\n      }\n    }\n    instate.seqno = curSeqno;\n  } else {\n    outstate.status = OUT_READY;\n    if (instate.status === IN_PACKET) {\n      // Explicitly update incoming packet parser status in order to get the\n      // correct decipher, hmac, etc. states.\n\n      // We only get here if the host fingerprint callback was called\n      // asynchronously and the incoming packet parser is still expecting an\n      // unencrypted packet, etc.\n\n      self.debug('DEBUG: Parser: IN_PACKETBEFORE (update) (expecting '\n                 + instate.decrypt.size + ')');\n      // Wait for the right number of bytes so we can determine the incoming\n      // packet length\n      expectData(self,\n                 EXP_TYPE_BYTES,\n                 instate.decrypt.size,\n                 instate.decrypt.buf);\n    }\n    self.emit('ready');\n  }\n}\n\nfunction parsePacket(self, callback) {\n  var instate = self._state.incoming;\n  var outstate = self._state.outgoing;\n  var payload = instate.payload;\n  var seqno = instate.seqno;\n  var serviceName;\n  var lang;\n  var message;\n  var info;\n  var chan;\n  var data;\n  var srcIP;\n  var srcPort;\n  var sender;\n  var window;\n  var packetSize;\n  var recipient;\n  var description;\n  var socketPath;\n\n  if (++instate.seqno > MAX_SEQNO)\n    instate.seqno = 0;\n\n  if (instate.ignoreNext) {\n    self.debug('DEBUG: Parser: Packet ignored');\n    instate.ignoreNext = false;\n    return;\n  }\n\n  var type = payload[0];\n  if (type === undefined)\n    return false;\n\n  // If we receive a packet during handshake that is not the expected packet\n  // and it is not one of: DISCONNECT, IGNORE, UNIMPLEMENTED, or DEBUG, then we\n  // close the stream\n  if (outstate.status !== OUT_READY\n      && MESSAGE[type] !== instate.expectedPacket\n      && type < 1\n      && type > 4) {\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, expected: '\n               + instate.expectedPacket\n               + ' but got: '\n               + MESSAGE[type]);\n    // XXX: Potential issue where the module user decides to initiate a rekey\n    // via KEXINIT() (which sets `expectedPacket`) after receiving a packet\n    // and there is still another packet already waiting to be parsed at the\n    // time the KEXINIT is written. this will cause an unexpected disconnect...\n    self.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n    var err = new Error('Received unexpected packet');\n    err.level = 'protocol';\n    self.emit('error', err);\n    return false;\n  }\n\n  if (type === MESSAGE.CHANNEL_DATA) {\n    /*\n      byte      SSH_MSG_CHANNEL_DATA\n      uint32    recipient channel\n      string    data\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    // TODO: MAX_CHAN_DATA_LEN here should really be dependent upon the\n    //       channel's packet size. The ssh2 module uses 32KB, so we'll hard\n    //       code this for now ...\n    data = readString(payload, 5, self, callback, 32768);\n    if (data === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_DATA ('\n               + chan\n               + ')');\n    self.emit('CHANNEL_DATA:' + chan, data);\n  } else if (type === MESSAGE.CHANNEL_EXTENDED_DATA) {\n    /*\n      byte      SSH_MSG_CHANNEL_EXTENDED_DATA\n      uint32    recipient channel\n      uint32    data_type_code\n      string    data\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    var dataType = readInt(payload, 5, self, callback);\n    if (dataType === false)\n      return false;\n    data = readString(payload, 9, self, callback);\n    if (data === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: '\n               + 'CHANNEL_EXTENDED_DATA ('\n               + chan\n               + ')');\n    self.emit('CHANNEL_EXTENDED_DATA:' + chan, dataType, data);\n  } else if (type === MESSAGE.CHANNEL_WINDOW_ADJUST) {\n    /*\n      byte      SSH_MSG_CHANNEL_WINDOW_ADJUST\n      uint32    recipient channel\n      uint32    bytes to add\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    var bytesToAdd = readInt(payload, 5, self, callback);\n    if (bytesToAdd === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: '\n               + 'CHANNEL_WINDOW_ADJUST ('\n               + chan\n               + ', '\n               + bytesToAdd\n               + ')');\n    self.emit('CHANNEL_WINDOW_ADJUST:' + chan, bytesToAdd);\n  } else if (type === MESSAGE.CHANNEL_SUCCESS) {\n    /*\n      byte      SSH_MSG_CHANNEL_SUCCESS\n      uint32    recipient channel\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_SUCCESS ('\n               + chan\n               + ')');\n    self.emit('CHANNEL_SUCCESS:' + chan);\n  } else if (type === MESSAGE.CHANNEL_FAILURE) {\n    /*\n      byte      SSH_MSG_CHANNEL_FAILURE\n      uint32    recipient channel\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_FAILURE ('\n               + chan\n               + ')');\n    self.emit('CHANNEL_FAILURE:' + chan);\n  } else if (type === MESSAGE.CHANNEL_EOF) {\n    /*\n      byte      SSH_MSG_CHANNEL_EOF\n      uint32    recipient channel\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_EOF ('\n               + chan\n               + ')');\n    self.emit('CHANNEL_EOF:' + chan);\n  } else if (type === MESSAGE.CHANNEL_OPEN) {\n    /*\n      byte      SSH_MSG_CHANNEL_OPEN\n      string    channel type in US-ASCII only\n      uint32    sender channel\n      uint32    initial window size\n      uint32    maximum packet size\n      ....      channel type specific data follows\n    */\n    var chanType = readString(payload, 1, 'ascii', self, callback);\n    if (chanType === false)\n      return false;\n    sender = readInt(payload, payload._pos, self, callback);\n    if (sender === false)\n      return false;\n    window = readInt(payload, payload._pos += 4, self, callback);\n    if (window === false)\n      return false;\n    packetSize = readInt(payload, payload._pos += 4, self, callback);\n    if (packetSize === false)\n      return false;\n    var channel;\n\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_OPEN ('\n               + sender\n               + ', '\n               + chanType\n               + ')');\n\n    if (chanType === 'forwarded-tcpip' // Server->Client\n        || chanType === 'direct-tcpip') { // Client->Server\n      /*\n        string    address that was connected / host to connect\n        uint32    port that was connected / port to connect\n        string    originator IP address\n        uint32    originator port\n      */\n      var destIP = readString(payload,\n                              payload._pos += 4,\n                              'ascii',\n                              self,\n                              callback);\n      if (destIP === false)\n        return false;\n      var destPort = readInt(payload, payload._pos, self, callback);\n      if (destPort === false)\n        return false;\n      srcIP = readString(payload, payload._pos += 4, 'ascii', self, callback);\n      if (srcIP === false)\n        return false;\n      srcPort = readInt(payload, payload._pos, self, callback);\n      if (srcPort === false)\n        return false;\n      channel = {\n        type: chanType,\n        sender: sender,\n        window: window,\n        packetSize: packetSize,\n        data: {\n          destIP: destIP,\n          destPort: destPort,\n          srcIP: srcIP,\n          srcPort: srcPort\n        }\n      };\n    } else if (// Server->Client\n               chanType === 'forwarded-streamlocal@openssh.com'\n               // Client->Server\n               || chanType === 'direct-streamlocal@openssh.com') {\n      /*\n        string    socket path\n        string    reserved for future use\n      */\n      socketPath = readString(payload,\n                              payload._pos += 4,\n                              'utf8',\n                              self,\n                              callback);\n      if (socketPath === false)\n        return false;\n      channel = {\n        type: chanType,\n        sender: sender,\n        window: window,\n        packetSize: packetSize,\n        data: {\n          socketPath: socketPath,\n        }\n      };\n    } else if (chanType === 'x11') { // Server->Client\n      /*\n        string    originator address (e.g., \"192.168.7.38\")\n        uint32    originator port\n      */\n      srcIP = readString(payload, payload._pos += 4, 'ascii', self, callback);\n      if (srcIP === false)\n        return false;\n      srcPort = readInt(payload, payload._pos, self, callback);\n      if (srcPort === false)\n        return false;\n      channel = {\n        type: chanType,\n        sender: sender,\n        window: window,\n        packetSize: packetSize,\n        data: {\n          srcIP: srcIP,\n          srcPort: srcPort\n        }\n      };\n    } else {\n      // 'session' (Client->Server), 'auth-agent@openssh.com' (Server->Client)\n      channel = {\n        type: chanType,\n        sender: sender,\n        window: window,\n        packetSize: packetSize,\n        data: {}\n      };\n    }\n\n    self.emit('CHANNEL_OPEN', channel);\n  } else if (type === MESSAGE.CHANNEL_OPEN_CONFIRMATION) {\n    /*\n      byte      SSH_MSG_CHANNEL_OPEN_CONFIRMATION\n      uint32    recipient channel\n      uint32    sender channel\n      uint32    initial window size\n      uint32    maximum packet size\n      ....      channel type specific data follows\n    */\n    // \"The 'recipient channel' is the channel number given in the\n    // original open request, and 'sender channel' is the channel number\n    // allocated by the other side.\"\n    recipient = readInt(payload, 1, self, callback);\n    if (recipient === false)\n      return false;\n    sender = readInt(payload, 5, self, callback);\n    if (sender === false)\n      return false;\n    window = readInt(payload, 9, self, callback);\n    if (window === false)\n      return false;\n    packetSize = readInt(payload, 13, self, callback);\n    if (packetSize === false)\n      return false;\n\n    info = {\n      recipient: recipient,\n      sender: sender,\n      window: window,\n      packetSize: packetSize\n    };\n\n    if (payload.length > 17)\n      info.data = payload.slice(17);\n\n    self.emit('CHANNEL_OPEN_CONFIRMATION:' + info.recipient, info);\n  } else if (type === MESSAGE.CHANNEL_OPEN_FAILURE) {\n    /*\n      byte      SSH_MSG_CHANNEL_OPEN_FAILURE\n      uint32    recipient channel\n      uint32    reason code\n      string    description in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    recipient = readInt(payload, 1, self, callback);\n    if (recipient === false)\n      return false;\n    var reasonCode = readInt(payload, 5, self, callback);\n    if (reasonCode === false)\n      return false;\n    description = readString(payload, 9, 'utf8', self, callback);\n    if (description === false)\n      return false;\n    lang = readString(payload, payload._pos, 'utf8', self, callback);\n    if (lang === false)\n      return false;\n    payload._pos = 9;\n    info = {\n      recipient: recipient,\n      reasonCode: reasonCode,\n      reason: CHANNEL_OPEN_FAILURE[reasonCode],\n      description: description,\n      lang: lang\n    };\n\n    self.emit('CHANNEL_OPEN_FAILURE:' + info.recipient, info);\n  } else if (type === MESSAGE.CHANNEL_CLOSE) {\n    /*\n      byte      SSH_MSG_CHANNEL_CLOSE\n      uint32    recipient channel\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_CLOSE ('\n               + chan\n               + ')');\n    self.emit('CHANNEL_CLOSE:' + chan);\n  } else if (type === MESSAGE.IGNORE) {\n    /*\n      byte      SSH_MSG_IGNORE\n      string    data\n    */\n  } else if (type === MESSAGE.DISCONNECT) {\n    /*\n      byte      SSH_MSG_DISCONNECT\n      uint32    reason code\n      string    description in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    var reason = readInt(payload, 1, self, callback);\n    if (reason === false)\n      return false;\n    var reasonText = DISCONNECT_REASON[reason];\n    description = readString(payload, 5, 'utf8', self, callback);\n    if (description === false)\n      return false;\n\n    if (payload._pos < payload.length)\n      lang = readString(payload, payload._pos, 'ascii', self, callback);\n\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: DISCONNECT ('\n               + reasonText\n               + ')');\n\n    self.emit('DISCONNECT', reasonText, reason, description, lang);\n  } else if (type === MESSAGE.DEBUG) {\n    /*\n      byte      SSH_MSG_DEBUG\n      boolean   always_display\n      string    message in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    message = readString(payload, 2, 'utf8', self, callback);\n    if (message === false)\n      return false;\n    lang = readString(payload, payload._pos, 'ascii', self, callback);\n    if (lang === false)\n      return false;\n\n    self.emit('DEBUG', message, lang);\n  } else if (type === MESSAGE.NEWKEYS) {\n    /*\n      byte      SSH_MSG_NEW_KEYS\n    */\n    self.emit('NEWKEYS');\n  } else if (type === MESSAGE.SERVICE_REQUEST) {\n    /*\n      byte      SSH_MSG_SERVICE_REQUEST\n      string    service name\n    */\n    serviceName = readString(payload, 1, 'ascii', self, callback);\n    if (serviceName === false)\n      return false;\n\n    self.emit('SERVICE_REQUEST', serviceName);\n  } else if (type === MESSAGE.SERVICE_ACCEPT) {\n    /*\n      byte      SSH_MSG_SERVICE_ACCEPT\n      string    service name\n    */\n    serviceName = readString(payload, 1, 'ascii', self, callback);\n    if (serviceName === false)\n      return false;\n\n    self.emit('SERVICE_ACCEPT', serviceName);\n  } else if (type === MESSAGE.USERAUTH_REQUEST) {\n    /*\n      byte      SSH_MSG_USERAUTH_REQUEST\n      string    user name in ISO-10646 UTF-8 encoding [RFC3629]\n      string    service name in US-ASCII\n      string    method name in US-ASCII\n      ....      method specific fields\n    */\n    var username = readString(payload, 1, 'utf8', self, callback);\n    if (username === false)\n      return false;\n    var svcName = readString(payload, payload._pos, 'ascii', self, callback);\n    if (svcName === false)\n      return false;\n    var method = readString(payload, payload._pos, 'ascii', self, callback);\n    if (method === false)\n      return false;\n    var methodData;\n\n    if (method === 'password') {\n      methodData = readString(payload,\n                              payload._pos + 1,\n                              'utf8',\n                              self,\n                              callback);\n      if (methodData === false)\n        return false;\n    } else if (method === 'publickey' || method === 'hostbased') {\n      var pkSigned;\n      var keyAlgo;\n      var key;\n      var signature;\n      var blob;\n      var hostname;\n      var userlocal;\n      if (method === 'publickey') {\n        pkSigned = payload[payload._pos++];\n        if (pkSigned === undefined)\n          return false;\n        pkSigned = (pkSigned !== 0);\n      }\n      keyAlgo = readString(payload, payload._pos, 'ascii', self, callback);\n      if (keyAlgo === false)\n        return false;\n      key = readString(payload, payload._pos, self, callback);\n      if (key === false)\n        return false;\n\n      if (pkSigned || method === 'hostbased') {\n        if (method === 'hostbased') {\n          hostname = readString(payload, payload._pos, 'ascii', self, callback);\n          if (hostname === false)\n            return false;\n          userlocal = readString(payload, payload._pos, 'utf8', self, callback);\n          if (userlocal === false)\n            return false;\n        }\n\n        var blobEnd = payload._pos;\n        signature = readString(payload, blobEnd, self, callback);\n        if (signature === false)\n          return false;\n\n        if (signature.length > (4 + keyAlgo.length + 4)\n            && signature.toString('ascii', 4, 4 + keyAlgo.length) === keyAlgo) {\n          // Skip algoLen + algo + sigLen\n          signature = signature.slice(4 + keyAlgo.length + 4);\n        }\n\n        if (keyAlgo === 'ssh-dss') {\n          signature = DSASigBareToBER(signature);\n        } else if (keyAlgo !== 'ssh-rsa' && keyAlgo !== 'ssh-dss') {\n          // ECDSA\n          signature = ECDSASigSSHToASN1(signature, self, callback);\n          if (signature === false)\n            return false;\n        }\n\n        blob = new Buffer(4 + outstate.sessionId.length + blobEnd);\n        blob.writeUInt32BE(outstate.sessionId.length, 0, true);\n        outstate.sessionId.copy(blob, 4);\n        payload.copy(blob, 4 + outstate.sessionId.length, 0, blobEnd);\n      }\n\n      methodData = {\n        keyAlgo: keyAlgo,\n        key: key,\n        signature: signature,\n        blob: blob,\n        localHostname: hostname,\n        localUsername: userlocal\n      };\n    } else if (method === 'keyboard-interactive') {\n      // Skip language, it's deprecated\n      var skipLen = readInt(payload, payload._pos, self, callback);\n      if (skipLen === false)\n        return false;\n      methodData = readString(payload,\n                              payload._pos + 4 + skipLen,\n                              'utf8',\n                              self,\n                              callback);\n      if (methodData === false)\n        return false;\n    } else if (method !== 'none')\n      methodData = payload.slice(payload._pos);\n\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: USERAUTH_REQUEST ('\n               + method\n               + ')');\n\n    self._state.authsQueue.push(method);\n    self.emit('USERAUTH_REQUEST', username, svcName, method, methodData);\n  } else if (type === MESSAGE.USERAUTH_SUCCESS) {\n    /*\n      byte      SSH_MSG_USERAUTH_SUCCESS\n    */\n    if (outstate.compress.type === 'zlib@openssh.com')\n      outstate.compress.instance = zlib.createDeflate(ZLIB_OPTS);\n    if (instate.decompress.type === 'zlib@openssh.com')\n      instate.decompress.instance = zlib.createInflate(ZLIB_OPTS);\n    self._state.authsQueue.shift();\n    self.emit('USERAUTH_SUCCESS');\n  } else if (type === MESSAGE.USERAUTH_FAILURE) {\n    /*\n      byte      SSH_MSG_USERAUTH_FAILURE\n      name-list    authentications that can continue\n      boolean      partial success\n    */\n    var auths = readString(payload, 1, 'ascii', self, callback);\n    if (auths === false)\n      return false;\n    var partSuccess = payload[payload._pos];\n    if (partSuccess === undefined)\n      return false;\n\n    partSuccess = (partSuccess !== 0);\n    auths = auths.split(',');\n\n    self._state.authsQueue.shift();\n    self.emit('USERAUTH_FAILURE', auths, partSuccess);\n  } else if (type === MESSAGE.USERAUTH_BANNER) {\n    /*\n      byte      SSH_MSG_USERAUTH_BANNER\n      string    message in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    message = readString(payload, 1, 'utf8', self, callback);\n    if (message === false)\n      return false;\n    lang = readString(payload, payload._pos, 'utf8', self, callback);\n    if (lang === false)\n      return false;\n\n    self.emit('USERAUTH_BANNER', message, lang);\n  } else if (type === MESSAGE.GLOBAL_REQUEST) {\n    /*\n      byte      SSH_MSG_GLOBAL_REQUEST\n      string    request name in US-ASCII only\n      boolean   want reply\n      ....      request-specific data follows\n    */\n    var request = readString(payload, 1, 'ascii', self, callback);\n    if (request === false) {\n      self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: GLOBAL_REQUEST');\n      return false;\n    }\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: GLOBAL_REQUEST ('\n               + request\n               + ')');\n\n    var wantReply = payload[payload._pos++];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n\n    var reqData;\n    if (request === 'tcpip-forward' || request === 'cancel-tcpip-forward') {\n      var bindAddr = readString(payload, payload._pos, 'ascii', self, callback);\n      if (bindAddr === false)\n        return false;\n      var bindPort = readInt(payload, payload._pos, self, callback);\n      if (bindPort === false)\n        return false;\n      reqData = {\n        bindAddr: bindAddr,\n        bindPort: bindPort\n      };\n    } else if (request === 'streamlocal-forward@openssh.com'\n               || request === 'cancel-streamlocal-forward@openssh.com') {\n      socketPath = readString(payload, payload._pos, 'utf8', self, callback);\n      if (socketPath === false)\n        return false;\n      reqData = {\n        socketPath: socketPath\n      };\n    } else if (request === 'no-more-sessions@openssh.com') {\n      // No data\n    } else {\n      reqData = payload.slice(payload._pos);\n    }\n\n    self.emit('GLOBAL_REQUEST', request, wantReply, reqData);\n  } else if (type === MESSAGE.REQUEST_SUCCESS) {\n    /*\n      byte      SSH_MSG_REQUEST_SUCCESS\n      ....      response specific data\n    */\n    if (payload.length > 1)\n      self.emit('REQUEST_SUCCESS', payload.slice(1));\n    else\n      self.emit('REQUEST_SUCCESS');\n  } else if (type === MESSAGE.REQUEST_FAILURE) {\n    /*\n      byte      SSH_MSG_REQUEST_FAILURE\n    */\n    self.emit('REQUEST_FAILURE');\n  } else if (type === MESSAGE.UNIMPLEMENTED) {\n    /*\n      byte      SSH_MSG_UNIMPLEMENTED\n      uint32    packet sequence number of rejected message\n    */\n    // TODO\n  } else if (type === MESSAGE.KEXINIT)\n    return parse_KEXINIT(self, callback);\n  else if (type === MESSAGE.CHANNEL_REQUEST)\n    return parse_CHANNEL_REQUEST(self, callback);\n  else if (type >= 30 && type <= 49) // Key exchange method-specific messages\n    return parse_KEX(self, type, callback);\n  else if (type >= 60 && type <= 70) // User auth context-specific messages\n    return parse_USERAUTH(self, type, callback);\n  else {\n    // Unknown packet type\n    var unimpl = new Buffer(1 + 4);\n    unimpl[0] = MESSAGE.UNIMPLEMENTED;\n    unimpl.writeUInt32BE(seqno, 1, true);\n    send(self, unimpl);\n  }\n}\n\nfunction parse_KEXINIT(self, callback) {\n  var instate = self._state.incoming;\n  var payload = instate.payload;\n\n  /*\n    byte         SSH_MSG_KEXINIT\n    byte[16]     cookie (random bytes)\n    name-list    kex_algorithms\n    name-list    server_host_key_algorithms\n    name-list    encryption_algorithms_client_to_server\n    name-list    encryption_algorithms_server_to_client\n    name-list    mac_algorithms_client_to_server\n    name-list    mac_algorithms_server_to_client\n    name-list    compression_algorithms_client_to_server\n    name-list    compression_algorithms_server_to_client\n    name-list    languages_client_to_server\n    name-list    languages_server_to_client\n    boolean      first_kex_packet_follows\n    uint32       0 (reserved for future extension)\n  */\n  var init = {\n    algorithms: {\n      kex: undefined,\n      srvHostKey: undefined,\n      cs: {\n        encrypt: undefined,\n        mac: undefined,\n        compress: undefined\n      },\n      sc: {\n        encrypt: undefined,\n        mac: undefined,\n        compress: undefined\n      }\n    },\n    languages: {\n      cs: undefined,\n      sc: undefined\n    }\n  };\n  var val;\n\n  val = readList(payload, 17, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.kex = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.srvHostKey = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.cs.encrypt = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.sc.encrypt = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.cs.mac = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.sc.mac = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.cs.compress = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.sc.compress = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.languages.cs = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.languages.sc = val;\n\n  var firstFollows = (payload._pos < payload.length\n                      && payload[payload._pos] === 1);\n\n  instate.kexinit = payload;\n\n  self.emit('KEXINIT', init, firstFollows);\n}\n\nfunction parse_KEX(self, type, callback) {\n  var state = self._state;\n  var instate = state.incoming;\n  var payload = instate.payload;\n  var pktType = (RE_GEX.test(state.kexdh)\n                 ? DYNAMIC_KEXDH_MESSAGE[type]\n                 : KEXDH_MESSAGE[type]);\n\n  if (state.outgoing.status === OUT_READY\n      || instate.expectedPacket !== pktType) {\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, expected: '\n               + instate.expectedPacket\n               + ' but got: '\n               + pktType);\n    self.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n    var err = new Error('Received unexpected packet');\n    err.level = 'protocol';\n    self.emit('error', err);\n    return false;\n  }\n\n  if (RE_GEX.test(state.kexdh)) {\n    // Dynamic group exchange-related\n\n    if (self.server) {\n      // TODO: Support group exchange server-side\n      self.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n      var err = new Error('DH group exchange not supported by server');\n      err.level = 'handshake';\n      self.emit('error', err);\n      return false;\n    } else {\n      if (type === MESSAGE.KEXDH_GEX_GROUP) {\n        /*\n          byte    SSH_MSG_KEX_DH_GEX_GROUP\n          mpint   p, safe prime\n          mpint   g, generator for subgroup in GF(p)\n        */\n        var prime = readString(payload, 1, self, callback);\n        if (prime === false)\n          return false;\n        var gen = readString(payload, payload._pos, self, callback);\n        if (gen === false)\n          return false;\n        self.emit('KEXDH_GEX_GROUP', prime, gen);\n      } else if (type === MESSAGE.KEXDH_GEX_REPLY)\n        return parse_KEXDH_REPLY(self, callback);\n    }\n  } else {\n    // Static group or ECDH-related\n\n    if (type === MESSAGE.KEXDH_INIT) {\n      /*\n        byte      SSH_MSG_KEXDH_INIT\n        mpint     e\n      */\n      var e = readString(payload, 1, self, callback);\n      if (e === false)\n        return false;\n\n      self.emit('KEXDH_INIT', e);\n    } else if (type === MESSAGE.KEXDH_REPLY)\n      return parse_KEXDH_REPLY(self, callback);\n  }\n}\n\nfunction parse_KEXDH_REPLY(self, callback) {\n  var payload = self._state.incoming.payload;\n  /*\n    byte      SSH_MSG_KEXDH_REPLY\n                / SSH_MSG_KEX_DH_GEX_REPLY\n                / SSH_MSG_KEX_ECDH_REPLY\n    string    server public host key and certificates (K_S)\n    mpint     f\n    string    signature of H\n  */\n  var hostkey = readString(payload, 1, self, callback);\n  if (hostkey === false)\n    return false;\n  var pubkey = readString(payload, payload._pos, self, callback);\n  if (pubkey === false)\n    return false;\n  var sig = readString(payload, payload._pos, self, callback);\n  if (sig === false)\n    return false;\n  var info = {\n    hostkey: hostkey,\n    hostkey_format: undefined,\n    pubkey: pubkey,\n    sig: sig,\n    sig_format: undefined\n  };\n  var hostkey_format = readString(hostkey, 0, 'ascii', self, callback);\n  if (hostkey_format === false)\n    return false;\n  info.hostkey_format = hostkey_format;\n  var sig_format = readString(sig, 0, 'ascii', self, callback);\n  if (sig_format === false)\n    return false;\n  info.sig_format = sig_format;\n  self.emit('KEXDH_REPLY', info);\n}\n\nfunction parse_USERAUTH(self, type, callback) {\n  var state = self._state;\n  var authMethod = state.authsQueue[0];\n  var payload = state.incoming.payload;\n  var message;\n  var lang;\n  var text;\n\n  if (authMethod === 'password') {\n    if (type === MESSAGE.USERAUTH_PASSWD_CHANGEREQ) {\n      /*\n        byte      SSH_MSG_USERAUTH_PASSWD_CHANGEREQ\n        string    prompt in ISO-10646 UTF-8 encoding\n        string    language tag\n      */\n      message = readString(payload, 1, 'utf8', self, callback);\n      if (message === false)\n        return false;\n      lang = readString(payload, payload._pos, 'utf8', self, callback);\n      if (lang === false)\n        return false;\n      self.emit('USERAUTH_PASSWD_CHANGEREQ', message, lang);\n    }\n  } else if (authMethod === 'keyboard-interactive') {\n    if (type === MESSAGE.USERAUTH_INFO_REQUEST) {\n      /*\n        byte      SSH_MSG_USERAUTH_INFO_REQUEST\n        string    name (ISO-10646 UTF-8)\n        string    instruction (ISO-10646 UTF-8)\n        string    language tag -- MAY be empty\n        int       num-prompts\n        string    prompt[1] (ISO-10646 UTF-8)\n        boolean   echo[1]\n        ...\n        string    prompt[num-prompts] (ISO-10646 UTF-8)\n        boolean   echo[num-prompts]\n      */\n      var name;\n      var instr;\n      var nprompts;\n\n      name = readString(payload, 1, 'utf8', self, callback);\n      if (name === false)\n        return false;\n      instr = readString(payload, payload._pos, 'utf8', self, callback);\n      if (instr === false)\n        return false;\n      lang = readString(payload, payload._pos, 'utf8', self, callback);\n      if (lang === false)\n        return false;\n      nprompts = readInt(payload, payload._pos, self, callback);\n      if (nprompts === false)\n        return false;\n\n      payload._pos += 4;\n\n      var prompts = [];\n      for (var prompt = 0; prompt < nprompts; ++prompt) {\n        text = readString(payload, payload._pos, 'utf8', self, callback);\n        if (text === false)\n          return false;\n        var echo = payload[payload._pos++];\n        if (echo === undefined)\n          return false;\n        echo = (echo !== 0);\n        prompts.push({\n          prompt: text,\n          echo: echo\n        });\n      }\n      self.emit('USERAUTH_INFO_REQUEST', name, instr, lang, prompts);\n    } else if (type === MESSAGE.USERAUTH_INFO_RESPONSE) {\n      /*\n        byte      SSH_MSG_USERAUTH_INFO_RESPONSE\n        int       num-responses\n        string    response[1] (ISO-10646 UTF-8)\n        ...\n        string    response[num-responses] (ISO-10646 UTF-8)\n      */\n      var nresponses = readInt(payload, 1, self, callback);\n      if (nresponses === false)\n        return false;\n\n      payload._pos = 5;\n\n      var responses = [];\n      for (var response = 0; response < nresponses; ++response) {\n        text = readString(payload, payload._pos, 'utf8', self, callback);\n        if (text === false)\n          return false;\n        responses.push(text);\n      }\n      self.emit('USERAUTH_INFO_RESPONSE', responses);\n    }\n  } else if (authMethod === 'publickey') {\n    if (type === MESSAGE.USERAUTH_PK_OK) {\n      /*\n        byte      SSH_MSG_USERAUTH_PK_OK\n        string    public key algorithm name from the request\n        string    public key blob from the request\n      */\n      var authsQueue = self._state.authsQueue;\n      if (!authsQueue.length || authsQueue[0] !== 'publickey')\n        return;\n      authsQueue.shift();\n      self.emit('USERAUTH_PK_OK');\n      // XXX: Parse public key info? client currently can ignore it because\n      // there is only one outstanding auth request at any given time, so it\n      // knows which key was OK'd\n    }\n  } else if (authMethod !== undefined) {\n    // Invalid packet for this auth type\n    self.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n    var err = new Error('Invalid authentication method: ' + authMethod);\n    err.level = 'protocol';\n    self.emit('error', err);\n  }\n}\n\nfunction parse_CHANNEL_REQUEST(self, callback) {\n  var payload = self._state.incoming.payload;\n  var info;\n  var cols;\n  var rows;\n  var width;\n  var height;\n  var wantReply;\n  var signal;\n\n  var recipient = readInt(payload, 1, self, callback);\n  if (recipient === false)\n    return false;\n  var request = readString(payload, 5, 'ascii', self, callback);\n  if (request === false)\n    return false;\n\n  if (request === 'exit-status') { // Server->Client\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"exit-status\"\n      boolean   FALSE\n      uint32    exit_status\n    */\n    var code = readInt(payload, ++payload._pos, self, callback);\n    if (code === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: false,\n      code: code\n    };\n  } else if (request === 'exit-signal') { // Server->Client\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"exit-signal\"\n      boolean   FALSE\n      string    signal name (without the \"SIG\" prefix)\n      boolean   core dumped\n      string    error message in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    var coredump;\n    if (!(self.remoteBugs & BUGS.OLD_EXIT)) {\n      signal = readString(payload, ++payload._pos, 'ascii', self, callback);\n      if (signal === false)\n        return false;\n      coredump = payload[payload._pos++];\n      if (coredump === undefined)\n        return false;\n      coredump = (coredump !== 0);\n    } else {\n      /*\n        Instead of `signal name` and `core dumped`, we have just:\n\n        uint32  signal number\n      */\n      signal = readInt(payload, ++payload._pos, self, callback);\n      if (signal === false)\n        return false;\n      switch (signal) {\n        case 1:\n          signal = 'HUP';\n          break;\n        case 2:\n          signal = 'INT';\n          break;\n        case 3:\n          signal = 'QUIT';\n          break;\n        case 6:\n          signal = 'ABRT';\n          break;\n        case 9:\n          signal = 'KILL';\n          break;\n        case 14:\n          signal = 'ALRM';\n          break;\n        case 15:\n          signal = 'TERM';\n          break;\n        default:\n          // Unknown or OS-specific\n          signal = 'UNKNOWN (' + signal + ')';\n      }\n      coredump = false;\n    }\n    var description = readString(payload, payload._pos, 'utf8', self,\n                                 callback);\n    if (description === false)\n      return false;\n    var lang = readString(payload, payload._pos, 'utf8', self, callback);\n    if (lang === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: false,\n      signal: signal,\n      coredump: coredump,\n      description: description,\n      lang: lang\n    };\n  } else if (request === 'pty-req') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"pty-req\"\n      boolean   want_reply\n      string    TERM environment variable value (e.g., vt100)\n      uint32    terminal width, characters (e.g., 80)\n      uint32    terminal height, rows (e.g., 24)\n      uint32    terminal width, pixels (e.g., 640)\n      uint32    terminal height, pixels (e.g., 480)\n      string    encoded terminal modes\n    */\n    wantReply = payload[payload._pos++];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    var term = readString(payload, payload._pos, 'ascii', self, callback);\n    if (term === false)\n      return false;\n    cols = readInt(payload, payload._pos, self, callback);\n    if (cols === false)\n      return false;\n    rows = readInt(payload, payload._pos += 4, self, callback);\n    if (rows === false)\n      return false;\n    width = readInt(payload, payload._pos += 4, self, callback);\n    if (width === false)\n      return false;\n    height = readInt(payload, payload._pos += 4, self, callback);\n    if (height === false)\n      return false;\n    var modes = readString(payload, payload._pos += 4, self, callback);\n    if (modes === false)\n      return false;\n    modes = bytesToModes(modes);\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply,\n      term: term,\n      cols: cols,\n      rows: rows,\n      width: width,\n      height: height,\n      modes: modes\n    };\n  } else if (request === 'window-change') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"window-change\"\n      boolean   FALSE\n      uint32    terminal width, columns\n      uint32    terminal height, rows\n      uint32    terminal width, pixels\n      uint32    terminal height, pixels\n    */\n    cols = readInt(payload, ++payload._pos, self, callback);\n    if (cols === false)\n      return false;\n    rows = readInt(payload, payload._pos += 4, self, callback);\n    if (rows === false)\n      return false;\n    width = readInt(payload, payload._pos += 4, self, callback);\n    if (width === false)\n      return false;\n    height = readInt(payload, payload._pos += 4, self, callback);\n    if (height === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: false,\n      cols: cols,\n      rows: rows,\n      width: width,\n      height: height\n    };\n  } else if (request === 'x11-req') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"x11-req\"\n      boolean   want reply\n      boolean   single connection\n      string    x11 authentication protocol\n      string    x11 authentication cookie\n      uint32    x11 screen number\n    */\n    wantReply = payload[payload._pos++];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    var single = payload[payload._pos++];\n    if (single === undefined)\n      return false;\n    single = (single !== 0);\n    var protocol = readString(payload, payload._pos, 'ascii', self, callback);\n    if (protocol === false)\n      return false;\n    var cookie = readString(payload, payload._pos, 'hex', self, callback);\n    if (cookie === false)\n      return false;\n    var screen = readInt(payload, payload._pos, self, callback);\n    if (screen === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply,\n      single: single,\n      protocol: protocol,\n      cookie: cookie,\n      screen: screen\n    };\n  } else if (request === 'env') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"env\"\n      boolean   want reply\n      string    variable name\n      string    variable value\n    */\n    wantReply = payload[payload._pos++];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    var key = readString(payload, payload._pos, 'utf8', self, callback);\n    if (key === false)\n      return false;\n    var val = readString(payload, payload._pos, 'utf8', self, callback);\n    if (val === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply,\n      key: key,\n      val: val\n    };\n  } else if (request === 'shell') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"shell\"\n      boolean   want reply\n    */\n    wantReply = payload[payload._pos];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply\n    };\n  } else if (request === 'exec') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"exec\"\n      boolean   want reply\n      string    command\n    */\n    wantReply = payload[payload._pos++];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    var command = readString(payload, payload._pos, 'utf8', self, callback);\n    if (command === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply,\n      command: command\n    };\n  } else if (request === 'subsystem') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"subsystem\"\n      boolean   want reply\n      string    subsystem name\n    */\n    wantReply = payload[payload._pos++];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    var subsystem = readString(payload, payload._pos, 'utf8', self, callback);\n    if (subsystem === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply,\n      subsystem: subsystem\n    };\n  } else if (request === 'signal') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"signal\"\n      boolean   FALSE\n      string    signal name (without the \"SIG\" prefix)\n    */\n    signal = readString(payload, ++payload._pos, 'ascii', self, callback);\n    if (signal === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: false,\n      signal: 'SIG' + signal\n    };\n  } else if (request === 'xon-xoff') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"xon-xoff\"\n      boolean   FALSE\n      boolean   client can do\n    */\n    var clientControl = payload[++payload._pos];\n    if (clientControl === undefined)\n      return false;\n    clientControl = (clientControl !== 0);\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: false,\n      clientControl: clientControl\n    };\n  } else if (request === 'auth-agent-req@openssh.com') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"auth-agent-req@openssh.com\"\n      boolean   want reply\n    */\n    wantReply = payload[payload._pos];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply\n    };\n  } else {\n    // Unknown request type\n    wantReply = payload[payload._pos];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply\n    };\n  }\n  self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_REQUEST ('\n             + recipient\n             + ', '\n             + request\n             + ')');\n  self.emit('CHANNEL_REQUEST:' + recipient, info);\n}\n\nfunction hmacVerify(self, data) {\n  var instate = self._state.incoming;\n  var hmac = instate.hmac;\n\n  self.debug('DEBUG: Parser: Verifying MAC');\n\n  if (instate.decrypt.isGCM) {\n    var decrypt = instate.decrypt;\n    var instance = decrypt.instance;\n\n    instance.setAuthTag(data);\n\n    var payload = instance.update(instate.packet);\n    instate.payload = payload.slice(1, instate.packet.length + 4 - payload[0]);\n    //instance.final();\n    iv_inc(decrypt.iv);\n\n    decrypt.instance = crypto.createDecipheriv(\n                         SSH_TO_OPENSSL[decrypt.type],\n                         decrypt.key,\n                         decrypt.iv\n                       );\n    decrypt.instance.setAutoPadding(false);\n    return true;\n  } else {\n    var calcHmac = crypto.createHmac(SSH_TO_OPENSSL[hmac.type], hmac.key);\n\n    hmac.bufCompute.writeUInt32BE(instate.seqno, 0, true);\n    hmac.bufCompute.writeUInt32BE(instate.pktLen, 4, true);\n    hmac.bufCompute[8] = instate.padLen;\n\n    calcHmac.update(hmac.bufCompute);\n    calcHmac.update(instate.packet);\n\n    var mac = calcHmac.digest('binary');\n    if (mac.length > instate.hmac.size)\n      mac = mac.slice(0, instate.hmac.size);\n    return (mac === data.toString('binary'));\n  }\n}\n\nfunction decryptData(self, data) {\n  var instance = self._state.incoming.decrypt.instance;\n  self.debug('DEBUG: Parser: Decrypting');\n  return instance.update(data);\n}\n\nfunction expectData(self, type, amount, bufferKey) {\n  var expect = self._state.incoming.expect;\n  expect.amount = amount;\n  expect.type = type;\n  expect.ptr = 0;\n  if (bufferKey && self[bufferKey])\n    expect.buf = self[bufferKey];\n  else if (amount)\n    expect.buf = new Buffer(amount);\n}\n\nfunction readList(buffer, start, stream, callback) {\n  var list = readString(buffer, start, 'ascii', stream, callback);\n  return (list !== false ? (list.length ? list.split(',') : []) : false);\n}\n\nfunction bytesToModes(buffer) {\n  var modes = {};\n\n  for (var i = 0, len = buffer.length, opcode; i < len; i += 5) {\n    opcode = buffer[i];\n    if (opcode === TERMINAL_MODE.TTY_OP_END\n        || TERMINAL_MODE[opcode] === undefined\n        || i + 5 > len)\n      break;\n    modes[TERMINAL_MODE[opcode]] = buffer.readUInt32BE(i + 1, true);\n  }\n\n  return modes;\n}\n\nfunction modesToBytes(modes) {\n  var RE_IS_NUM = /^\\d+$/;\n  var keys = Object.keys(modes);\n  var b = 0;\n  var bytes = [];\n\n  for (var i = 0, len = keys.length, key, opcode, val; i < len; ++i) {\n    key = keys[i];\n    opcode = TERMINAL_MODE[key];\n    if (opcode\n        && !RE_IS_NUM.test(key)\n        && typeof modes[key] === 'number'\n        && key !== 'TTY_OP_END') {\n      val = modes[key];\n      bytes[b++] = opcode;\n      bytes[b++] = (val >>> 24) & 0xFF;\n      bytes[b++] = (val >>> 16) & 0xFF;\n      bytes[b++] = (val >>> 8) & 0xFF;\n      bytes[b++] = val & 0xFF;\n    }\n  }\n\n  bytes[b] = TERMINAL_MODE.TTY_OP_END;\n\n  return bytes;\n}\n\n// Shared outgoing functions\nfunction KEXINIT(self, cb) { // Client/Server\n  randBytes(16, function(myCookie) {\n    /*\n      byte         SSH_MSG_KEXINIT\n      byte[16]     cookie (random bytes)\n      name-list    kex_algorithms\n      name-list    server_host_key_algorithms\n      name-list    encryption_algorithms_client_to_server\n      name-list    encryption_algorithms_server_to_client\n      name-list    mac_algorithms_client_to_server\n      name-list    mac_algorithms_server_to_client\n      name-list    compression_algorithms_client_to_server\n      name-list    compression_algorithms_server_to_client\n      name-list    languages_client_to_server\n      name-list    languages_server_to_client\n      boolean      first_kex_packet_follows\n      uint32       0 (reserved for future extension)\n    */\n    var algos = self.config.algorithms;\n\n    var kexBuf = algos.kexBuf;\n    if (self.remoteBugs & BUGS.BAD_DHGEX) {\n      var copied = false;\n      var kexList = algos.kex;\n      for (var j = kexList.length - 1; j >= 0; --j) {\n        if (kexList[j].indexOf('group-exchange') !== -1) {\n          if (!copied) {\n            kexList = kexList.slice();\n            copied = true;\n          }\n          kexList.splice(j, 1);\n        }\n      }\n      if (copied)\n        kexBuf = new Buffer(kexList.join(','));\n    }\n\n    var hostKeyBuf = algos.serverHostKeyBuf;\n\n    var kexInitSize = 1 + 16\n                      + 4 + kexBuf.length\n                      + 4 + hostKeyBuf.length\n                      + (2 * (4 + algos.cipherBuf.length))\n                      + (2 * (4 + algos.hmacBuf.length))\n                      + (2 * (4 + algos.compressBuf.length))\n                      + (2 * (4 /* languages skipped */))\n                      + 1 + 4;\n    var buf = new Buffer(kexInitSize);\n    var p = 17;\n\n    buf.fill(0);\n\n    buf[0] = MESSAGE.KEXINIT;\n\n    if (myCookie !== false)\n      myCookie.copy(buf, 1);\n\n    buf.writeUInt32BE(kexBuf.length, p, true);\n    p += 4;\n    kexBuf.copy(buf, p);\n    p += kexBuf.length;\n\n    buf.writeUInt32BE(hostKeyBuf.length, p, true);\n    p += 4;\n    hostKeyBuf.copy(buf, p);\n    p += hostKeyBuf.length;\n\n    buf.writeUInt32BE(algos.cipherBuf.length, p, true);\n    p += 4;\n    algos.cipherBuf.copy(buf, p);\n    p += algos.cipherBuf.length;\n\n    buf.writeUInt32BE(algos.cipherBuf.length, p, true);\n    p += 4;\n    algos.cipherBuf.copy(buf, p);\n    p += algos.cipherBuf.length;\n\n    buf.writeUInt32BE(algos.hmacBuf.length, p, true);\n    p += 4;\n    algos.hmacBuf.copy(buf, p);\n    p += algos.hmacBuf.length;\n\n    buf.writeUInt32BE(algos.hmacBuf.length, p, true);\n    p += 4;\n    algos.hmacBuf.copy(buf, p);\n    p += algos.hmacBuf.length;\n\n    buf.writeUInt32BE(algos.compressBuf.length, p, true);\n    p += 4;\n    algos.compressBuf.copy(buf, p);\n    p += algos.compressBuf.length;\n\n    buf.writeUInt32BE(algos.compressBuf.length, p, true);\n    p += 4;\n    algos.compressBuf.copy(buf, p);\n    p += algos.compressBuf.length;\n\n    // Skip language lists, first_kex_packet_follows, and reserved bytes\n\n    self.debug('DEBUG: Outgoing: Writing KEXINIT');\n\n    self._state.incoming.expectedPacket = 'KEXINIT';\n\n    var outstate = self._state.outgoing;\n\n    outstate.kexinit = buf;\n\n    if (outstate.status === OUT_READY) {\n      // We are the one starting the rekeying process ...\n      outstate.status = OUT_REKEYING;\n    }\n\n    send(self, buf, cb, true);\n  });\n  return true;\n}\n\nfunction KEXDH_INIT(self) { // Client\n  var state = self._state;\n  var outstate = state.outgoing;\n  var buf = new Buffer(1 + 4 + outstate.pubkey.length);\n\n  if (RE_GEX.test(state.kexdh)) {\n    state.incoming.expectedPacket = 'KEXDH_GEX_REPLY';\n    buf[0] = MESSAGE.KEXDH_GEX_INIT;\n    self.debug('DEBUG: Outgoing: Writing KEXDH_GEX_INIT');\n  } else {\n    state.incoming.expectedPacket = 'KEXDH_REPLY';\n    buf[0] = MESSAGE.KEXDH_INIT;\n    if (state.kexdh !== 'group')\n      self.debug('DEBUG: Outgoing: Writing KEXECDH_INIT');\n    else\n      self.debug('DEBUG: Outgoing: Writing KEXDH_INIT');\n  }\n\n  buf.writeUInt32BE(outstate.pubkey.length, 1, true);\n  outstate.pubkey.copy(buf, 5);\n\n  return send(self, buf, undefined, true);\n}\n\nfunction KEXDH_REPLY(self, e) { // Server\n  var state = self._state;\n  var outstate = state.outgoing;\n  var instate = state.incoming;\n  var curHostKey = self.config.hostKeys[state.hostkeyFormat];\n  var hostkey = curHostKey.publicKey.public;\n  var hostkeyAlgo = curHostKey.publicKey.fulltype;\n  var privateKey = curHostKey.privateKey.privateOrig;\n\n  // e === client DH public key\n\n  var slicepos = -1;\n  for (var i = 0, len = e.length; i < len; ++i) {\n    if (e[i] === 0)\n      ++slicepos;\n    else\n      break;\n  }\n  if (slicepos > -1)\n    e = e.slice(slicepos + 1);\n\n  var secret = tryComputeSecret(state.kex, e);\n  if (secret instanceof Error) {\n    secret.message = 'Error while computing DH secret ('\n                     + state.kexdh + '): '\n                     + secret.message;\n    secret.level = 'handshake';\n    self.emit('error', secret);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  var hashAlgo;\n  if (state.kexdh === 'group')\n    hashAlgo = 'sha1';\n  else\n    hashAlgo = RE_KEX_HASH.exec(state.kexdh)[1];\n\n  var hash = crypto.createHash(hashAlgo);\n\n  var len_ident = Buffer.byteLength(instate.identRaw);\n  var len_sident = Buffer.byteLength(self.config.ident);\n  var len_init = instate.kexinit.length;\n  var len_sinit = outstate.kexinit.length;\n  var len_hostkey = hostkey.length;\n  var len_pubkey = e.length;\n  var len_spubkey = outstate.pubkey.length;\n  var len_secret = secret.length;\n\n  var idx_spubkey = 0;\n  var idx_secret = 0;\n\n  while (outstate.pubkey[idx_spubkey] === 0x00) {\n    ++idx_spubkey;\n    --len_spubkey;\n  }\n  while (secret[idx_secret] === 0x00) {\n    ++idx_secret;\n    --len_secret;\n  }\n  if (e[0] & 0x80)\n    ++len_pubkey;\n  if (outstate.pubkey[idx_spubkey] & 0x80)\n    ++len_spubkey;\n  if (secret[idx_secret] & 0x80)\n    ++len_secret;\n\n  var exchangeBufLen = len_ident\n                       + len_sident\n                       + len_init\n                       + len_sinit\n                       + len_hostkey\n                       + len_pubkey\n                       + len_spubkey\n                       + len_secret\n                       + (4 * 8); // Length fields for above values\n\n  // Group exchange-related\n  var isGEX = RE_GEX.test(state.kexdh);\n  var len_gex_prime = 0;\n  var len_gex_gen = 0;\n  var idx_gex_prime = 0;\n  var idx_gex_gen = 0;\n  var gex_prime;\n  var gex_gen;\n  if (isGEX) {\n    gex_prime = state.kex.getPrime();\n    gex_gen = state.kex.getGenerator();\n    len_gex_prime = gex_prime.length;\n    len_gex_gen = gex_gen.length;\n    while (gex_prime[idx_gex_prime] === 0x00) {\n      ++idx_gex_prime;\n      --len_gex_prime;\n    }\n    while (gex_gen[idx_gex_gen] === 0x00) {\n      ++idx_gex_gen;\n      --len_gex_gen;\n    }\n    if (gex_prime[idx_gex_prime] & 0x80)\n      ++len_gex_prime;\n    if (gex_gen[idx_gex_gen] & 0x80)\n      ++len_gex_gen;\n    exchangeBufLen += (4 * 3); // min, n, max values\n    exchangeBufLen += (4 * 2); // prime, generator length fields\n    exchangeBufLen += len_gex_prime;\n    exchangeBufLen += len_gex_gen;\n  }\n\n  var bp = 0;\n  var exchangeBuf = new Buffer(exchangeBufLen);\n\n  exchangeBuf.writeUInt32BE(len_ident, bp, true);\n  bp += 4;\n  exchangeBuf.write(instate.identRaw, bp, 'utf8'); // V_C\n  bp += len_ident;\n\n  exchangeBuf.writeUInt32BE(len_sident, bp, true);\n  bp += 4;\n  exchangeBuf.write(self.config.ident, bp, 'utf8'); // V_S\n  bp += len_sident;\n\n  exchangeBuf.writeUInt32BE(len_init, bp, true);\n  bp += 4;\n  instate.kexinit.copy(exchangeBuf, bp); // I_C\n  bp += len_init;\n  instate.kexinit = undefined;\n\n  exchangeBuf.writeUInt32BE(len_sinit, bp, true);\n  bp += 4;\n  outstate.kexinit.copy(exchangeBuf, bp); // I_S\n  bp += len_sinit;\n  outstate.kexinit = undefined;\n\n  exchangeBuf.writeUInt32BE(len_hostkey, bp, true);\n  bp += 4;\n  hostkey.copy(exchangeBuf, bp); // K_S\n  bp += len_hostkey;\n\n  if (isGEX) {\n    KEXDH_GEX_REQ_PACKET.slice(1).copy(exchangeBuf, bp); // min, n, max\n    bp += (4 * 3); // Skip over bytes just copied\n\n    exchangeBuf.writeUInt32BE(len_gex_prime, bp, true);\n    bp += 4;\n    if (gex_prime[idx_gex_prime] & 0x80)\n      exchangeBuf[bp++] = 0;\n    gex_prime.copy(exchangeBuf, bp, idx_gex_prime); // p\n    bp += len_gex_prime - (gex_prime[idx_gex_prime] & 0x80 ? 1 : 0);\n\n    exchangeBuf.writeUInt32BE(len_gex_gen, bp, true);\n    bp += 4;\n    if (gex_gen[idx_gex_gen] & 0x80)\n      exchangeBuf[bp++] = 0;\n    gex_gen.copy(exchangeBuf, bp, idx_gex_gen); // g\n    bp += len_gex_gen - (gex_gen[idx_gex_gen] & 0x80 ? 1 : 0);\n  }\n\n  exchangeBuf.writeUInt32BE(len_pubkey, bp, true);\n  bp += 4;\n  if (e[0] & 0x80)\n    exchangeBuf[bp++] = 0;\n  e.copy(exchangeBuf, bp); // e\n  bp += len_pubkey - (e[0] & 0x80 ? 1 : 0);\n\n  exchangeBuf.writeUInt32BE(len_spubkey, bp, true);\n  bp += 4;\n  if (outstate.pubkey[idx_spubkey] & 0x80)\n    exchangeBuf[bp++] = 0;\n  outstate.pubkey.copy(exchangeBuf, bp, idx_spubkey); // f\n  bp += len_spubkey - (outstate.pubkey[idx_spubkey] & 0x80 ? 1 : 0);\n\n  exchangeBuf.writeUInt32BE(len_secret, bp, true);\n  bp += 4;\n  if (secret[idx_secret] & 0x80)\n    exchangeBuf[bp++] = 0;\n  secret.copy(exchangeBuf, bp, idx_secret); // K\n\n  outstate.exchangeHash = hash.update(exchangeBuf).digest(); // H\n\n  if (outstate.sessionId === undefined)\n    outstate.sessionId = outstate.exchangeHash;\n  outstate.kexsecret = secret;\n\n  var signAlgo;\n  switch (hostkeyAlgo) {\n    case 'ssh-rsa':\n      signAlgo = 'RSA-SHA1';\n      break;\n    case 'ssh-dss':\n      signAlgo = 'DSA-SHA1';\n      break;\n    case 'ecdsa-sha2-nistp256':\n      signAlgo = 'sha256';\n      break;\n    case 'ecdsa-sha2-nistp384':\n      signAlgo = 'sha384';\n      break;\n    case 'ecdsa-sha2-nistp521':\n      signAlgo = 'sha512';\n      break;\n  }\n  var signer = crypto.createSign(signAlgo);\n  var signature;\n  signer.update(outstate.exchangeHash);\n  signature = trySign(signer, privateKey);\n  if (signature instanceof Error) {\n    signature.message = 'Error while signing data with host key ('\n                        + hostkeyAlgo + '): '\n                        + signature.message;\n    signature.level = 'handshake';\n    self.emit('error', signature);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (signAlgo === 'DSA-SHA1') {\n    signature = DSASigBERToBare(signature);\n  } else if (signAlgo !== 'RSA-SHA1') {\n    // ECDSA\n    signature = ECDSASigASN1ToSSH(signature);\n  }\n\n  /*\n    byte      SSH_MSG_KEXDH_REPLY\n    string    server public host key and certificates (K_S)\n    mpint     f\n    string    signature of H\n  */\n\n  var siglen = 4 + hostkeyAlgo.length + 4 + signature.length;\n  var buf = new Buffer(1\n                       + 4 + len_hostkey\n                       + 4 + len_spubkey\n                       + 4 + siglen);\n\n  bp = 0;\n  buf[bp] = (!isGEX ? MESSAGE.KEXDH_REPLY : MESSAGE.KEXDH_GEX_REPLY);\n  ++bp;\n\n  buf.writeUInt32BE(len_hostkey, bp, true);\n  bp += 4;\n  hostkey.copy(buf, bp); // K_S\n  bp += len_hostkey;\n\n  buf.writeUInt32BE(len_spubkey, bp, true);\n  bp += 4;\n  if (outstate.pubkey[idx_spubkey] & 0x80)\n    buf[bp++] = 0;\n  outstate.pubkey.copy(buf, bp, idx_spubkey); // f\n  bp += len_spubkey - (outstate.pubkey[idx_spubkey] & 0x80 ? 1 : 0);\n\n  buf.writeUInt32BE(siglen, bp, true);\n  bp += 4;\n  buf.writeUInt32BE(hostkeyAlgo.length, bp, true);\n  bp += 4;\n  buf.write(hostkeyAlgo, bp, hostkeyAlgo.length, 'ascii');\n  bp += hostkeyAlgo.length;\n  buf.writeUInt32BE(signature.length, bp, true);\n  bp += 4;\n  signature.copy(buf, bp);\n\n  state.incoming.expectedPacket = 'NEWKEYS';\n\n  if (isGEX)\n    self.debug('DEBUG: Outgoing: Writing KEXDH_GEX_REPLY');\n  else if (state.kexdh !== 'group')\n    self.debug('DEBUG: Outgoing: Writing KEXECDH_REPLY');\n  else\n    self.debug('DEBUG: Outgoing: Writing KEXDH_REPLY');\n  send(self, buf, undefined, true);\n\n  outstate.sentNEWKEYS = true;\n  self.debug('DEBUG: Outgoing: Writing NEWKEYS');\n  return send(self, NEWKEYS_PACKET, undefined, true);\n}\n\nfunction KEXDH_GEX_REQ(self) { // Client\n  self._state.incoming.expectedPacket = 'KEXDH_GEX_GROUP';\n\n  self.debug('DEBUG: Outgoing: Writing KEXDH_GEX_REQUEST');\n  return send(self, KEXDH_GEX_REQ_PACKET, undefined, true);\n}\n\nfunction send(self, payload, cb, bypass) {\n  var state = self._state;\n\n  if (!state)\n    return false;\n\n  var outstate = state.outgoing;\n  if (outstate.status === OUT_REKEYING && !bypass) {\n    if (typeof cb === 'function')\n      outstate.rekeyQueue.push([payload, cb]);\n    else\n      outstate.rekeyQueue.push(payload);\n    return false;\n  } else if (self._readableState.ended || self._writableState.ended)\n    return false;\n\n  var compress = outstate.compress.instance;\n  if (compress) {\n    compress.write(payload);\n    compress.flush(Z_PARTIAL_FLUSH, function() {\n      if (self._readableState.ended || self._writableState.ended)\n        return;\n      send_(self, compress.read(), cb);\n    });\n    return true;\n  } else\n    return send_(self, payload, cb);\n}\n\nfunction send_(self, payload, cb) {\n  // TODO: Implement length checks\n\n  var state = self._state;\n  var outstate = state.outgoing;\n  var encrypt = outstate.encrypt;\n  var hmac = outstate.hmac;\n  var pktLen;\n  var padLen;\n  var buf;\n  var mac;\n  var ret;\n\n  pktLen = payload.length + 9;\n\n  if (encrypt.instance !== false && encrypt.isGCM) {\n    var ptlen = 1 + payload.length + 4 /* Must have at least 4 bytes padding*/;\n    while ((ptlen % encrypt.size) !== 0)\n      ++ptlen;\n    padLen = ptlen - 1 - payload.length;\n    pktLen = 4 + ptlen;\n  } else {\n    pktLen += ((encrypt.size - 1) * pktLen) % encrypt.size;\n    padLen = pktLen - payload.length - 5;\n  }\n\n  buf = new Buffer(pktLen);\n\n  buf.writeUInt32BE(pktLen - 4, 0, true);\n  buf[4] = padLen;\n  payload.copy(buf, 5);\n\n  var padBytes = crypto.randomBytes(padLen);\n  padBytes.copy(buf, 5 + payload.length);\n\n  if (hmac.type !== false && hmac.key) {\n    mac = crypto.createHmac(SSH_TO_OPENSSL[hmac.type], hmac.key);\n    outstate.bufSeqno.writeUInt32BE(outstate.seqno, 0, true);\n    mac.update(outstate.bufSeqno);\n    mac.update(buf);\n    mac = mac.digest();\n    if (mac.length > outstate.hmac.size)\n      mac = mac.slice(0, outstate.hmac.size);\n  }\n\n  var nb = 0;\n  var encData;\n\n  if (encrypt.instance !== false) {\n    if (encrypt.isGCM) {\n      var encrypter = crypto.createCipheriv(SSH_TO_OPENSSL[encrypt.type],\n                                            encrypt.key,\n                                            encrypt.iv);\n      encrypter.setAutoPadding(false);\n\n      var lenbuf = buf.slice(0, 4);\n\n      encrypter.setAAD(lenbuf);\n      self.push(lenbuf);\n      nb += lenbuf;\n\n      encData = encrypter.update(buf.slice(4));\n      self.push(encData);\n      nb += encData.length;\n\n      var final = encrypter.final();\n      if (final.length) {\n        self.push(final);\n        nb += final.length;\n      }\n\n      var authTag = encrypter.getAuthTag();\n      ret = self.push(authTag);\n      nb += authTag.length;\n\n      iv_inc(encrypt.iv);\n    } else {\n      encData = encrypt.instance.update(buf);\n      self.push(encData);\n      nb += encData.length;\n\n      ret = self.push(mac);\n      nb += mac.length;\n    }\n  } else {\n    ret = self.push(buf);\n    nb = buf.length;\n  }\n\n  self.bytesSent += nb;\n\n  if (++outstate.seqno > MAX_SEQNO)\n    outstate.seqno = 0;\n\n  cb && cb();\n\n  return ret;\n}\n\nfunction randBytes(n, cb) {\n  crypto.randomBytes(n, function retry(err, buf) {\n    if (err)\n      return crypto.randomBytes(n, retry);\n    cb && cb(buf);\n  });\n}\n\nfunction trySign(sig, key) {\n  try {\n    return sig.sign(key);\n  } catch (err) {\n    return err;\n  }\n}\n\nfunction tryComputeSecret(dh, e) {\n  try {\n    return dh.computeSecret(e);\n  } catch (err) {\n    return err;\n  }\n}\n\nmodule.exports = SSH2Stream;\nmodule.exports._send = send;\n","module.exports = require(\"zlib\");","module.exports = require(\"buffer\");","/*\n  Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation\n  by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool\n*/\nvar EventEmitter = require('events').EventEmitter,\n    inherits = require('util').inherits;\n\nfunction jsmemcmp(buf1, pos1, buf2, pos2, num) {\n  for (var i = 0; i < num; ++i, ++pos1, ++pos2)\n    if (buf1[pos1] !== buf2[pos2])\n      return false;\n  return true;\n}\n\nfunction SBMH(needle) {\n  if (typeof needle === 'string')\n    needle = new Buffer(needle);\n  var i, j, needle_len = needle.length;\n\n  this.maxMatches = Infinity;\n  this.matches = 0;\n\n  this._occ = new Array(256);\n  this._lookbehind_size = 0;\n  this._needle = needle;\n  this._bufpos = 0;\n\n  this._lookbehind = new Buffer(needle_len);\n\n  // Initialize occurrence table.\n  for (j = 0; j < 256; ++j)\n    this._occ[j] = needle_len;\n\n  // Populate occurrence table with analysis of the needle,\n  // ignoring last letter.\n  if (needle_len >= 1) {\n    for (i = 0; i < needle_len - 1; ++i)\n      this._occ[needle[i]] = needle_len - 1 - i;\n  }\n}\ninherits(SBMH, EventEmitter);\n\nSBMH.prototype.reset = function() {\n  this._lookbehind_size = 0;\n  this.matches = 0;\n  this._bufpos = 0;\n};\n\nSBMH.prototype.push = function(chunk, pos) {\n  var r, chlen;\n  if (!Buffer.isBuffer(chunk))\n    chunk = new Buffer(chunk, 'binary');\n  chlen = chunk.length;\n  this._bufpos = pos || 0;\n  while (r !== chlen && this.matches < this.maxMatches)\n    r = this._sbmh_feed(chunk);\n  return r;\n};\n\nSBMH.prototype._sbmh_feed = function(data) {\n  var len = data.length, needle = this._needle, needle_len = needle.length;\n\n  // Positive: points to a position in `data`\n  //           pos == 3 points to data[3]\n  // Negative: points to a position in the lookbehind buffer\n  //           pos == -2 points to lookbehind[lookbehind_size - 2]\n  var pos = -this._lookbehind_size,\n      last_needle_char = needle[needle_len - 1],\n      occ = this._occ,\n      lookbehind = this._lookbehind;\n\n  if (pos < 0) {\n    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool\n    // search with character lookup code that considers both the\n    // lookbehind buffer and the current round's haystack data.\n    //\n    // Loop until\n    //   there is a match.\n    // or until\n    //   we've moved past the position that requires the\n    //   lookbehind buffer. In this case we switch to the\n    //   optimized loop.\n    // or until\n    //   the character to look at lies outside the haystack.\n    while (pos < 0 && pos <= len - needle_len) {\n       var ch = this._sbmh_lookup_char(data, pos + needle_len - 1);\n\n      if (ch === last_needle_char\n          && this._sbmh_memcmp(data, pos, needle_len - 1)) {\n        this._lookbehind_size = 0;\n        ++this.matches;\n        if (pos > -this._lookbehind_size)\n          this.emit('info', true, lookbehind, 0, this._lookbehind_size + pos);\n        else\n          this.emit('info', true);\n\n        this._bufpos = pos + needle_len;\n        return pos + needle_len;\n      } else\n        pos += occ[ch];\n    }\n\n    // No match.\n\n    if (pos < 0) {\n      // There's too few data for Boyer-Moore-Horspool to run,\n      // so let's use a different algorithm to skip as much as\n      // we can.\n      // Forward pos until\n      //   the trailing part of lookbehind + data\n      //   looks like the beginning of the needle\n      // or until\n      //   pos == 0\n      while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos))\n        pos++;\n    }\n\n    if (pos >= 0) {\n      // Discard lookbehind buffer.\n      this.emit('info', false, lookbehind, 0, this._lookbehind_size);\n      this._lookbehind_size = 0;\n    } else {\n      // Cut off part of the lookbehind buffer that has\n      // been processed and append the entire haystack\n      // into it.\n      var bytesToCutOff = this._lookbehind_size + pos;\n\n      if (bytesToCutOff > 0) {\n        // The cut off data is guaranteed not to contain the needle.\n        this.emit('info', false, lookbehind, 0, bytesToCutOff);\n      }\n\n      lookbehind.copy(lookbehind, 0, bytesToCutOff,\n                      this._lookbehind_size - bytesToCutOff);\n      this._lookbehind_size -= bytesToCutOff;\n\n      data.copy(lookbehind, this._lookbehind_size);\n      this._lookbehind_size += len;\n\n      this._bufpos = len;\n      return len;\n    }\n  }\n\n  if (pos >= 0)\n    pos += this._bufpos;\n\n  // Lookbehind buffer is now empty. Perform Boyer-Moore-Horspool\n  // search with optimized character lookup code that only considers\n  // the current round's haystack data.\n  while (pos <= len - needle_len) {\n    var ch = data[pos + needle_len - 1];\n\n    if (ch === last_needle_char\n        && data[pos] === needle[0]\n        && jsmemcmp(needle, 0, data, pos, needle_len - 1)) {\n      ++this.matches;\n      if (pos > 0)\n        this.emit('info', true, data, this._bufpos, pos);\n      else\n        this.emit('info', true);\n\n      this._bufpos = pos + needle_len;\n      return pos + needle_len;\n    } else\n      pos += occ[ch];\n  }\n\n  // There was no match. If there's trailing haystack data that we cannot\n  // match yet using the Boyer-Moore-Horspool algorithm (because the trailing\n  // data is less than the needle size) then match using a modified\n  // algorithm that starts matching from the beginning instead of the end.\n  // Whatever trailing data is left after running this algorithm is added to\n  // the lookbehind buffer.\n  if (pos < len) {\n    while (pos < len && (data[pos] !== needle[0]\n                         || !jsmemcmp(data, pos, needle, 0, len - pos))) {\n      ++pos;\n    }\n    if (pos < len) {\n      data.copy(lookbehind, 0, pos, pos + (len - pos));\n      this._lookbehind_size = len - pos;\n    }\n  }\n\n  // Everything until pos is guaranteed not to contain needle data.\n  if (pos > 0)\n    this.emit('info', false, data, this._bufpos, pos < len ? pos : len);\n\n  this._bufpos = len;\n  return len;\n};\n\nSBMH.prototype._sbmh_lookup_char = function(data, pos) {\n  if (pos < 0)\n    return this._lookbehind[this._lookbehind_size + pos];\n  else\n    return data[pos];\n}\n\nSBMH.prototype._sbmh_memcmp = function(data, pos, len) {\n  var i = 0;\n\n  while (i < len) {\n    if (this._sbmh_lookup_char(data, pos + i) === this._needle[i])\n      ++i;\n    else\n      return false;\n  }\n  return true;\n}\n\nmodule.exports = SBMH;\n","var Socket = require('net').Socket;\nvar EventEmitter = require('events').EventEmitter;\nvar inherits = require('util').inherits;\nvar path = require('path');\nvar fs = require('fs');\nvar cp = require('child_process');\n\nvar REQUEST_IDENTITIES = 11;\nvar IDENTITIES_ANSWER = 12;\nvar SIGN_REQUEST = 13;\nvar SIGN_RESPONSE = 14;\nvar FAILURE = 5;\n\nvar RE_CYGWIN_SOCK = /^\\!<socket >(\\d+) s ([A-Z0-9]{8}\\-[A-Z0-9]{8}\\-[A-Z0-9]{8}\\-[A-Z0-9]{8})/;\n\nmodule.exports = function(sockPath, key, keyType, data, cb) {\n  var sock;\n  var error;\n  var sig;\n  var datalen;\n  var keylen = 0;\n  var isSigning = Buffer.isBuffer(key);\n  var type;\n  var count = 0;\n  var siglen = 0;\n  var nkeys = 0;\n  var keys;\n  var comlen = 0;\n  var comment = false;\n  var accept;\n  var reject;\n\n  if (typeof key === 'function' && typeof keyType === 'function') {\n    // agent forwarding\n    accept = key;\n    reject = keyType;\n  } else if (isSigning) {\n    keylen = key.length;\n    datalen = data.length;\n  } else {\n    cb = key;\n    key = undefined;\n  }\n\n  function onconnect() {\n    var buf;\n    if (isSigning) {\n      /*\n        byte        SSH2_AGENTC_SIGN_REQUEST\n        string      key_blob\n        string      data\n        uint32      flags\n      */\n      var p = 9;\n      buf = new Buffer(4 + 1 + 4 + keylen + 4 + datalen + 4);\n      buf.writeUInt32BE(buf.length - 4, 0, true);\n      buf[4] = SIGN_REQUEST;\n      buf.writeUInt32BE(keylen, 5, true);\n      key.copy(buf, p);\n      buf.writeUInt32BE(datalen, p += keylen, true);\n      data.copy(buf, p += 4);\n      buf.writeUInt32BE(0, p += datalen, true);\n      sock.write(buf);\n    } else {\n      /*\n        byte        SSH2_AGENTC_REQUEST_IDENTITIES\n      */\n      sock.write(new Buffer([0, 0, 0, 1, REQUEST_IDENTITIES]));\n    }\n  }\n  function ondata(chunk) {\n    for (var i = 0, len = chunk.length; i < len; ++i) {\n      if (type === undefined) {\n        // skip over packet length\n        if (++count === 5) {\n          type = chunk[i];\n          count = 0;\n        }\n      } else if (type === SIGN_RESPONSE) {\n        /*\n          byte        SSH2_AGENT_SIGN_RESPONSE\n          string      signature_blob\n        */\n        if (!sig) {\n          siglen <<= 8;\n          siglen += chunk[i];\n          if (++count === 4) {\n            sig = new Buffer(siglen);\n            count = 0;\n          }\n        } else {\n          sig[count] = chunk[i];\n          if (++count === siglen) {\n            sock.removeAllListeners('data');\n            return sock.destroy();\n          }\n        }\n      } else if (type === IDENTITIES_ANSWER) {\n        /*\n          byte        SSH2_AGENT_IDENTITIES_ANSWER\n          uint32      num_keys\n\n        Followed by zero or more consecutive keys, encoded as:\n\n          string      public key blob\n          string      public key comment\n        */\n        if (keys === undefined) {\n          nkeys <<= 8;\n          nkeys += chunk[i];\n          if (++count === 4) {\n            keys = new Array(nkeys);\n            count = 0;\n            if (nkeys === 0) {\n              sock.removeAllListeners('data');\n              return sock.destroy();\n            }\n          }\n        } else {\n          if (!key) {\n            keylen <<= 8;\n            keylen += chunk[i];\n            if (++count === 4) {\n              key = new Buffer(keylen);\n              count = 0;\n            }\n          } else if (comment === false) {\n            key[count] = chunk[i];\n            if (++count === keylen) {\n              keys[nkeys - 1] = key;\n              keylen = 0;\n              count = 0;\n              comment = true;\n              if (--nkeys === 0) {\n                key = undefined;\n                sock.removeAllListeners('data');\n                return sock.destroy();\n              }\n            }\n          } else if (comment === true) {\n            comlen <<= 8;\n            comlen += chunk[i];\n            if (++count === 4) {\n              count = 0;\n              if (comlen > 0)\n                comment = comlen;\n              else {\n                key = undefined;\n                comment = false;\n              }\n              comlen = 0;\n            }\n          } else {\n            // skip comments\n            if (++count === comment) {\n              comment = false;\n              count = 0;\n              key = undefined;\n            }\n          }\n        }\n      } else if (type === FAILURE) {\n        if (isSigning)\n          error = new Error('Agent unable to sign data');\n        else\n          error = new Error('Unable to retrieve list of keys from agent');\n        sock.removeAllListeners('data');\n        return sock.destroy();\n      }\n    }\n  }\n  function onerror(err) {\n    error = err;\n  }\n  function onclose() {\n    if (error)\n      cb(error);\n    else if ((isSigning && !sig) || (!isSigning && !keys))\n      cb(new Error('Unexpected disconnection from agent'));\n    else if (isSigning && sig)\n      cb(undefined, sig);\n    else if (!isSigning && keys)\n      cb(undefined, keys);\n  }\n\n  if (process.platform === 'win32') {\n    if (sockPath === 'pageant') {\n      // Pageant (PuTTY authentication agent)\n      sock = new PageantSock();\n    } else {\n      // cygwin ssh-agent instance\n      var triedCygpath = false;\n      fs.readFile(sockPath, function readCygsocket(err, data) {\n        if (err) {\n          if (triedCygpath)\n            return cb(new Error('Invalid cygwin unix socket path'));\n          // try using `cygpath` to convert a possible *nix-style path to the\n          // real Windows path before giving up ...\n          cp.exec('cygpath -w \"' + sockPath + '\"',\n                  function(err, stdout, stderr) {\n            if (err || stdout.length === 0)\n              return cb(new Error('Invalid cygwin unix socket path'));\n            triedCygpath = true;\n            sockPath = stdout.toString().replace(/[\\r\\n]/g, '');\n            fs.readFile(sockPath, readCygsocket);\n          });\n          return;\n        }\n\n        var m;\n        if (m = RE_CYGWIN_SOCK.exec(data.toString('ascii'))) {\n          var port;\n          var secret;\n          var secretbuf;\n          var state;\n          var bc = 0;\n          var isRetrying = false;\n          var inbuf = [];\n          var credsbuf = new Buffer(12);\n          var i;\n          var j;\n\n          // use 0 for pid, uid, and gid to ensure we get an error and also\n          // a valid uid and gid from cygwin so that we don't have to figure it\n          // out ourselves\n          credsbuf.fill(0);\n\n          // parse cygwin unix socket file contents\n          port = parseInt(m[1], 10);\n          secret = m[2].replace(/\\-/g, '');\n          secretbuf = new Buffer(16);\n          for (i = 0, j = 0; j < 32; ++i,j+=2)\n            secretbuf[i] = parseInt(secret.substring(j, j + 2), 16);\n\n          // convert to host order (always LE for Windows)\n          for (i = 0; i < 16; i += 4)\n            secretbuf.writeUInt32LE(secretbuf.readUInt32BE(i, true), i, true);\n\n          function _onconnect() {\n            bc = 0;\n            state = 'secret';\n            sock.write(secretbuf);\n          }\n          function _ondata(data) {\n            bc += data.length;\n            if (state === 'secret') {\n              // the secret we sent is echoed back to us by cygwin, not sure of\n              // the reason for that, but we ignore it nonetheless ...\n              if (bc === 16) {\n                bc = 0;\n                state = 'creds';\n                sock.write(credsbuf);\n              }\n            } else if (state === 'creds') {\n              // if this is the first attempt, make sure to gather the valid\n              // uid and gid for our next attempt\n              if (!isRetrying)\n                inbuf.push(data);\n\n              if (bc === 12) {\n                sock.removeListener('connect', _onconnect);\n                sock.removeListener('data', _ondata);\n                sock.removeListener('close', _onclose);\n                if (isRetrying) {\n                  addSockListeners();\n                  sock.emit('connect');\n                } else {\n                  isRetrying = true;\n                  credsbuf = Buffer.concat(inbuf);\n                  credsbuf.writeUInt32LE(process.pid, 0, true);\n                  sock.destroy();\n                  tryConnect();\n                }\n              }\n            }\n          }\n          function _onclose() {\n            cb(new Error('Problem negotiating cygwin unix socket security'));\n          }\n          function tryConnect() {\n            sock = new Socket();\n            sock.once('connect', _onconnect);\n            sock.on('data', _ondata);\n            sock.once('close', _onclose);\n            sock.connect(port);\n          }\n          tryConnect();\n        } else\n          cb(new Error('Malformed cygwin unix socket file'));\n      });\n      return;\n    }\n  } else\n    sock = new Socket();\n\n  function addSockListeners() {\n    if (!accept && !reject) {\n      sock.once('connect', onconnect);\n      sock.on('data', ondata);\n      sock.once('error', onerror);\n      sock.once('close', onclose);\n    } else {\n      var chan;\n      sock.once('connect', function() {\n        chan = accept();\n        var isDone = false;\n        function onDone() {\n          if (isDone)\n            return;\n          sock.destroy();\n          isDone = true;\n        }\n        chan.once('end', onDone)\n            .once('close', onDone)\n            .on('data', function(data) {\n          sock.write(data);\n        });\n        sock.on('data', function(data) {\n          chan.write(data);\n        });\n      });\n      sock.once('close', function() {\n        if (!chan)\n          reject();\n      });\n    }\n  }\n  addSockListeners();\n  sock.connect(sockPath);\n};\n\n\n// win32 only ------------------------------------------------------------------\nif (process.platform === 'win32') {\n  var RET_ERR_BADARGS = 10;\n  var RET_ERR_UNAVAILABLE = 11;\n  var RET_ERR_NOMAP = 12;\n  var RET_ERR_BINSTDIN = 13;\n  var RET_ERR_BINSTDOUT = 14;\n  var RET_ERR_BADLEN = 15;\n\n  var ERROR = {};\n  var EXEPATH = path.resolve(__dirname, '..', 'util/pagent.exe');\n  ERROR[RET_ERR_BADARGS] = new Error('Invalid pagent.exe arguments');\n  ERROR[RET_ERR_UNAVAILABLE] = new Error('Pageant is not running');\n  ERROR[RET_ERR_NOMAP] = new Error('pagent.exe could not create an mmap');\n  ERROR[RET_ERR_BINSTDIN] = new Error('pagent.exe could not set mode for stdin');\n  ERROR[RET_ERR_BINSTDOUT] = new Error('pagent.exe could not set mode for stdout');\n  ERROR[RET_ERR_BADLEN] = new Error('pagent.exe did not get expected input payload');\n\n  function PageantSock() {\n    this.proc = undefined;\n    this.buffer = null;\n  }\n  inherits(PageantSock, EventEmitter);\n\n  PageantSock.prototype.write = function(buf) {\n    if (this.buffer === null)\n      this.buffer = buf;\n    else {\n      this.buffer = Buffer.concat([this.buffer, buf],\n                                  this.buffer.length + buf.length);\n    }\n    // Wait for at least all length bytes\n    if (this.buffer.length < 4)\n      return;\n\n    var len = this.buffer.readUInt32BE(0, true);\n    // Make sure we have a full message before querying pageant\n    if ((this.buffer.length - 4) < len)\n      return;\n\n    buf = this.buffer.slice(0, 4 + len);\n    if (this.buffer.length > (4 + len))\n      this.buffer = this.buffer.slice(4 + len);\n    else\n      this.buffer = null;\n\n    var self = this;\n    var proc;\n    var hadError = false;\n    proc = this.proc = cp.spawn(EXEPATH, [ buf.length ]);\n    proc.stdout.on('data', function(data) {\n      self.emit('data', data);\n    });\n    proc.once('error', function(err) {\n      if (!hadError) {\n        hadError = true;\n        self.emit('error', err);\n      }\n    });\n    proc.once('close', function(code) {\n      self.proc = undefined;\n      if (ERROR[code] && !hadError) {\n        hadError = true;\n        self.emit('error', ERROR[code]);\n      }\n      self.emit('close', hadError);\n    });\n    proc.stdin.end(buf);\n  };\n  PageantSock.prototype.end = PageantSock.prototype.destroy = function() {\n    this.buffer = null;\n    if (this.proc) {\n      this.proc.kill();\n      this.proc = undefined;\n    }\n  };\n  PageantSock.prototype.connect = function() {\n    this.emit('connect');\n  };\n}\n","module.exports = require(\"child_process\");","// This wrapper class is used to retain backwards compatibility with\n// pre-v0.4 ssh2. If it weren't for `read()` and `write()` being used by the\n// streams2/3 API, we could just pass the SFTPStream directly to the end user...\n\nvar inherits = require('util').inherits,\n    EventEmitter = require('events').EventEmitter;\n\nfunction SFTPWrapper(stream) {\n  var self = this;\n\n  EventEmitter.call(this);\n\n  this._stream = stream;\n\n  stream.on('error', function(err) {\n    self.emit('error', err);\n  }).on('end', function() {\n    self.emit('end');\n  }).on('close', function() {\n    self.emit('close');\n  }).on('continue', function() {\n    self.emit('continue');\n  });\n}\ninherits(SFTPWrapper, EventEmitter);\n\n// stream-related methods to pass on\nSFTPWrapper.prototype.end = function() {\n  return this._stream.end();\n};\n// SFTPStream client methods\nSFTPWrapper.prototype.createReadStream = function(path, options) {\n  return this._stream.createReadStream(path, options);\n};\nSFTPWrapper.prototype.createWriteStream = function(path, options) {\n  return this._stream.createWriteStream(path, options);\n};\nSFTPWrapper.prototype.open = function(path, flags, attrs, cb) {\n  return this._stream.open(path, flags, attrs, cb);\n};\nSFTPWrapper.prototype.close = function(handle, cb) {\n  return this._stream.close(handle, cb);\n};\nSFTPWrapper.prototype.read = function(handle, buf, off, len, position, cb) {\n  return this._stream.readData(handle, buf, off, len, position, cb);\n};\nSFTPWrapper.prototype.write = function(handle, buf, off, len, position, cb) {\n  return this._stream.writeData(handle, buf, off, len, position, cb);\n};\nSFTPWrapper.prototype.fastGet = function(remotePath, localPath, opts, cb) {\n  return this._stream.fastGet(remotePath, localPath, opts, cb);\n};\nSFTPWrapper.prototype.fastPut = function(localPath, remotePath, opts, cb) {\n  return this._stream.fastPut(localPath, remotePath, opts, cb);\n};\nSFTPWrapper.prototype.readFile = function(path, options, callback_) {\n  return this._stream.readFile(path, options, callback_);\n};\nSFTPWrapper.prototype.writeFile = function(path, data, options, callback_) {\n  return this._stream.writeFile(path, data, options, callback_);\n};\nSFTPWrapper.prototype.appendFile = function(path, data, options, callback_) {\n  return this._stream.appendFile(path, data, options, callback_);\n};\nSFTPWrapper.prototype.exists = function(path, cb) {\n  return this._stream.exists(path, cb);\n};\nSFTPWrapper.prototype.unlink = function(filename, cb) {\n  return this._stream.unlink(filename, cb);\n};\nSFTPWrapper.prototype.rename = function(oldPath, newPath, cb) {\n  return this._stream.rename(oldPath, newPath, cb);\n};\nSFTPWrapper.prototype.mkdir = function(path, attrs, cb) {\n  return this._stream.mkdir(path, attrs, cb);\n};\nSFTPWrapper.prototype.rmdir = function(path, cb) {\n  return this._stream.rmdir(path, cb);\n};\nSFTPWrapper.prototype.readdir = function(where, opts, cb) {\n  return this._stream.readdir(where, opts, cb);\n};\nSFTPWrapper.prototype.fstat = function(handle, cb) {\n  return this._stream.fstat(handle, cb);\n};\nSFTPWrapper.prototype.stat = function(path, cb) {\n  return this._stream.stat(path, cb);\n};\nSFTPWrapper.prototype.lstat = function(path, cb) {\n  return this._stream.lstat(path, cb);\n};\nSFTPWrapper.prototype.opendir = function(path, cb) {\n  return this._stream.opendir(path, cb);\n};\nSFTPWrapper.prototype.setstat = function(path, attrs, cb) {\n  return this._stream.setstat(path, attrs, cb);\n};\nSFTPWrapper.prototype.fsetstat = function(handle, attrs, cb) {\n  return this._stream.fsetstat(handle, attrs, cb);\n};\nSFTPWrapper.prototype.futimes = function(handle, atime, mtime, cb) {\n  return this._stream.futimes(handle, atime, mtime, cb);\n};\nSFTPWrapper.prototype.utimes = function(path, atime, mtime, cb) {\n  return this._stream.utimes(path, atime, mtime, cb);\n};\nSFTPWrapper.prototype.fchown = function(handle, uid, gid, cb) {\n  return this._stream.fchown(handle, uid, gid, cb);\n};\nSFTPWrapper.prototype.chown = function(path, uid, gid, cb) {\n  return this._stream.chown(path, uid, gid, cb);\n};\nSFTPWrapper.prototype.fchmod = function(handle, mode, cb) {\n  return this._stream.fchmod(handle, mode, cb);\n};\nSFTPWrapper.prototype.chmod = function(path, mode, cb) {\n  return this._stream.chmod(path, mode, cb);\n};\nSFTPWrapper.prototype.readlink = function(path, cb) {\n  return this._stream.readlink(path, cb);\n};\nSFTPWrapper.prototype.symlink = function(targetPath, linkPath, cb) {\n  return this._stream.symlink(targetPath, linkPath, cb);\n};\nSFTPWrapper.prototype.realpath = function(path, cb) {\n  return this._stream.realpath(path, cb);\n};\n// extended requests\nSFTPWrapper.prototype.ext_openssh_rename = function(oldPath, newPath, cb) {\n  return this._stream.ext_openssh_rename(oldPath, newPath, cb);\n};\nSFTPWrapper.prototype.ext_openssh_statvfs = function(path, cb) {\n  return this._stream.ext_openssh_statvfs(path, cb);\n};\nSFTPWrapper.prototype.ext_openssh_fstatvfs = function(handle, cb) {\n  return this._stream.ext_openssh_fstatvfs(handle, cb);\n};\nSFTPWrapper.prototype.ext_openssh_hardlink = function(oldPath, newPath, cb) {\n  return this._stream.ext_openssh_hardlink(oldPath, newPath, cb);\n};\nSFTPWrapper.prototype.ext_openssh_fsync = function(handle, cb) {\n  return this._stream.ext_openssh_fsync(handle, cb);\n};\n\nmodule.exports = SFTPWrapper;\n","var net = require('net');\nvar EventEmitter = require('events').EventEmitter;\nvar listenerCount = EventEmitter.listenerCount;\nvar inherits = require('util').inherits;\n\nvar ssh2_streams = require('ssh2-streams');\nvar parseKey = ssh2_streams.utils.parseKey;\nvar genPublicKey = ssh2_streams.utils.genPublicKey;\nvar decryptKey = ssh2_streams.utils.decryptKey;\nvar SSH2Stream = ssh2_streams.SSH2Stream;\nvar SFTPStream = ssh2_streams.SFTPStream;\nvar consts = ssh2_streams.constants;\nvar DISCONNECT_REASON = consts.DISCONNECT_REASON;\nvar CHANNEL_OPEN_FAILURE = consts.CHANNEL_OPEN_FAILURE;\nvar ALGORITHMS = consts.ALGORITHMS;\n\nvar Channel = require('./Channel');\nvar KeepaliveManager = require('./keepalivemgr');\n\nvar MAX_CHANNEL = Math.pow(2, 32) - 1;\nvar MAX_PENDING_AUTHS = 10;\n\nvar kaMgr;\n\nfunction Server(cfg, listener) {\n  if (!(this instanceof Server))\n    return new Server(cfg, listener);\n\n  var hostKeys = {\n    'ssh-rsa': null,\n    'ssh-dss': null,\n    'ecdsa-sha2-nistp256': null,\n    'ecdsa-sha2-nistp384': null,\n    'ecdsa-sha2-nistp521': null\n  };\n\n  var hostKeys_ = cfg.hostKeys;\n  if (!Array.isArray(hostKeys_))\n    throw new Error('hostKeys must be an array');\n\n  var i;\n  for (i = 0; i < hostKeys_.length; ++i) {\n    var privateKey;\n    if (Buffer.isBuffer(hostKeys_[i]) || typeof hostKeys_[i] === 'string')\n      privateKey = parseKey(hostKeys_[i]);\n    else\n      privateKey = parseKey(hostKeys_[i].key);\n    if (privateKey instanceof Error)\n      throw new Error('Cannot parse privateKey: ' + privateKey.message);\n    if (!privateKey.private)\n      throw new Error('privateKey value contains an invalid private key');\n    if (hostKeys[privateKey.fulltype])\n      continue;\n    if (privateKey.encryption) {\n      if (typeof hostKeys_[i].passphrase !== 'string')\n        throw new Error('Missing passphrase for encrypted private key');\n      decryptKey(privateKey, hostKeys_[i].passphrase);\n    }\n    hostKeys[privateKey.fulltype] = {\n      privateKey: privateKey,\n      publicKey: genPublicKey(privateKey)\n    };\n  }\n\n  var algorithms = {\n    kex: undefined,\n    kexBuf: undefined,\n    cipher: undefined,\n    cipherBuf: undefined,\n    serverHostKey: undefined,\n    serverHostKeyBuf: undefined,\n    hmac: undefined,\n    hmacBuf: undefined,\n    compress: undefined,\n    compressBuf: undefined\n  };\n  if (typeof cfg.algorithms === 'object' && cfg.algorithms !== null) {\n    var algosSupported;\n    var algoList;\n\n    algoList = cfg.algorithms.kex;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_KEX;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1)\n          throw new Error('Unsupported key exchange algorithm: ' + algoList[i]);\n      }\n      algorithms.kex = algoList;\n    }\n\n    algoList = cfg.algorithms.cipher;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_CIPHER;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1)\n          throw new Error('Unsupported cipher algorithm: ' + algoList[i]);\n      }\n      algorithms.cipher = algoList;\n    }\n\n    algoList = cfg.algorithms.serverHostKey;\n    var copied = false;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_SERVER_HOST_KEY;\n      for (i = algoList.length - 1; i >= 0; --i) {\n        if (algosSupported.indexOf(algoList[i]) === -1) {\n          throw new Error('Unsupported server host key algorithm: '\n                           + algoList[i]);\n        }\n        if (!hostKeys[algoList[i]]) {\n          // Silently discard for now\n          if (!copied) {\n            algoList = algoList.slice();\n            copied = true;\n          }\n          algoList.splice(i, 1);\n        }\n      }\n      if (algoList.length > 0)\n        algorithms.serverHostKey = algoList;\n    }\n\n    algoList = cfg.algorithms.hmac;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_HMAC;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1)\n          throw new Error('Unsupported HMAC algorithm: ' + algoList[i]);\n      }\n      algorithms.hmac = algoList;\n    }\n\n    algoList = cfg.algorithms.compress;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_COMPRESS;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1)\n          throw new Error('Unsupported compression algorithm: ' + algoList[i]);\n      }\n      algorithms.compress = algoList;\n    }\n  }\n\n  // Make sure we at least have some kind of valid list of support key\n  // formats\n  if (algorithms.serverHostKey === undefined) {\n    var hostKeyAlgos = Object.keys(hostKeys);\n    for (i = hostKeyAlgos.length - 1; i >= 0; --i) {\n      if (!hostKeys[hostKeyAlgos[i]])\n        hostKeyAlgos.splice(i, 1);\n    }\n    algorithms.serverHostKey = hostKeyAlgos;\n  }\n\n  if (!kaMgr\n      && Server.KEEPALIVE_INTERVAL > 0\n      && Server.KEEPALIVE_CLIENT_INTERVAL > 0\n      && Server.KEEPALIVE_CLIENT_COUNT_MAX >= 0) {\n    kaMgr = new KeepaliveManager(Server.KEEPALIVE_INTERVAL,\n                                 Server.KEEPALIVE_CLIENT_INTERVAL,\n                                 Server.KEEPALIVE_CLIENT_COUNT_MAX);\n  }\n\n  var self = this;\n\n  EventEmitter.call(this);\n\n  if (typeof listener === 'function')\n    self.on('connection', listener);\n\n  var streamcfg = {\n    algorithms: algorithms,\n    hostKeys: hostKeys,\n    server: true\n  };\n  var keys;\n  var len;\n  for (i = 0, keys = Object.keys(cfg), len = keys.length; i < len; ++i) {\n    var key = keys[i];\n    if (key === 'privateKey'\n        || key === 'publicKey'\n        || key === 'passphrase'\n        || key === 'algorithms'\n        || key === 'hostKeys'\n        || key === 'server') {\n      continue;\n    }\n    streamcfg[key] = cfg[key];\n  }\n\n  if (typeof streamcfg.debug === 'function') {\n    var oldDebug = streamcfg.debug;\n    var cfgKeys = Object.keys(streamcfg);\n  }\n\n  this._srv = new net.Server(function(socket) {\n    if (self._connections >= self.maxConnections) {\n      socket.destroy();\n      return;\n    }\n    ++self._connections;\n    socket.once('close', function(had_err) {\n      --self._connections;\n\n      // since joyent/node#993bb93e0a, we have to \"read past EOF\" in order to\n      // get an `end` event on streams. thankfully adding this does not\n      // negatively affect node versions pre-joyent/node#993bb93e0a.\n      sshstream.read();\n    }).on('error', function(err) {\n      sshstream.reset();\n      sshstream.emit('error', err);\n    });\n\n    var conncfg = streamcfg;\n\n    // prepend debug output with a unique identifier in case there are multiple\n    // clients connected at the same time\n    if (oldDebug) {\n      conncfg = {};\n      for (var i = 0, key; i < cfgKeys.length; ++i) {\n        key = cfgKeys[i];\n        conncfg[key] = streamcfg[key];\n      }\n      var debugPrefix = '[' + process.hrtime().join('.') + '] ';\n      conncfg.debug = function(msg) {\n        oldDebug(debugPrefix + msg);\n      };\n    }\n\n    var sshstream = new SSH2Stream(conncfg);\n    var client = new Client(sshstream, socket);\n\n    socket.pipe(sshstream).pipe(socket);\n\n    // silence pre-header errors\n    function onClientPreHeaderError(err) {}\n    client.on('error', onClientPreHeaderError);\n\n    sshstream.once('header', function(header) {\n      if (sshstream._readableState.ended) {\n        // already disconnected internally in SSH2Stream due to incompatible\n        // protocol version\n        return;\n      } else if (!listenerCount(self, 'connection')) {\n        // auto reject\n        return sshstream.disconnect(DISCONNECT_REASON.BY_APPLICATION);\n      }\n\n      client.removeListener('error', onClientPreHeaderError);\n\n      self.emit('connection',\n                client,\n                { ip: socket.remoteAddress, header: header });\n    });\n  }).on('error', function(err) {\n    self.emit('error', err);\n  }).on('listening', function() {\n    self.emit('listening');\n  }).on('close', function() {\n    self.emit('close');\n  });\n  this._connections = 0;\n  this.maxConnections = Infinity;\n}\ninherits(Server, EventEmitter);\n\nServer.prototype.listen = function() {\n  this._srv.listen.apply(this._srv, arguments);\n  return this;\n};\n\nServer.prototype.address = function() {\n  return this._srv.address();\n};\n\nServer.prototype.getConnections = function(cb) {\n  this._srv.getConnections(cb);\n};\n\nServer.prototype.close = function(cb) {\n  this._srv.close(cb);\n  return this;\n};\n\nServer.prototype.ref = function() {\n  this._srv.ref();\n};\n\nServer.prototype.unref = function() {\n  this._srv.unref();\n};\n\n\nfunction Client(stream, socket) {\n  EventEmitter.call(this);\n\n  var self = this;\n\n  this._sshstream = stream;\n  var channels = this._channels = {};\n  this._curChan = -1;\n  this._sock = socket;\n  this.noMoreSessions = false;\n  this.authenticated = false;\n\n  stream.on('end', function() {\n    self.emit('end');\n  }).on('close', function(hasErr) {\n    self.emit('close', hasErr);\n  }).on('error', function(err) {\n    self.emit('error', err);\n  }).on('drain', function() {\n    self.emit('drain');\n  }).on('continue', function() {\n    self.emit('continue');\n  });\n\n  var exchanges = 0;\n  var acceptedAuthSvc = false;\n  var pendingAuths = [];\n  var authCtx;\n\n  // begin service/auth-related ================================================\n  stream.on('SERVICE_REQUEST', function(service) {\n    if (exchanges === 0\n        || acceptedAuthSvc\n        || self.authenticated\n        || service !== 'ssh-userauth')\n      return stream.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);\n\n    acceptedAuthSvc = true;\n    stream.serviceAccept(service);\n  }).on('USERAUTH_REQUEST', onUSERAUTH_REQUEST);\n  function onUSERAUTH_REQUEST(username, service, method, methodData) {\n    if (exchanges === 0\n        || (authCtx\n            && (authCtx.username !== username || authCtx.service !== service))\n          // TODO: support hostbased auth\n        || (method !== 'password'\n            && method !== 'publickey'\n            && method !== 'hostbased'\n            && method !== 'keyboard-interactive'\n            && method !== 'none')\n        || pendingAuths.length === MAX_PENDING_AUTHS)\n      return stream.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n    else if (service !== 'ssh-connection')\n      return stream.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);\n\n    // XXX: this really shouldn't be reaching into private state ...\n    stream._state.authMethod = method;\n\n    var ctx;\n    if (method === 'keyboard-interactive') {\n      ctx = new KeyboardAuthContext(stream, username, service, method,\n                                    methodData, onAuthDecide);\n    } else if (method === 'publickey') {\n      ctx = new PKAuthContext(stream, username, service, method, methodData,\n                              onAuthDecide);\n    } else if (method === 'hostbased') {\n      ctx = new HostbasedAuthContext(stream, username, service, method,\n                                     methodData, onAuthDecide);\n    } else if (method === 'password') {\n      ctx = new PwdAuthContext(stream, username, service, method, methodData,\n                               onAuthDecide);\n    } else if (method === 'none')\n      ctx = new AuthContext(stream, username, service, method, onAuthDecide);\n\n    if (authCtx) {\n      if (!authCtx._initialResponse)\n        return pendingAuths.push(ctx);\n      else if (authCtx._multistep && !this._finalResponse) {\n        // RFC 4252 says to silently abort the current auth request if a new\n        // auth request comes in before the final response from an auth method\n        // that requires additional request/response exchanges -- this means\n        // keyboard-interactive for now ...\n        authCtx._cleanup && authCtx._cleanup();\n        authCtx.emit('abort');\n      }\n    }\n\n    authCtx = ctx;\n\n    if (listenerCount(self, 'authentication'))\n      self.emit('authentication', authCtx);\n    else\n      authCtx.reject();\n  }\n  function onAuthDecide(ctx, allowed, methodsLeft, isPartial) {\n    if (authCtx === ctx && !self.authenticated) {\n      if (allowed) {\n        stream.removeListener('USERAUTH_REQUEST', onUSERAUTH_REQUEST);\n        authCtx = undefined;\n        self.authenticated = true;\n        stream.authSuccess();\n        pendingAuths = [];\n        self.emit('ready');\n      } else {\n        stream.authFailure(methodsLeft, isPartial);\n        if (pendingAuths.length) {\n          authCtx = pendingAuths.pop();\n          if (listenerCount(self, 'authentication'))\n            self.emit('authentication', authCtx);\n          else\n            authCtx.reject();\n        }\n      }\n    }\n  }\n  // end service/auth-related ==================================================\n\n  var unsentGlobalRequestsReplies = [];\n\n  function sendReplies() {\n    var reply;\n    while (unsentGlobalRequestsReplies.length > 0\n           && unsentGlobalRequestsReplies[0].type) {\n      reply = unsentGlobalRequestsReplies.shift();\n      if (reply.type === 'SUCCESS')\n        stream.requestSuccess(reply.buf);\n      if (reply.type === 'FAILURE')\n        stream.requestFailure();\n    }\n  }\n\n  stream.on('GLOBAL_REQUEST', function(name, wantReply, data) {\n    var reply = {\n      type: null,\n      buf: null\n    };\n\n    function setReply(type, buf) {\n      reply.type = type;\n      reply.buf = buf;\n      sendReplies();\n    }\n\n    if (wantReply)\n      unsentGlobalRequestsReplies.push(reply);\n\n    if ((name === 'tcpip-forward'\n         || name === 'cancel-tcpip-forward'\n         || name === 'no-more-sessions@openssh.com'\n         || name === 'streamlocal-forward@openssh.com'\n         || name === 'cancel-streamlocal-forward@openssh.com')\n        && listenerCount(self, 'request')\n        && self.authenticated) {\n      var accept;\n      var reject;\n\n      if (wantReply) {\n        var replied = false;\n        accept = function(chosenPort) {\n          if (replied)\n            return;\n          replied = true;\n          var bufPort;\n          if (name === 'tcpip-forward'\n              && data.bindPort === 0\n              && typeof chosenPort === 'number') {\n            bufPort = new Buffer(4);\n            bufPort.writeUInt32BE(chosenPort, 0, true);\n          }\n          setReply('SUCCESS', bufPort);\n        };\n        reject = function() {\n          if (replied)\n            return;\n          replied = true;\n          setReply('FAILURE');\n        };\n      }\n\n      if (name === 'no-more-sessions@openssh.com') {\n        self.noMoreSessions = true;\n        accept && accept();\n        return;\n      }\n\n      self.emit('request', accept, reject, name, data);\n    } else if (wantReply)\n      setReply('FAILURE');\n  });\n\n  stream.on('CHANNEL_OPEN', function(info) {\n    // do early reject in some cases to prevent wasteful channel allocation\n    if ((info.type === 'session' && self.noMoreSessions)\n        || !self.authenticated) {\n      var reasonCode = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n      return stream.channelOpenFail(info.sender, reasonCode);\n    }\n\n    var localChan = nextChannel(self);\n    var accept;\n    var reject;\n    var replied = false;\n    if (localChan === false) {\n      // auto-reject due to no channels available\n      return stream.channelOpenFail(info.sender,\n                                    CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE);\n    }\n\n    // be optimistic, reserve channel to prevent another request from trying to\n    // take the same channel\n    channels[localChan] = true;\n\n    reject = function() {\n      if (replied)\n        return;\n\n      replied = true;\n\n      delete channels[localChan];\n\n      var reasonCode = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n      return stream.channelOpenFail(info.sender, reasonCode);\n    };\n\n    switch (info.type) {\n      case 'session':\n        if (listenerCount(self, 'session')) {\n          accept = function() {\n            if (replied)\n              return;\n\n            replied = true;\n\n            stream.channelOpenConfirm(info.sender,\n                                      localChan,\n                                      Channel.MAX_WINDOW,\n                                      Channel.PACKET_SIZE);\n\n            return new Session(self, info, localChan);\n          };\n\n          self.emit('session', accept, reject);\n        } else\n          reject();\n      break;\n      case 'direct-tcpip':\n        if (listenerCount(self, 'tcpip')) {\n          accept = function() {\n            if (replied)\n              return;\n\n            replied = true;\n\n            stream.channelOpenConfirm(info.sender,\n                                      localChan,\n                                      Channel.MAX_WINDOW,\n                                      Channel.PACKET_SIZE);\n\n            var chaninfo = {\n              type: undefined,\n              incoming: {\n                id: localChan,\n                window: Channel.MAX_WINDOW,\n                packetSize: Channel.PACKET_SIZE,\n                state: 'open'\n              },\n              outgoing: {\n                id: info.sender,\n                window: info.window,\n                packetSize: info.packetSize,\n                state: 'open'\n              }\n            };\n\n            return new Channel(chaninfo, self);\n          };\n\n          self.emit('tcpip', accept, reject, info.data);\n        } else\n          reject();\n      break;\n      case 'direct-streamlocal@openssh.com':\n        if (listenerCount(self, 'openssh.streamlocal')) {\n          accept = function() {\n            if (replied)\n              return;\n\n            replied = true;\n\n            stream.channelOpenConfirm(info.sender,\n                                      localChan,\n                                      Channel.MAX_WINDOW,\n                                      Channel.PACKET_SIZE);\n\n            var chaninfo = {\n              type: undefined,\n              incoming: {\n                id: localChan,\n                window: Channel.MAX_WINDOW,\n                packetSize: Channel.PACKET_SIZE,\n                state: 'open'\n              },\n              outgoing: {\n                id: info.sender,\n                window: info.window,\n                packetSize: info.packetSize,\n                state: 'open'\n              }\n            };\n\n            return new Channel(chaninfo, self);\n          };\n\n          self.emit('openssh.streamlocal', accept, reject, info.data);\n        } else\n          reject();\n      break;\n      default:\n        // auto-reject unsupported channel types\n        reject();\n    }\n  });\n\n  stream.on('NEWKEYS', function() {\n    if (++exchanges > 1)\n      self.emit('rekey');\n  });\n\n  if (kaMgr) {\n    this.once('ready', function() {\n      kaMgr.add(stream);\n    });\n  }\n}\ninherits(Client, EventEmitter);\n\nClient.prototype.end = function() {\n  return this._sshstream.disconnect(DISCONNECT_REASON.BY_APPLICATION);\n};\n\nClient.prototype.x11 = function(originAddr, originPort, cb) {\n  var opts = {\n    originAddr: originAddr,\n    originPort: originPort\n  };\n  return openChannel(this, 'x11', opts, cb);\n};\n\nClient.prototype.forwardOut = function(boundAddr, boundPort, remoteAddr,\n                                       remotePort, cb) {\n  var opts = {\n    boundAddr: boundAddr,\n    boundPort: boundPort,\n    remoteAddr: remoteAddr,\n    remotePort: remotePort\n  };\n  return openChannel(this, 'forwarded-tcpip', opts, cb);\n};\n\nClient.prototype.openssh_forwardOutStreamLocal = function(socketPath, cb) {\n  var opts = {\n    socketPath: socketPath\n  };\n  return openChannel(this, 'forwarded-streamlocal@openssh.com', opts, cb);\n};\n\nClient.prototype.rekey = function(cb) {\n  var stream = this._sshstream;\n  var ret = true;\n  var error;\n\n  try {\n    ret = stream.rekey();\n  } catch (ex) {\n    error = ex;\n  }\n\n  // TODO: re-throw error if no callback?\n\n  if (typeof cb === 'function') {\n    if (error) {\n      process.nextTick(function() {\n        cb(error);\n      });\n    } else\n      this.once('rekey', cb);\n  }\n\n  return ret;\n};\n\nfunction Session(client, info, localChan) {\n  this.subtype = undefined;\n\n  var ending = false;\n  var self = this;\n  var outgoingId = info.sender;\n  var channel;\n\n  var chaninfo = {\n    type: 'session',\n    incoming: {\n      id: localChan,\n      window: Channel.MAX_WINDOW,\n      packetSize: Channel.PACKET_SIZE,\n      state: 'open'\n    },\n    outgoing: {\n      id: info.sender,\n      window: info.window,\n      packetSize: info.packetSize,\n      state: 'open'\n    }\n  };\n\n  function onREQUEST(info) {\n    var replied = false;\n    var accept;\n    var reject;\n\n    if (info.wantReply) {\n      // \"real session\" requests will have custom accept behaviors\n      if (info.request !== 'shell'\n          && info.request !== 'exec'\n          && info.request !== 'subsystem') {\n        accept = function() {\n          if (replied || ending || channel)\n            return;\n\n          replied = true;\n\n          return client._sshstream.channelSuccess(outgoingId);\n        };\n      }\n\n      reject = function() {\n        if (replied || ending || channel)\n          return;\n\n        replied = true;\n\n        return client._sshstream.channelFailure(outgoingId);\n      };\n    }\n\n    if (ending) {\n      reject && reject();\n      return;\n    }\n\n    switch (info.request) {\n      // \"pre-real session start\" requests\n      case 'env':\n        if (listenerCount(self, 'env')) {\n          self.emit('env', accept, reject, {\n            key: info.key,\n            val: info.val\n          });\n        } else\n          reject && reject();\n      break;\n      case 'pty-req':\n        if (listenerCount(self, 'pty')) {\n          self.emit('pty', accept, reject, {\n            cols: info.cols,\n            rows: info.rows,\n            width: info.width,\n            height: info.height,\n            term: info.term,\n            modes: info.modes,\n          });\n        } else\n          reject && reject();\n      break;\n      case 'window-change':\n        if (listenerCount(self, 'window-change')) {\n          self.emit('window-change', accept, reject, {\n            cols: info.cols,\n            rows: info.rows,\n            width: info.width,\n            height: info.height\n          });\n        } else\n          reject && reject();\n      break;\n      case 'x11-req':\n        if (listenerCount(self, 'x11')) {\n          self.emit('x11', accept, reject, {\n            single: info.single,\n            protocol: info.protocol,\n            cookie: info.cookie,\n            screen: info.screen\n          });\n        } else\n          reject && reject();\n      break;\n      // \"post-real session start\" requests\n      case 'signal':\n        if (listenerCount(self, 'signal')) {\n          self.emit('signal', accept, reject, {\n            name: info.signal\n          });\n        } else\n          reject && reject();\n      break;\n      // XXX: is `auth-agent-req@openssh.com` really \"post-real session start\"?\n      case 'auth-agent-req@openssh.com':\n        if (listenerCount(self, 'auth-agent'))\n          self.emit('auth-agent', accept, reject);\n        else\n          reject && reject();\n      break;\n      // \"real session start\" requests\n      case 'shell':\n        if (listenerCount(self, 'shell')) {\n          accept = function() {\n            if (replied || ending || channel)\n              return;\n\n            replied = true;\n\n            if (info.wantReply)\n              client._sshstream.channelSuccess(outgoingId);\n\n            channel = new Channel(chaninfo, client, { server: true });\n\n            channel.subtype = self.subtype = info.request;\n\n            return channel;\n          };\n\n          self.emit('shell', accept, reject);\n        } else\n          reject && reject();\n      break;\n      case 'exec':\n        if (listenerCount(self, 'exec')) {\n          accept = function() {\n            if (replied || ending || channel)\n              return;\n\n            replied = true;\n\n            if (info.wantReply)\n              client._sshstream.channelSuccess(outgoingId);\n\n            channel = new Channel(chaninfo, client, { server: true });\n\n            channel.subtype = self.subtype = info.request;\n\n            return channel;\n          };\n\n          self.emit('exec', accept, reject, {\n            command: info.command\n          });\n        } else\n          reject && reject();\n      break;\n      case 'subsystem':\n        accept = function() {\n          if (replied || ending || channel)\n            return;\n\n          replied = true;\n\n          if (info.wantReply)\n            client._sshstream.channelSuccess(outgoingId);\n\n          channel = new Channel(chaninfo, client, { server: true });\n\n          channel.subtype = self.subtype = (info.request + ':' + info.subsystem);\n\n          if (info.subsystem === 'sftp') {\n            var sftp = new SFTPStream({\n              server: true,\n              debug: client._sshstream.debug\n            });\n            channel.pipe(sftp).pipe(channel);\n\n            return sftp;\n          } else\n            return channel;\n        };\n\n        if (info.subsystem === 'sftp' && listenerCount(self, 'sftp'))\n          self.emit('sftp', accept, reject);\n        else if (info.subsystem !== 'sftp' && listenerCount(self, 'subsystem')) {\n          self.emit('subsystem', accept, reject, {\n            name: info.subsystem\n          });\n        } else\n          reject && reject();\n      break;\n      default:\n        reject && reject();\n    }\n  }\n  function onEOF() {\n    ending = true;\n    self.emit('eof');\n    self.emit('end');\n  }\n  function onCLOSE() {\n    ending = true;\n    self.emit('close');\n  }\n  client._sshstream\n        .on('CHANNEL_REQUEST:' + localChan, onREQUEST)\n        .once('CHANNEL_EOF:' + localChan, onEOF)\n        .once('CHANNEL_CLOSE:' + localChan, onCLOSE);\n}\ninherits(Session, EventEmitter);\n\n\nfunction AuthContext(stream, username, service, method, cb) {\n  EventEmitter.call(this);\n\n  var self = this;\n\n  this.username = this.user = username;\n  this.service = service;\n  this.method = method;\n  this._initialResponse = false;\n  this._finalResponse = false;\n  this._multistep = false;\n  this._cbfinal = function(allowed, methodsLeft, isPartial) {\n    if (!self._finalResponse) {\n      self._finalResponse = true;\n      cb(self, allowed, methodsLeft, isPartial);\n    }\n  };\n  this._stream = stream;\n}\ninherits(AuthContext, EventEmitter);\nAuthContext.prototype.accept = function() {\n  this._cleanup && this._cleanup();\n  this._initialResponse = true;\n  this._cbfinal(true);\n};\nAuthContext.prototype.reject = function(methodsLeft, isPartial) {\n  this._cleanup && this._cleanup();\n  this._initialResponse = true;\n  this._cbfinal(false, methodsLeft, isPartial);\n};\n\nvar RE_KBINT_SUBMETHODS = /[ \\t\\r\\n]*,[ \\t\\r\\n]*/g;\nfunction KeyboardAuthContext(stream, username, service, method, submethods, cb) {\n  AuthContext.call(this, stream, username, service, method, cb);\n  this._multistep = true;\n\n  var self = this;\n\n  this._cb = undefined;\n  this._onInfoResponse = function(responses) {\n    if (self._cb) {\n      var callback = self._cb;\n      self._cb = undefined;\n      callback(responses);\n    }\n  };\n  this.submethods = submethods.split(RE_KBINT_SUBMETHODS);\n  this.on('abort', function() {\n    self._cb && self._cb(new Error('Authentication request aborted'));\n  });\n}\ninherits(KeyboardAuthContext, AuthContext);\nKeyboardAuthContext.prototype._cleanup = function() {\n  this._stream.removeListener('USERAUTH_INFO_RESPONSE', this._onInfoResponse);\n};\nKeyboardAuthContext.prototype.prompt = function(prompts, title, instructions,\n                                                cb) {\n  if (!Array.isArray(prompts))\n    prompts = [ prompts ];\n\n  if (typeof title === 'function') {\n    cb = title;\n    title = instructions = undefined;\n  } else if (typeof instructions === 'function') {\n    cb = instructions;\n    instructions = undefined;\n  }\n\n  for (var i = 0; i < prompts.length; ++i) {\n    if (typeof prompts[i] === 'string') {\n      prompts[i] = {\n        prompt: prompts[i],\n        echo: true\n      };\n    }\n  }\n\n  this._cb = cb;\n  this._initialResponse = true;\n  this._stream.once('USERAUTH_INFO_RESPONSE', this._onInfoResponse);\n\n  return this._stream.authInfoReq(title, instructions, prompts);\n};\n\nfunction PKAuthContext(stream, username, service, method, pkInfo, cb) {\n  AuthContext.call(this, stream, username, service, method, cb);\n\n  this.key = { algo: pkInfo.keyAlgo, data: pkInfo.key };\n  this.signature = pkInfo.signature;\n  var sigAlgo;\n  if (this.signature) {\n    switch (pkInfo.keyAlgo) {\n      case 'ssh-rsa':\n        sigAlgo = 'RSA-SHA1';\n        break;\n      case 'ssh-dss':\n        sigAlgo = 'DSA-SHA1';\n        break;\n      case 'ecdsa-sha2-nistp256':\n        sigAlgo = 'sha256';\n        break;\n      case 'ecdsa-sha2-nistp384':\n        sigAlgo = 'sha384';\n        break;\n      case 'ecdsa-sha2-nistp521':\n        sigAlgo = 'sha512';\n        break;\n    }\n  }\n  this.sigAlgo = sigAlgo;\n  this.blob = pkInfo.blob;\n}\ninherits(PKAuthContext, AuthContext);\nPKAuthContext.prototype.accept = function() {\n  if (!this.signature) {\n    this._initialResponse = true;\n    this._stream.authPKOK(this.key.algo, this.key.data);\n  } else\n    AuthContext.prototype.accept.call(this);\n};\n\nfunction HostbasedAuthContext(stream, username, service, method, pkInfo, cb) {\n  AuthContext.call(this, stream, username, service, method, cb);\n\n  this.key = { algo: pkInfo.keyAlgo, data: pkInfo.key };\n  this.signature = pkInfo.signature;\n  var sigAlgo;\n  if (this.signature) {\n    switch (pkInfo.keyAlgo) {\n      case 'ssh-rsa':\n        sigAlgo = 'RSA-SHA1';\n        break;\n      case 'ssh-dss':\n        sigAlgo = 'DSA-SHA1';\n        break;\n      case 'ecdsa-sha2-nistp256':\n        sigAlgo = 'sha256';\n        break;\n      case 'ecdsa-sha2-nistp384':\n        sigAlgo = 'sha384';\n        break;\n      case 'ecdsa-sha2-nistp521':\n        sigAlgo = 'sha512';\n        break;\n    }\n  }\n  this.sigAlgo = sigAlgo;\n  this.blob = pkInfo.blob;\n  this.localHostname = pkInfo.localHostname;\n  this.localUsername = pkInfo.localUsername;\n}\ninherits(HostbasedAuthContext, AuthContext);\n\nfunction PwdAuthContext(stream, username, service, method, password, cb) {\n  AuthContext.call(this, stream, username, service, method, cb);\n\n  this.password = password;\n}\ninherits(PwdAuthContext, AuthContext);\n\n\nfunction openChannel(self, type, opts, cb) {\n  // ask the client to open a channel for some purpose\n  // (e.g. a forwarded TCP connection)\n  var localChan = nextChannel(self);\n  var initWindow = Channel.MAX_WINDOW;\n  var maxPacket = Channel.PACKET_SIZE;\n  var ret = true;\n\n  if (localChan === false)\n    return cb(new Error('No free channels available'));\n\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  self._channels[localChan] = true;\n\n  var sshstream = self._sshstream;\n  sshstream.once('CHANNEL_OPEN_CONFIRMATION:' + localChan, function(info) {\n    sshstream.removeAllListeners('CHANNEL_OPEN_FAILURE:' + localChan);\n\n    var chaninfo = {\n      type: type,\n      incoming: {\n        id: localChan,\n        window: initWindow,\n        packetSize: maxPacket,\n        state: 'open'\n      },\n      outgoing: {\n        id: info.sender,\n        window: info.window,\n        packetSize: info.packetSize,\n        state: 'open'\n      }\n    };\n    cb(undefined, new Channel(chaninfo, self, { server: true }));\n  }).once('CHANNEL_OPEN_FAILURE:' + localChan, function(info) {\n    sshstream.removeAllListeners('CHANNEL_OPEN_CONFIRMATION:' + localChan);\n\n    delete self._channels[localChan];\n\n    var err = new Error('(SSH) Channel open failure: ' + info.description);\n    err.reason = info.reason;\n    err.lang = info.lang;\n    cb(err);\n  });\n\n  if (type === 'forwarded-tcpip')\n    ret = sshstream.forwardedTcpip(localChan, initWindow, maxPacket, opts);\n  else if (type === 'x11')\n    ret = sshstream.x11(localChan, initWindow, maxPacket, opts);\n  else if (type === 'forwarded-streamlocal@openssh.com') {\n    ret = sshstream.openssh_forwardedStreamLocal(localChan,\n                                                 initWindow,\n                                                 maxPacket,\n                                                 opts);\n  }\n\n  return ret;\n}\n\nfunction nextChannel(self) {\n  // get the next available channel number\n\n  // fast path\n  if (self._curChan < MAX_CHANNEL)\n    return ++self._curChan;\n\n  // slower lookup path\n  for (var i = 0, channels = self._channels; i < MAX_CHANNEL; ++i)\n    if (!channels[i])\n      return i;\n\n  return false;\n}\n\n\nServer.createServer = function(cfg, listener) {\n  return new Server(cfg, listener);\n};\nServer.KEEPALIVE_INTERVAL = 1000;\nServer.KEEPALIVE_CLIENT_INTERVAL = 15000;\nServer.KEEPALIVE_CLIENT_COUNT_MAX = 3;\n\nmodule.exports = Server;\nmodule.exports.IncomingClient = Client;\n","var spliceOne = require('./utils').spliceOne;\n\nfunction Manager(interval, streamInterval, kaCountMax) {\n  var streams = this._streams = [];\n  this._timer = undefined;\n  this._timerInterval = interval;\n  this._timerfn = function() {\n    var now = Date.now();\n    for (var i = 0, len = streams.length, s, last; i < len; ++i) {\n      s = streams[i];\n      last = s._kalast;\n      if (last && (now - last) >= streamInterval) {\n        if (++s._kacnt > kaCountMax) {\n          var err = new Error('Keepalive timeout');\n          err.level = 'client-timeout';\n          s.emit('error', err);\n          s.disconnect();\n          spliceOne(streams, i);\n          --i;\n          len = streams.length;\n        } else {\n          s._kalast = now;\n          // XXX: if the server ever starts sending real global requests to the\n          //      client, we will need to add a dummy callback here to keep the\n          //      correct reply order\n          s.ping();\n        }\n      }\n    }\n  };\n}\n\nManager.prototype.start = function() {\n  if (this._timer)\n    this.stop();\n  this._timer = setInterval(this._timerfn, this._timerInterval);\n};\n\nManager.prototype.stop = function() {\n  if (this._timer) {\n    clearInterval(this._timer);\n    this._timer = undefined;\n  }\n};\n\nManager.prototype.add = function(stream) {\n  var streams = this._streams,\n      self = this;\n\n  stream.once('end', function() {\n    self.remove(stream);\n  }).on('packet', resetKA);\n\n  streams[streams.length] = stream;\n\n  resetKA();\n\n  if (!this._timer)\n    this.start();\n\n  function resetKA() {\n    stream._kalast = Date.now();\n    stream._kacnt = 0;\n  }\n};\n\nManager.prototype.remove = function(stream) {\n  var streams = this._streams,\n      index = streams.indexOf(stream);\n  if (index > -1)\n    spliceOne(streams, index);\n  if (!streams.length)\n    this.stop();\n};\n\nmodule.exports = Manager;\n","exports.spliceOne = function(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    list[i] = list[k];\n  list.pop();\n};\n","\nvar Promise = require('any-promise')\nvar fs\ntry {\n  fs = require('graceful-fs')\n} catch(err) {\n  fs = require('fs')\n}\n\nvar api = [\n  'rename',\n  'ftruncate',\n  'chown',\n  'fchown',\n  'lchown',\n  'chmod',\n  'fchmod',\n  'stat',\n  'lstat',\n  'fstat',\n  'link',\n  'symlink',\n  'readlink',\n  'realpath',\n  'unlink',\n  'rmdir',\n  'mkdir',\n  'readdir',\n  'close',\n  'open',\n  'utimes',\n  'futimes',\n  'fsync',\n  'fdatasync',\n  'write',\n  'read',\n  'readFile',\n  'writeFile',\n  'appendFile',\n  'truncate',\n]\n\ntypeof fs.access === 'function' && api.push('access')\ntypeof fs.mkdtemp === 'function' && api.push('mkdtemp')\n\nrequire('thenify-all').withCallback(fs, exports, api)\n\nexports.exists = function (filename, callback) {\n  // callback\n  if (typeof callback === 'function') {\n    return fs.stat(filename, function (err) {\n      callback(null, !err);\n    })\n  }\n  // or promise\n  return new Promise(function (resolve) {\n    fs.stat(filename, function (err) {\n      resolve(!err)\n    })\n  })\n}\n","\"use strict\"\nmodule.exports = require('./loader')(global, loadImplementation);\n\n/**\n * Node.js version of loadImplementation.\n *\n * Requires the given implementation and returns the registration\n * containing {Promise, implementation}\n *\n * If implementation is undefined or global.Promise, loads it\n * Otherwise uses require\n */\nfunction loadImplementation(implementation){\n  var impl = null\n\n  if(shouldPreferGlobalPromise(implementation)){\n    // if no implementation or env specified use global.Promise\n    impl = {\n      Promise: global.Promise,\n      implementation: 'global.Promise'\n    }\n  } else if(implementation){\n    // if implementation specified, require it\n    var lib = require(implementation)\n    impl = {\n      Promise: lib.Promise || lib,\n      implementation: implementation\n    }\n  } else {\n    // try to auto detect implementation. This is non-deterministic\n    // and should prefer other branches, but this is our last chance\n    // to load something without throwing error\n    impl = tryAutoDetect()\n  }\n\n  if(impl === null){\n    throw new Error('Cannot find any-promise implementation nor'+\n      ' global.Promise. You must install polyfill or call'+\n      ' require(\"any-promise/register\") with your preferred'+\n      ' implementation, e.g. require(\"any-promise/register/bluebird\")'+\n      ' on application load prior to any require(\"any-promise\").')\n  }\n\n  return impl\n}\n\n/**\n * Determines if the global.Promise should be preferred if an implementation\n * has not been registered.\n */\nfunction shouldPreferGlobalPromise(implementation){\n  if(implementation){\n    return implementation === 'global.Promise'\n  } else if(typeof global.Promise !== 'undefined'){\n    // Load global promise if implementation not specified\n    // Versions < 0.11 did not have global Promise\n    // Do not use for version < 0.12 as version 0.11 contained buggy versions\n    var version = (/v(\\d+)\\.(\\d+)\\.(\\d+)/).exec(process.version)\n    return !(version && +version[1] == 0 && +version[2] < 12)\n  }\n\n  // do not have global.Promise or another implementation was specified\n  return false\n}\n\n/**\n * Look for common libs as last resort there is no guarantee that\n * this will return a desired implementation or even be deterministic.\n * The priority is also nearly arbitrary. We are only doing this\n * for older versions of Node.js <0.12 that do not have a reasonable\n * global.Promise implementation and we the user has not registered\n * the preference. This preserves the behavior of any-promise <= 0.1\n * and may be deprecated or removed in the future\n */\nfunction tryAutoDetect(){\n  var libs = [\n      \"es6-promise\",\n      \"promise\",\n      \"native-promise-only\",\n      \"bluebird\",\n      \"rsvp\",\n      \"when\",\n      \"q\",\n      \"pinkie\",\n      \"lie\",\n      \"vow\"]\n  var i = 0, len = libs.length\n  for(; i < len; i++){\n    try {\n      return loadImplementation(libs[i])\n    } catch(e){}\n  }\n  return null\n}\n","\"use strict\"\n    // global key for user preferred registration\nvar REGISTRATION_KEY = '@@any-promise/REGISTRATION',\n    // Prior registration (preferred or detected)\n    registered = null\n\n/**\n * Registers the given implementation.  An implementation must\n * be registered prior to any call to `require(\"any-promise\")`,\n * typically on application load.\n *\n * If called with no arguments, will return registration in\n * following priority:\n *\n * For Node.js:\n *\n * 1. Previous registration\n * 2. global.Promise if node.js version >= 0.12\n * 3. Auto detected promise based on first sucessful require of\n *    known promise libraries. Note this is a last resort, as the\n *    loaded library is non-deterministic. node.js >= 0.12 will\n *    always use global.Promise over this priority list.\n * 4. Throws error.\n *\n * For Browser:\n *\n * 1. Previous registration\n * 2. window.Promise\n * 3. Throws error.\n *\n * Options:\n *\n * Promise: Desired Promise constructor\n * global: Boolean - Should the registration be cached in a global variable to\n * allow cross dependency/bundle registration?  (default true)\n */\nmodule.exports = function(root, loadImplementation){\n  return function register(implementation, opts){\n    implementation = implementation || null\n    opts = opts || {}\n    // global registration unless explicitly  {global: false} in options (default true)\n    var registerGlobal = opts.global !== false;\n\n    // load any previous global registration\n    if(registered === null && registerGlobal){\n      registered = root[REGISTRATION_KEY] || null\n    }\n\n    if(registered !== null\n        && implementation !== null\n        && registered.implementation !== implementation){\n      // Throw error if attempting to redefine implementation\n      throw new Error('any-promise already defined as \"'+registered.implementation+\n        '\".  You can only register an implementation before the first '+\n        ' call to require(\"any-promise\") and an implementation cannot be changed')\n    }\n\n    if(registered === null){\n      // use provided implementation\n      if(implementation !== null && typeof opts.Promise !== 'undefined'){\n        registered = {\n          Promise: opts.Promise,\n          implementation: implementation\n        }\n      } else {\n        // require implementation if implementation is specified but not provided\n        registered = loadImplementation(implementation)\n      }\n\n      if(registerGlobal){\n        // register preference globally in case multiple installations\n        root[REGISTRATION_KEY] = registered\n      }\n    }\n\n    return registered\n  }\n}\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 60;","var fs = require('fs')\nvar polyfills = require('./polyfills.js')\nvar legacy = require('./legacy-streams.js')\nvar queue = []\n\nvar util = require('util')\n\nfunction noop () {}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog('gfs4')\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\n    console.error(m)\n  }\n\nif (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\n  process.on('exit', function() {\n    debug(queue)\n    require('assert').equal(queue.length, 0)\n  })\n}\n\nmodule.exports = patch(require('./fs.js'))\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH) {\n  module.exports = patch(fs)\n}\n\n// Always patch fs.close/closeSync, because we want to\n// retry() whenever a close happens *anywhere* in the program.\n// This is essential when multiple graceful-fs instances are\n// in play at the same time.\nmodule.exports.close =\nfs.close = (function (fs$close) { return function (fd, cb) {\n  return fs$close.call(fs, fd, function (err) {\n    if (!err)\n      retry()\n\n    if (typeof cb === 'function')\n      cb.apply(this, arguments)\n  })\n}})(fs.close)\n\nmodule.exports.closeSync =\nfs.closeSync = (function (fs$closeSync) { return function (fd) {\n  // Note that graceful-fs also retries when fs.closeSync() fails.\n  // Looks like a bug to me, although it's probably a harmless one.\n  var rval = fs$closeSync.apply(fs, arguments)\n  retry()\n  return rval\n}})(fs.closeSync)\n\nfunction patch (fs) {\n  // Everything that references the open() function needs to be in here\n  polyfills(fs)\n  fs.gracefulify = patch\n  fs.FileReadStream = ReadStream;  // Legacy name.\n  fs.FileWriteStream = WriteStream;  // Legacy name.\n  fs.createReadStream = createReadStream\n  fs.createWriteStream = createWriteStream\n  var fs$readFile = fs.readFile\n  fs.readFile = readFile\n  function readFile (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readFile(path, options, cb)\n\n    function go$readFile (path, options, cb) {\n      return fs$readFile(path, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readFile, [path, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$writeFile = fs.writeFile\n  fs.writeFile = writeFile\n  function writeFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$writeFile(path, data, options, cb)\n\n    function go$writeFile (path, data, options, cb) {\n      return fs$writeFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$writeFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$appendFile = fs.appendFile\n  if (fs$appendFile)\n    fs.appendFile = appendFile\n  function appendFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$appendFile(path, data, options, cb)\n\n    function go$appendFile (path, data, options, cb) {\n      return fs$appendFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$appendFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$readdir = fs.readdir\n  fs.readdir = readdir\n  function readdir (path, options, cb) {\n    var args = [path]\n    if (typeof options !== 'function') {\n      args.push(options)\n    } else {\n      cb = options\n    }\n    args.push(go$readdir$cb)\n\n    return go$readdir(args)\n\n    function go$readdir$cb (err, files) {\n      if (files && files.sort)\n        files.sort()\n\n      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n        enqueue([go$readdir, [args]])\n      else {\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n        retry()\n      }\n    }\n  }\n\n  function go$readdir (args) {\n    return fs$readdir.apply(fs, args)\n  }\n\n  if (process.version.substr(0, 4) === 'v0.8') {\n    var legStreams = legacy(fs)\n    ReadStream = legStreams.ReadStream\n    WriteStream = legStreams.WriteStream\n  }\n\n  var fs$ReadStream = fs.ReadStream\n  ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n  ReadStream.prototype.open = ReadStream$open\n\n  var fs$WriteStream = fs.WriteStream\n  WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n  WriteStream.prototype.open = WriteStream$open\n\n  fs.ReadStream = ReadStream\n  fs.WriteStream = WriteStream\n\n  function ReadStream (path, options) {\n    if (this instanceof ReadStream)\n      return fs$ReadStream.apply(this, arguments), this\n    else\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n  }\n\n  function ReadStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        if (that.autoClose)\n          that.destroy()\n\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n        that.read()\n      }\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (this instanceof WriteStream)\n      return fs$WriteStream.apply(this, arguments), this\n    else\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n  }\n\n  function WriteStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        that.destroy()\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n      }\n    })\n  }\n\n  function createReadStream (path, options) {\n    return new ReadStream(path, options)\n  }\n\n  function createWriteStream (path, options) {\n    return new WriteStream(path, options)\n  }\n\n  var fs$open = fs.open\n  fs.open = open\n  function open (path, flags, mode, cb) {\n    if (typeof mode === 'function')\n      cb = mode, mode = null\n\n    return go$open(path, flags, mode, cb)\n\n    function go$open (path, flags, mode, cb) {\n      return fs$open(path, flags, mode, function (err, fd) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$open, [path, flags, mode, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  return fs\n}\n\nfunction enqueue (elem) {\n  debug('ENQUEUE', elem[0].name, elem[1])\n  queue.push(elem)\n}\n\nfunction retry () {\n  var elem = queue.shift()\n  if (elem) {\n    debug('RETRY', elem[0].name, elem[1])\n    elem[0].apply(null, elem[1])\n  }\n}\n","var fs = require('./fs.js')\nvar constants = require('constants')\n\nvar origCwd = process.cwd\nvar cwd = null\n\nvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\n\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\ntry {\n  process.cwd()\n} catch (er) {}\n\nvar chdir = process.chdir\nprocess.chdir = function(d) {\n  cwd = null\n  chdir.call(process, d)\n}\n\nmodule.exports = patch\n\nfunction patch (fs) {\n  // (re-)implement some things that are known busted or missing.\n\n  // lchmod, broken prior to 0.6.2\n  // back-port the fix here.\n  if (constants.hasOwnProperty('O_SYMLINK') &&\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n    patchLchmod(fs)\n  }\n\n  // lutimes implementation, or no-op\n  if (!fs.lutimes) {\n    patchLutimes(fs)\n  }\n\n  // https://github.com/isaacs/node-graceful-fs/issues/4\n  // Chown should not fail on einval or eperm if non-root.\n  // It should not fail on enosys ever, as this just indicates\n  // that a fs doesn't support the intended operation.\n\n  fs.chown = chownFix(fs.chown)\n  fs.fchown = chownFix(fs.fchown)\n  fs.lchown = chownFix(fs.lchown)\n\n  fs.chmod = chmodFix(fs.chmod)\n  fs.fchmod = chmodFix(fs.fchmod)\n  fs.lchmod = chmodFix(fs.lchmod)\n\n  fs.chownSync = chownFixSync(fs.chownSync)\n  fs.fchownSync = chownFixSync(fs.fchownSync)\n  fs.lchownSync = chownFixSync(fs.lchownSync)\n\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\n  fs.stat = statFix(fs.stat)\n  fs.fstat = statFix(fs.fstat)\n  fs.lstat = statFix(fs.lstat)\n\n  fs.statSync = statFixSync(fs.statSync)\n  fs.fstatSync = statFixSync(fs.fstatSync)\n  fs.lstatSync = statFixSync(fs.lstatSync)\n\n  // if lchmod/lchown do not exist, then make them no-ops\n  if (!fs.lchmod) {\n    fs.lchmod = function (path, mode, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchmodSync = function () {}\n  }\n  if (!fs.lchown) {\n    fs.lchown = function (path, uid, gid, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchownSync = function () {}\n  }\n\n  // on Windows, A/V software can lock the directory, causing this\n  // to fail with an EACCES or EPERM if the directory contains newly\n  // created files.  Try again on failure, for up to 60 seconds.\n\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n  // bit9, may lock files for up to a minute, causing npm package install\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n  // CPU to a busy looping process, which can cause the program causing the lock\n  // contention to be starved of CPU by node, so the contention doesn't resolve.\n  if (platform === \"win32\") {\n    fs.rename = (function (fs$rename) { return function (from, to, cb) {\n      var start = Date.now()\n      var backoff = 0;\n      fs$rename(from, to, function CB (er) {\n        if (er\n            && (er.code === \"EACCES\" || er.code === \"EPERM\")\n            && Date.now() - start < 60000) {\n          setTimeout(function() {\n            fs.stat(to, function (stater, st) {\n              if (stater && stater.code === \"ENOENT\")\n                fs$rename(from, to, CB);\n              else\n                cb(er)\n            })\n          }, backoff)\n          if (backoff < 100)\n            backoff += 10;\n          return;\n        }\n        if (cb) cb(er)\n      })\n    }})(fs.rename)\n  }\n\n  // if read() returns EAGAIN, then just try it again.\n  fs.read = (function (fs$read) { return function (fd, buffer, offset, length, position, callback_) {\n    var callback\n    if (callback_ && typeof callback_ === 'function') {\n      var eagCounter = 0\n      callback = function (er, _, __) {\n        if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n        }\n        callback_.apply(this, arguments)\n      }\n    }\n    return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n  }})(fs.read)\n\n  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n    var eagCounter = 0\n    while (true) {\n      try {\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n      } catch (er) {\n        if (er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          continue\n        }\n        throw er\n      }\n    }\n  }})(fs.readSync)\n}\n\nfunction patchLchmod (fs) {\n  fs.lchmod = function (path, mode, callback) {\n    fs.open( path\n           , constants.O_WRONLY | constants.O_SYMLINK\n           , mode\n           , function (err, fd) {\n      if (err) {\n        if (callback) callback(err)\n        return\n      }\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      fs.fchmod(fd, mode, function (err) {\n        fs.close(fd, function(err2) {\n          if (callback) callback(err || err2)\n        })\n      })\n    })\n  }\n\n  fs.lchmodSync = function (path, mode) {\n    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n    // prefer to return the chmod error, if one occurs,\n    // but still try to close, and report closing errors if they occur.\n    var threw = true\n    var ret\n    try {\n      ret = fs.fchmodSync(fd, mode)\n      threw = false\n    } finally {\n      if (threw) {\n        try {\n          fs.closeSync(fd)\n        } catch (er) {}\n      } else {\n        fs.closeSync(fd)\n      }\n    }\n    return ret\n  }\n}\n\nfunction patchLutimes (fs) {\n  if (constants.hasOwnProperty(\"O_SYMLINK\")) {\n    fs.lutimes = function (path, at, mt, cb) {\n      fs.open(path, constants.O_SYMLINK, function (er, fd) {\n        if (er) {\n          if (cb) cb(er)\n          return\n        }\n        fs.futimes(fd, at, mt, function (er) {\n          fs.close(fd, function (er2) {\n            if (cb) cb(er || er2)\n          })\n        })\n      })\n    }\n\n    fs.lutimesSync = function (path, at, mt) {\n      var fd = fs.openSync(path, constants.O_SYMLINK)\n      var ret\n      var threw = true\n      try {\n        ret = fs.futimesSync(fd, at, mt)\n        threw = false\n      } finally {\n        if (threw) {\n          try {\n            fs.closeSync(fd)\n          } catch (er) {}\n        } else {\n          fs.closeSync(fd)\n        }\n      }\n      return ret\n    }\n\n  } else {\n    fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n    fs.lutimesSync = function () {}\n  }\n}\n\nfunction chmodFix (orig) {\n  if (!orig) return orig\n  return function (target, mode, cb) {\n    return orig.call(fs, target, mode, function (er) {\n      if (chownErOk(er)) er = null\n      if (cb) cb.apply(this, arguments)\n    })\n  }\n}\n\nfunction chmodFixSync (orig) {\n  if (!orig) return orig\n  return function (target, mode) {\n    try {\n      return orig.call(fs, target, mode)\n    } catch (er) {\n      if (!chownErOk(er)) throw er\n    }\n  }\n}\n\n\nfunction chownFix (orig) {\n  if (!orig) return orig\n  return function (target, uid, gid, cb) {\n    return orig.call(fs, target, uid, gid, function (er) {\n      if (chownErOk(er)) er = null\n      if (cb) cb.apply(this, arguments)\n    })\n  }\n}\n\nfunction chownFixSync (orig) {\n  if (!orig) return orig\n  return function (target, uid, gid) {\n    try {\n      return orig.call(fs, target, uid, gid)\n    } catch (er) {\n      if (!chownErOk(er)) throw er\n    }\n  }\n}\n\n\nfunction statFix (orig) {\n  if (!orig) return orig\n  // Older versions of Node erroneously returned signed integers for\n  // uid + gid.\n  return function (target, cb) {\n    return orig.call(fs, target, function (er, stats) {\n      if (!stats) return cb.apply(this, arguments)\n      if (stats.uid < 0) stats.uid += 0x100000000\n      if (stats.gid < 0) stats.gid += 0x100000000\n      if (cb) cb.apply(this, arguments)\n    })\n  }\n}\n\nfunction statFixSync (orig) {\n  if (!orig) return orig\n  // Older versions of Node erroneously returned signed integers for\n  // uid + gid.\n  return function (target) {\n    var stats = orig.call(fs, target)\n    if (stats.uid < 0) stats.uid += 0x100000000\n    if (stats.gid < 0) stats.gid += 0x100000000\n    return stats;\n  }\n}\n\n// ENOSYS means that the fs doesn't support the op. Just ignore\n// that, because it doesn't matter.\n//\n// if there's no getuid, or if getuid() is something other\n// than 0, and the error is EINVAL or EPERM, then just ignore\n// it.\n//\n// This specific case is a silent failure in cp, install, tar,\n// and most other unix tools that manage permissions.\n//\n// When running as root, or if other types of errors are\n// encountered, then it's strict.\nfunction chownErOk (er) {\n  if (!er)\n    return true\n\n  if (er.code === \"ENOSYS\")\n    return true\n\n  var nonroot = !process.getuid || process.getuid() !== 0\n  if (nonroot) {\n    if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n      return true\n  }\n\n  return false\n}\n","module.exports = require(\"constants\");","var Stream = require('stream').Stream\n\nmodule.exports = legacy\n\nfunction legacy (fs) {\n  return {\n    ReadStream: ReadStream,\n    WriteStream: WriteStream\n  }\n\n  function ReadStream (path, options) {\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\n    Stream.call(this);\n\n    var self = this;\n\n    this.path = path;\n    this.fd = null;\n    this.readable = true;\n    this.paused = false;\n\n    this.flags = 'r';\n    this.mode = 438; /*=0666*/\n    this.bufferSize = 64 * 1024;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.encoding) this.setEncoding(this.encoding);\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.end === undefined) {\n        this.end = Infinity;\n      } else if ('number' !== typeof this.end) {\n        throw TypeError('end must be a Number');\n      }\n\n      if (this.start > this.end) {\n        throw new Error('start must be <= end');\n      }\n\n      this.pos = this.start;\n    }\n\n    if (this.fd !== null) {\n      process.nextTick(function() {\n        self._read();\n      });\n      return;\n    }\n\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n      if (err) {\n        self.emit('error', err);\n        self.readable = false;\n        return;\n      }\n\n      self.fd = fd;\n      self.emit('open', fd);\n      self._read();\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\n    Stream.call(this);\n\n    this.path = path;\n    this.fd = null;\n    this.writable = true;\n\n    this.flags = 'w';\n    this.encoding = 'binary';\n    this.mode = 438; /*=0666*/\n    this.bytesWritten = 0;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.start < 0) {\n        throw new Error('start must be >= zero');\n      }\n\n      this.pos = this.start;\n    }\n\n    this.busy = false;\n    this._queue = [];\n\n    if (this.fd === null) {\n      this._open = fs.open;\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n      this.flush();\n    }\n  }\n}\n","\nvar thenify = require('thenify')\n\nmodule.exports = thenifyAll\nthenifyAll.withCallback = withCallback\nthenifyAll.thenify = thenify\n\n/**\n * Promisifies all the selected functions in an object.\n *\n * @param {Object} source the source object for the async functions\n * @param {Object} [destination] the destination to set all the promisified methods\n * @param {Array} [methods] an array of method names of `source`\n * @return {Object}\n * @api public\n */\n\nfunction thenifyAll(source, destination, methods) {\n  return promisifyAll(source, destination, methods, thenify)\n}\n\n/**\n * Promisifies all the selected functions in an object and backward compatible with callback.\n *\n * @param {Object} source the source object for the async functions\n * @param {Object} [destination] the destination to set all the promisified methods\n * @param {Array} [methods] an array of method names of `source`\n * @return {Object}\n * @api public\n */\n\nfunction withCallback(source, destination, methods) {\n  return promisifyAll(source, destination, methods, thenify.withCallback)\n}\n\nfunction promisifyAll(source, destination, methods, promisify) {\n  if (!destination) {\n    destination = {};\n    methods = Object.keys(source)\n  }\n\n  if (Array.isArray(destination)) {\n    methods = destination\n    destination = {}\n  }\n\n  if (!methods) {\n    methods = Object.keys(source)\n  }\n\n  if (typeof source === 'function') destination = promisify(source)\n\n  methods.forEach(function (name) {\n    // promisify only if it's a function\n    if (typeof source[name] === 'function') destination[name] = promisify(source[name])\n  })\n\n  // proxy the rest\n  Object.keys(source).forEach(function (name) {\n    if (deprecated(source, name)) return\n    if (destination[name]) return\n    destination[name] = source[name]\n  })\n\n  return destination\n}\n\nfunction deprecated(source, name) {\n  var desc = Object.getOwnPropertyDescriptor(source, name)\n  if (!desc || !desc.get) return false\n  if (desc.get.name === 'deprecated') return true\n  return false\n}\n","\nvar Promise = require('any-promise')\nvar assert = require('assert')\n\nmodule.exports = thenify\n\n/**\n * Turn async functions into promises\n *\n * @param {Function} $$__fn__$$\n * @return {Function}\n * @api public\n */\n\nfunction thenify($$__fn__$$, options) {\n  assert(typeof $$__fn__$$ === 'function')\n  return eval(createWrapper($$__fn__$$.name, options))\n}\n\n/**\n * Turn async functions into promises and backward compatible with callback\n *\n * @param {Function} $$__fn__$$\n * @return {Function}\n * @api public\n */\n\nthenify.withCallback = function ($$__fn__$$, options) {\n  assert(typeof $$__fn__$$ === 'function')\n  options = options || {}\n  options.withCallback = true\n  if (options.multiArgs === undefined) options.multiArgs = true\n  return eval(createWrapper($$__fn__$$.name, options))\n}\n\nfunction createCallback(resolve, reject, multiArgs) {\n  return function(err, value) {\n    if (err) return reject(err)\n    var length = arguments.length\n\n    if (length <= 2 || !multiArgs) return resolve(value)\n\n    if (Array.isArray(multiArgs)) {\n      var values = {}\n      for (var i = 1; i < length; i++) values[multiArgs[i - 1]] = arguments[i]\n      return resolve(values)\n    }\n\n    var values = new Array(length - 1)\n    for (var i = 1; i < length; ++i) values[i - 1] = arguments[i]\n    resolve(values)\n  }\n}\n\nfunction createWrapper(name, options) {\n  name = (name || '').replace(/\\s|bound(?!$)/g, '')\n  options = options || {}\n  // default to true\n  var multiArgs = options.multiArgs !== undefined ? options.multiArgs : true\n  multiArgs = 'var multiArgs = ' + JSON.stringify(multiArgs) + '\\n'\n\n  var withCallback = options.withCallback ?\n    'var lastType = typeof arguments[len - 1]\\n'\n    + 'if (lastType === \"function\") return $$__fn__$$.apply(self, arguments)\\n'\n   : ''\n\n  return '(function ' + name + '() {\\n'\n    + 'var self = this\\n'\n    + 'var len = arguments.length\\n'\n    + multiArgs\n    + withCallback\n    + 'var args = new Array(len + 1)\\n'\n    + 'for (var i = 0; i < len; ++i) args[i] = arguments[i]\\n'\n    + 'var lastIndex = i\\n'\n    + 'return new Promise(function (resolve, reject) {\\n'\n      + 'args[lastIndex] = createCallback(resolve, reject, multiArgs)\\n'\n      + '$$__fn__$$.apply(self, args)\\n'\n    + '})\\n'\n  + '})'\n}\n","import { BaseSession } from 'terminus-terminal'\n\nexport interface LoginScript {\n    expect?: string\n    send: string\n    isRegex?: boolean\n    optional?: boolean\n}\n\nexport interface SSHConnection {\n    name?: string\n    host: string\n    port: number\n    user: string\n    password?: string\n    privateKey?: string\n    group?: string\n    scripts?: LoginScript[]\n    keepaliveInterval?: number\n    keepaliveCountMax?: number\n    readyTimeout?: number\n}\n\nexport class SSHSession extends BaseSession {\n    scripts?: LoginScript[]\n\n    constructor (private shell: any, conn: SSHConnection) {\n        super()\n        this.scripts = conn.scripts || []\n    }\n\n    start () {\n        this.open = true\n\n        this.shell.on('data', data => {\n            let dataString = data.toString()\n            this.emitOutput(dataString)\n\n            if (this.scripts) {\n                let found = false\n                for (let script of this.scripts) {\n                    let match = false\n                    let cmd = ''\n                    if (script.isRegex) {\n                        let re = new RegExp(script.expect, 'g')\n                        if (dataString.match(re)) {\n                            cmd = dataString.replace(re, script.send)\n                            match = true\n                            found = true\n                        }\n                    } else {\n                        if (dataString.includes(script.expect)) {\n                            cmd = script.send\n                            match = true\n                            found = true\n                        }\n                    }\n\n                    if (match) {\n                        console.log('Executing script: \"' + cmd + '\"')\n                        this.shell.write(cmd + '\\n')\n                        this.scripts = this.scripts.filter(x => x !== script)\n                    } else {\n                        if (script.optional) {\n                            console.log('Skip optional script: ' + script.expect)\n                            found = true\n                            this.scripts = this.scripts.filter(x => x !== script)\n                        } else {\n                            break\n                        }\n                    }\n                }\n\n                if (found) {\n                    this.executeUnconditionalScripts()\n                }\n            }\n        })\n\n        this.shell.on('end', () => {\n            if (this.open) {\n                this.destroy()\n            }\n        })\n\n        this.executeUnconditionalScripts()\n    }\n\n    resize (columns, rows) {\n        this.shell.setWindow(rows, columns)\n    }\n\n    write (data) {\n        this.shell.write(data)\n    }\n\n    kill (signal?: string) {\n        this.shell.signal(signal || 'TERM')\n    }\n\n    async getChildProcesses (): Promise<any[]> {\n        return []\n    }\n\n    async gracefullyKillProcess (): Promise<void> {\n        this.kill('TERM')\n    }\n\n    async getWorkingDirectory (): Promise<string> {\n        return null\n    }\n\n    private executeUnconditionalScripts () {\n        if (this.scripts) {\n            for (let script of this.scripts) {\n                if (!script.expect) {\n                    console.log('Executing script:', script.send)\n                    this.shell.write(script.send + '\\n')\n                    this.scripts = this.scripts.filter(x => x !== script)\n                } else {\n                    break\n                }\n            }\n        }\n    }\n}\n\nexport interface ISSHConnectionGroup {\n    name: string\n    connections: SSHConnection[]\n}\n","var pug = require(\"!../../../node_modules/pug-runtime/index.js\");\n\nfunction template(locals) {var pug_html = \"\", pug_mixins = {}, pug_interp;pug_html = pug_html + \"\\u003Cdiv class=\\\"modal-body\\\"\\u003E\\u003Cinput class=\\\"form-control\\\" [type]=\\\"password ? &quot;password&quot; : &quot;text&quot;\\\" autofocus [(ngModel)]=\\\"value\\\" #input [placeholder]=\\\"prompt\\\" (keyup.enter)=\\\"ok()\\\" (keyup.esc)=\\\"cancel()\\\"\\u003E\\u003C\\u002Fdiv\\u003E\";;return pug_html;};\nmodule.exports = template;\n\nmodule.exports = module.exports.apply(module, [])","var pug = require(\"!../../../node_modules/pug-runtime/index.js\");\n\nfunction template(locals) {var pug_html = \"\", pug_mixins = {}, pug_interp;pug_html = pug_html + \"\\u003Cdiv class=\\\"modal-body\\\"\\u003E\\u003Cinput class=\\\"form-control\\\" type=\\\"text\\\" [(ngModel)]=\\\"quickTarget\\\" autofocus placeholder=\\\"Quick connect: [user@]host[:port]\\\" (ngModelChange)=\\\"refresh()\\\" (keyup.enter)=\\\"quickConnect()\\\"\\u003E\\u003Cdiv class=\\\"list-group mt-3\\\" *ngIf=\\\"lastConnection\\\"\\u003E\\u003Ca class=\\\"list-group-item list-group-item-action d-flex align-items-center\\\" (click)=\\\"connect(lastConnection)\\\"\\u003E \\u003Ci class=\\\"fa fa-fw fa-history\\\"\\u003E\\u003C\\u002Fi\\u003E\\u003Cdiv class=\\\"mr-auto\\\"\\u003E{{lastConnection.name}}\\u003C\\u002Fdiv\\u003E\\u003Cbutton class=\\\"btn btn-outline-danger btn-sm\\\" (click)=\\\"clearLastConnection(); $event.stopPropagation()\\\"\\u003E\\u003Ci class=\\\"fa fa-trash-o\\\"\\u003E\\u003C\\u002Fi\\u003E\\u003C\\u002Fbutton\\u003E\\u003C\\u002Fa\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"list-group mt-3 connections-list\\\" *ngIf=\\\"childGroups.length\\\"\\u003E\\u003Cng-container *ngFor=\\\"let group of childGroups\\\"\\u003E \\u003Cdiv class=\\\"list-group-item list-group-item-action d-flex align-items-center\\\" (click)=\\\"groupCollapsed[group.name] = !groupCollapsed[group.name]\\\"\\u003E\\u003Cdiv class=\\\"fa fa-fw fa-chevron-right\\\" *ngIf=\\\"groupCollapsed[group.name]\\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"fa fa-fw fa-chevron-down\\\" *ngIf=\\\"!groupCollapsed[group.name]\\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"ml-2\\\"\\u003E{{group.name || \\\"Ungrouped\\\"}}\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cng-container *ngIf=\\\"!groupCollapsed[group.name]\\\"\\u003E\\u003Cdiv class=\\\"list-group-item list-group-item-action pl-5 d-flex align-items-center\\\" *ngFor=\\\"let connection of group.connections\\\" (click)=\\\"connect(connection)\\\"\\u003E{{connection.name}}\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fng-container\\u003E\\u003C\\u002Fng-container\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\";;return pug_html;};\nmodule.exports = template;\n\nmodule.exports = module.exports.apply(module, [])","\n        var result = require(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/lib/loader.js!./sshModal.component.scss\");\n\n        if (typeof result === \"string\") {\n            module.exports = result;\n        } else {\n            module.exports = result.toString();\n        }\n    ","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(undefined);\n// imports\n\n\n// module\nexports.push([module.id, \".list-group.connections-list {\\n  display: block;\\n  max-height: 70vh;\\n  overflow-y: auto; }\\n\", \"\"]);\n\n// exports\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap) {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n  var base64 = new Buffer(JSON.stringify(sourceMap)).toString('base64');\n  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n  return '/*# ' + data + ' */';\n}\n","var pug = require(\"!../../../node_modules/pug-runtime/index.js\");\n\nfunction template(locals) {var pug_html = \"\", pug_mixins = {}, pug_interp;pug_html = pug_html + \"\\u003Ch3\\u003EConnections\\u003C\\u002Fh3\\u003E\\u003Cdiv class=\\\"list-group mt-3 mb-3\\\"\\u003E\\u003Cng-container *ngFor=\\\"let group of childGroups\\\"\\u003E \\u003Cdiv class=\\\"list-group-item list-group-item-action d-flex align-items-center\\\" (click)=\\\"groupCollapsed[group.name] = !groupCollapsed[group.name]\\\"\\u003E\\u003Cdiv class=\\\"fa fa-fw fa-chevron-right\\\" *ngIf=\\\"groupCollapsed[group.name]\\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"fa fa-fw fa-chevron-down\\\" *ngIf=\\\"!groupCollapsed[group.name]\\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cspan class=\\\"ml-3 mr-auto\\\"\\u003E{{group.name || \\\"Ungrouped\\\"}}\\u003C\\u002Fspan\\u003E\\u003Cbutton class=\\\"btn btn-outline-info ml-2\\\" (click)=\\\"editGroup(group)\\\"\\u003E\\u003Ci class=\\\"fa fa-pencil\\\"\\u003E\\u003C\\u002Fi\\u003E\\u003C\\u002Fbutton\\u003E\\u003Cbutton class=\\\"btn btn-outline-danger ml-1\\\" (click)=\\\"deleteGroup(group)\\\"\\u003E\\u003Ci class=\\\"fa fa-trash-o\\\"\\u003E\\u003C\\u002Fi\\u003E\\u003C\\u002Fbutton\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cng-container *ngIf=\\\"!groupCollapsed[group.name]\\\"\\u003E\\u003Cdiv class=\\\"list-group-item pl-5 d-flex align-items-center\\\" *ngFor=\\\"let connection of group.connections\\\"\\u003E \\u003Cdiv class=\\\"mr-auto\\\"\\u003E\\u003Cdiv\\u003E{{connection.name}}\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"text-muted\\\"\\u003E{{connection.host}}\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cbutton class=\\\"btn btn-outline-info ml-2\\\" (click)=\\\"editConnection(connection)\\\"\\u003E\\u003Ci class=\\\"fa fa-pencil\\\"\\u003E\\u003C\\u002Fi\\u003E\\u003C\\u002Fbutton\\u003E\\u003Cbutton class=\\\"btn btn-outline-danger ml-1\\\" (click)=\\\"deleteConnection(connection)\\\"\\u003E\\u003Ci class=\\\"fa fa-trash-o\\\"\\u003E\\u003C\\u002Fi\\u003E\\u003C\\u002Fbutton\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fng-container\\u003E\\u003C\\u002Fng-container\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cbutton class=\\\"btn btn-outline-primary\\\" (click)=\\\"createConnection()\\\"\\u003E\\u003Cdiv class=\\\"fa fa-fw fa-globe\\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cspan class=\\\"ml-2\\\"\\u003EAdd connection\\u003C\\u002Fspan\\u003E\\u003C\\u002Fbutton\\u003E\";;return pug_html;};\nmodule.exports = template;\n\nmodule.exports = module.exports.apply(module, [])","import { Injectable } from '@angular/core'\nimport { DomSanitizer } from '@angular/platform-browser'\nimport { NgbModal } from '@ng-bootstrap/ng-bootstrap'\nimport { HotkeysService, ToolbarButtonProvider, IToolbarButton } from 'terminus-core'\nimport { SSHModalComponent } from './components/sshModal.component'\n\n@Injectable()\nexport class ButtonProvider extends ToolbarButtonProvider {\n    constructor (\n        private ngbModal: NgbModal,\n        private domSanitizer: DomSanitizer,\n        hotkeys: HotkeysService,\n    ) {\n        super()\n        hotkeys.matchedHotkey.subscribe(async (hotkey) => {\n            if (hotkey === 'ssh') {\n                this.activate()\n            }\n        })\n    }\n\n    activate () {\n        this.ngbModal.open(SSHModalComponent)\n    }\n\n    provide (): IToolbarButton[] {\n        return [{\n            icon: this.domSanitizer.bypassSecurityTrustHtml(require('./icons/globe.svg')),\n            weight: 5,\n            title: 'SSH connections',\n            touchBarNSImage: 'NSTouchBarOpenInBrowserTemplate',\n            click: async () => {\n                this.activate()\n            }\n        }]\n    }\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__75__;","module.exports = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 496 512\\\"><path d=\\\"M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm179.3 160h-67.2c-6.7-36.5-17.5-68.8-31.2-94.7 42.9 19 77.7 52.7 98.4 94.7zM248 56c18.6 0 48.6 41.2 63.2 112H184.8C199.4 97.2 229.4 56 248 56zM48 256c0-13.7 1.4-27.1 4-40h77.7c-1 13.1-1.7 26.3-1.7 40s.7 26.9 1.7 40H52c-2.6-12.9-4-26.3-4-40zm20.7 88h67.2c6.7 36.5 17.5 68.8 31.2 94.7-42.9-19-77.7-52.7-98.4-94.7zm67.2-176H68.7c20.7-42 55.5-75.7 98.4-94.7-13.7 25.9-24.5 58.2-31.2 94.7zM248 456c-18.6 0-48.6-41.2-63.2-112h126.5c-14.7 70.8-44.7 112-63.3 112zm70.1-160H177.9c-1.1-12.8-1.9-26-1.9-40s.8-27.2 1.9-40h140.3c1.1 12.8 1.9 26 1.9 40s-.9 27.2-2 40zm10.8 142.7c13.7-25.9 24.4-58.2 31.2-94.7h67.2c-20.7 42-55.5 75.7-98.4 94.7zM366.3 296c1-13.1 1.7-26.3 1.7-40s-.7-26.9-1.7-40H444c2.6 12.9 4 26.3 4 40s-1.4 27.1-4 40h-77.7z\\\"></path></svg>\"","import { ConfigProvider } from 'terminus-core'\n\nexport class SSHConfigProvider extends ConfigProvider {\n    defaults = {\n        ssh: {\n            connections: [],\n            options: {\n            }\n        },\n        hotkeys: {\n            'ssh': [\n                'Alt-S',\n            ],\n        },\n    }\n\n    platformDefaults = { }\n}\n","import { Injectable } from '@angular/core'\nimport { SettingsTabProvider } from 'terminus-settings'\n\nimport { SSHSettingsTabComponent } from './components/sshSettingsTab.component'\n\n@Injectable()\nexport class SSHSettingsTabProvider extends SettingsTabProvider {\n    id = 'ssh'\n    title = 'SSH'\n\n    getComponentType (): any {\n        return SSHSettingsTabComponent\n    }\n}\n"],"sourceRoot":""}